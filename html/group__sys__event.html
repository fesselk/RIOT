<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Event Queue</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        displaySR();
                    }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sys__event.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event Queue<div class="ingroups"><a class="el" href="group__sys.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides an Event loop.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides an Event loop. </p>
<p>This module offers an event queue framework like libevent or libuev.</p>
<p>An event queue is basically a FIFO queue of events, with some functions to efficiently and safely handle adding and getting events to / from such a queue.</p>
<p>An event queue is bound to a thread, but any thread or ISR can put events into a queue. In most cases, the owning thread of a queue is set during the queue's initialization. But it is also possible to initialize a queue in a detached state from a different context and to set the owning thread at a later point of time using the <a class="el" href="group__sys__event.html#ga901462dc0093b6da40ec2fa787ac704f" title="Bind an event queue to the calling thread.">event_queue_claim()</a> function.</p>
<p>An event is a structure containing a pointer to an event handler. It can be extended to provide context or arguments to the handler. It can also be embedded into existing structures (see examples).</p>
<p>Compared to msg or mbox, this some fundamental differences:</p>
<ol type="1">
<li>events are "sender allocated". Unlike <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8" title="Send a message (blocking).">msg_send()</a>, <a class="el" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba" title="Queue an event.">event_post()</a> never blocks or fails.</li>
<li>events contain everything necessary to handle them, thus a thread processing the events of an event queue doesn't need to be changed in order to support new event types.</li>
<li>events can be safely used (and actually perform best) when used within one thread, e.g., in order to create a state-machine like process flow. This is not (easily) possible using msg queues, as they might fill up.</li>
<li>an event can only be queued in one event queue at the same time. Notifying many queues using only one event object is not possible with this implementation.</li>
</ol>
<p>At the core, <a class="el" href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3" title="Get next event from event queue, blocking.">event_wait()</a> uses thread flags to implement waiting for events to be queued. Thus event queues can be used safely and efficiently in combination with thread flags and msg queues.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// simple event handler</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handler(<a class="code" href="structevent.html">event_t</a> *<a class="code" href="structevent.html">event</a>)</div>
<div class="line">{</div>
<div class="line">   printf(<span class="stringliteral">&quot;triggered 0x%08x\n&quot;</span>, (<span class="keywordtype">unsigned</span>)<a class="code" href="structevent.html">event</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code" href="structevent.html">event_t</a> <span class="keyword">event</span> = { .<a class="code" href="structevent.html#a09014dfe22d45e0d11b3d71f0361dbb7">handler</a> = handler };</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="structevent__queue__t.html">event_queue_t</a> queue;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>(&amp;queue);</div>
<div class="line">    <a class="code" href="group__sys__event.html#ga321751eb630a363f187305e098229e7d">event_loop</a>(&amp;queue);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[...] <a class="code" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a>(&amp;queue, &amp;<a class="code" href="structevent.html">event</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// example for event extended event struct</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <a class="code" href="structevent.html">event_t</a> super;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *text;</div>
<div class="line">} custom_event_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> custom_handler(<a class="code" href="structevent.html">event_t</a> *<a class="code" href="structevent.html">event</a>)</div>
<div class="line">{</div>
<div class="line">    custom_event_t *custom_event = (custom_event_t *)<a class="code" href="structevent.html">event</a>;</div>
<div class="line">    printf(<span class="stringliteral">&quot;triggered custom event with text: \&quot;%s\&quot;\n&quot;</span>, custom_event-&gt;text);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> custom_event_t custom_event = { .super.handler = custom_handler, .text = <span class="stringliteral">&quot;CUSTOM EVENT&quot;</span> };</div>
<div class="line"> </div>
<div class="line">[...] <a class="code" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a>(&amp;queue, &amp;custom_event)</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:callback_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="callback_8h.html">callback.h</a></td></tr>
<tr class="memdesc:callback_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a callback-with-argument event type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sys_2include_2event_2thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_2include_2event_2thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:sys_2include_2event_2thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides utility functions for event handler threads. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_2timeout_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_2timeout_8h.html">timeout.h</a></td></tr>
<tr class="memdesc:event_2timeout_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality to trigger events after timeout. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html">event.h</a></td></tr>
<tr class="memdesc:event_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent.html">event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">event structure  <a href="structevent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__queue__t.html">event_queue_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">event queue structure  <a href="structevent__queue__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="memItemLeft" align="right" valign="top"><a id="gaafa9b96ad0e2d68d166b6ba394660a4b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaafa9b96ad0e2d68d166b6ba394660a4b">THREAD_FLAG_EVENT</a>&#160;&#160;&#160;(0x1)</td></tr>
<tr class="memdesc:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structThread.html" title="Thread struct within mqtt paho.">Thread</a> flag use to notify available events in an event queue. <br /></td></tr>
<tr class="separator:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc0919266554541d5723bed79b1e3ed"><td class="memItemLeft" align="right" valign="top"><a id="gafbc0919266554541d5723bed79b1e3ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gafbc0919266554541d5723bed79b1e3ed">EVENT_QUEUE_INIT</a>&#160;&#160;&#160;{ .waiter = <a class="el" href="group__core__thread.html#ga605ef75cf40c9116339ba8ef54193e4c">thread_get_active</a>() }</td></tr>
<tr class="memdesc:gafbc0919266554541d5723bed79b1e3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structevent__queue__t.html" title="event queue structure">event_queue_t</a> static initializer <br /></td></tr>
<tr class="separator:gafbc0919266554541d5723bed79b1e3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e41a0654cf42441ef0a640053894911"><td class="memItemLeft" align="right" valign="top"><a id="ga4e41a0654cf42441ef0a640053894911"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga4e41a0654cf42441ef0a640053894911">EVENT_QUEUE_INIT_DETACHED</a>&#160;&#160;&#160;{ .waiter = NULL }</td></tr>
<tr class="memdesc:ga4e41a0654cf42441ef0a640053894911"><td class="mdescLeft">&#160;</td><td class="mdescRight">static initializer for detached event queues <br /></td></tr>
<tr class="separator:ga4e41a0654cf42441ef0a640053894911"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad0c066ffb009d3286186a124d37a0c2d"><td class="memItemLeft" align="right" valign="top"><a id="gad0c066ffb009d3286186a124d37a0c2d"></a>
typedef struct <a class="el" href="structevent.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a></td></tr>
<tr class="memdesc:gad0c066ffb009d3286186a124d37a0c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">event structure forward declaration <br /></td></tr>
<tr class="separator:gad0c066ffb009d3286186a124d37a0c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c9f34f565c834ed82a585d154d0010"><td class="memItemLeft" align="right" valign="top"><a id="ga60c9f34f565c834ed82a585d154d0010"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga60c9f34f565c834ed82a585d154d0010">event_handler_t</a>) (<a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *)</td></tr>
<tr class="memdesc:ga60c9f34f565c834ed82a585d154d0010"><td class="mdescLeft">&#160;</td><td class="mdescRight">event handler type definition <br /></td></tr>
<tr class="separator:ga60c9f34f565c834ed82a585d154d0010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad0b53659c2fbf312ff1a47782a42e0cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gad0b53659c2fbf312ff1a47782a42e0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of event queues.  <a href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">More...</a><br /></td></tr>
<tr class="separator:gad0b53659c2fbf312ff1a47782a42e0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609d4085b10b48c8b8725dab5b465896"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga609d4085b10b48c8b8725dab5b465896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an event queue.  <a href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">More...</a><br /></td></tr>
<tr class="separator:ga609d4085b10b48c8b8725dab5b465896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3402e5ea1b6f2682b7e4f6a8294150"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaba3402e5ea1b6f2682b7e4f6a8294150">event_queues_init_detached</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gaba3402e5ea1b6f2682b7e4f6a8294150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of event queues not binding it to a thread.  <a href="group__sys__event.html#gaba3402e5ea1b6f2682b7e4f6a8294150">More...</a><br /></td></tr>
<tr class="separator:gaba3402e5ea1b6f2682b7e4f6a8294150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abb6e200225ac747dcccc071add6a24"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga7abb6e200225ac747dcccc071add6a24">event_queue_init_detached</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga7abb6e200225ac747dcccc071add6a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an event queue not binding it to a thread.  <a href="group__sys__event.html#ga7abb6e200225ac747dcccc071add6a24">More...</a><br /></td></tr>
<tr class="separator:ga7abb6e200225ac747dcccc071add6a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f1745747ef9c13022aa925eead68cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaa3f1745747ef9c13022aa925eead68cd">event_queues_claim</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gaa3f1745747ef9c13022aa925eead68cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an array of event queues to the calling thread.  <a href="group__sys__event.html#gaa3f1745747ef9c13022aa925eead68cd">More...</a><br /></td></tr>
<tr class="separator:gaa3f1745747ef9c13022aa925eead68cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901462dc0093b6da40ec2fa787ac704f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga901462dc0093b6da40ec2fa787ac704f">event_queue_claim</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga901462dc0093b6da40ec2fa787ac704f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an event queue to the calling thread.  <a href="group__sys__event.html#ga901462dc0093b6da40ec2fa787ac704f">More...</a><br /></td></tr>
<tr class="separator:ga901462dc0093b6da40ec2fa787ac704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2053ce1facf709fffd024bee9e2383ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="memdesc:ga2053ce1facf709fffd024bee9e2383ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue an event.  <a href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">More...</a><br /></td></tr>
<tr class="separator:ga2053ce1facf709fffd024bee9e2383ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696280baa5719e3c5ef75fec41e81b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga696280baa5719e3c5ef75fec41e81b3a">event_cancel</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="memdesc:ga696280baa5719e3c5ef75fec41e81b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a queued event.  <a href="group__sys__event.html#ga696280baa5719e3c5ef75fec41e81b3a">More...</a><br /></td></tr>
<tr class="separator:ga696280baa5719e3c5ef75fec41e81b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b6336946a171046f7626f476fba292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gae5b6336946a171046f7626f476fba292">event_get</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gae5b6336946a171046f7626f476fba292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, non-blocking.  <a href="group__sys__event.html#gae5b6336946a171046f7626f476fba292">More...</a><br /></td></tr>
<tr class="separator:gae5b6336946a171046f7626f476fba292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf549606f1a9059f0b1b0cef87ca6a95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b">event_wait_multi</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gaf549606f1a9059f0b1b0cef87ca6a95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from the given event queues, blocking.  <a href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b">More...</a><br /></td></tr>
<tr class="separator:gaf549606f1a9059f0b1b0cef87ca6a95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8c9a1fbf3ffc656a1ab53ab1585df3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">event_wait</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga1a8c9a1fbf3ffc656a1ab53ab1585df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking.  <a href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">More...</a><br /></td></tr>
<tr class="separator:ga1a8c9a1fbf3ffc656a1ab53ab1585df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaf979ad68f1d4ef379de1f0da0644ff72">event_wait_timeout</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, uint32_t timeout)</td></tr>
<tr class="memdesc:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking until timeout expires.  <a href="group__sys__event.html#gaf979ad68f1d4ef379de1f0da0644ff72">More...</a><br /></td></tr>
<tr class="separator:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22551716e8df163590e16bf2cc5ff590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga22551716e8df163590e16bf2cc5ff590">event_wait_timeout64</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, uint64_t timeout)</td></tr>
<tr class="memdesc:ga22551716e8df163590e16bf2cc5ff590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking until timeout expires.  <a href="group__sys__event.html#ga22551716e8df163590e16bf2cc5ff590">More...</a><br /></td></tr>
<tr class="separator:ga22551716e8df163590e16bf2cc5ff590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d52cdf6e7593e240311a119ca076f7e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga1d52cdf6e7593e240311a119ca076f7e">event_loop_multi</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:ga1d52cdf6e7593e240311a119ca076f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple event loop with multiple queues.  <a href="group__sys__event.html#ga1d52cdf6e7593e240311a119ca076f7e">More...</a><br /></td></tr>
<tr class="separator:ga1d52cdf6e7593e240311a119ca076f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga321751eb630a363f187305e098229e7d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga321751eb630a363f187305e098229e7d">event_loop</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga321751eb630a363f187305e098229e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple event loop.  <a href="group__sys__event.html#ga321751eb630a363f187305e098229e7d">More...</a><br /></td></tr>
<tr class="separator:ga321751eb630a363f187305e098229e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga696280baa5719e3c5ef75fec41e81b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga696280baa5719e3c5ef75fec41e81b3a">&#9670;&nbsp;</a></span>event_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a queued event. </p>
<p>This will remove a queued event from an event queue.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the underlying list implementation, this will run in O(n).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to remove event from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event to remove from queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5b6336946a171046f7626f476fba292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b6336946a171046f7626f476fba292">&#9670;&nbsp;</a></span>event_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, non-blocking. </p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to get event from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd>
<dd>
NULL if no event available </dd></dl>

</div>
</div>
<a id="ga321751eb630a363f187305e098229e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga321751eb630a363f187305e098229e7d">&#9670;&nbsp;</a></span>event_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple event loop. </p>
<p>This function will forever sit in a loop, waiting for events to be queued and executing their handlers.</p>
<p>It is pretty much defined as:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> ((<a class="code" href="structevent.html">event</a> = <a class="code" href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">event_wait</a>(queue))) {</div>
<div class="line">    <span class="keyword">event</span>-&gt;handler(<a class="code" href="structevent.html">event</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to process </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00404">404</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga1d52cdf6e7593e240311a119ca076f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d52cdf6e7593e240311a119ca076f7e">&#9670;&nbsp;</a></span>event_loop_multi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_loop_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple event loop with multiple queues. </p>
<p>This function will forever sit in a loop, waiting for events to be queued and executing their handlers. If more than one queue contains an event, the queue with the lowest index is chosen. Thus, a lower index in the <code>queues</code> array translates into a higher priority of the queue.</p>
<p>It is pretty much defined as:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> ((<a class="code" href="structevent.html">event</a> = <a class="code" href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b">event_wait_multi</a>(queues, n_queues))) {</div>
<div class="line">    <span class="keyword">event</span>-&gt;handler(<a class="code" href="structevent.html">event</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b" title="Get next event from the given event queues, blocking.">event_wait_multi</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Event queues to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>Number of queues passed with <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00379">379</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga2053ce1facf709fffd024bee9e2383ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2053ce1facf709fffd024bee9e2383ba">&#9670;&nbsp;</a></span>event_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue an event. </p>
<p>The given event will be posted on the given <code>queue</code>. If the event is already queued when calling this function, the event will not be touched and remain in the previous position on the queue. So reposting an event while it is already on the queue will have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to queue event in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event to queue in event queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga901462dc0093b6da40ec2fa787ac704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901462dc0093b6da40ec2fa787ac704f">&#9670;&nbsp;</a></span>event_queue_claim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queue_claim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an event queue to the calling thread. </p>
<p>This function must only be called once and only if the given queue is not yet bound to a thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>(queue-&gt;waiter == NULL)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to bind to a thread </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00243">243</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga609d4085b10b48c8b8725dab5b465896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609d4085b10b48c8b8725dab5b465896">&#9670;&nbsp;</a></span>event_queue_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queue_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an event queue. </p>
<p>This will set the calling thread as owner of <code>queue</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to initialize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00182">182</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga7abb6e200225ac747dcccc071add6a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7abb6e200225ac747dcccc071add6a24">&#9670;&nbsp;</a></span>event_queue_init_detached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queue_init_detached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an event queue not binding it to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to initialize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00207">207</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gaa3f1745747ef9c13022aa925eead68cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f1745747ef9c13022aa925eead68cd">&#9670;&nbsp;</a></span>event_queues_claim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queues_claim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an array of event queues to the calling thread. </p>
<p>This function must only be called once and only if the given queue is not yet bound to a thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>(queues[i].waiter == NULL for i in {0, ..., n_queues - 1})</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>event queue objects to bind to a thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>number of queues in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00223">223</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gad0b53659c2fbf312ff1a47782a42e0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0b53659c2fbf312ff1a47782a42e0cb">&#9670;&nbsp;</a></span>event_queues_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queues_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an array of event queues. </p>
<p>This will set the calling thread as owner of each queue in <code>queues</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>event queue objects to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>number of queues in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00164">164</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gaba3402e5ea1b6f2682b7e4f6a8294150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba3402e5ea1b6f2682b7e4f6a8294150">&#9670;&nbsp;</a></span>event_queues_init_detached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queues_init_detached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an array of event queues not binding it to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>event queue objects to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>number of queues in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00193">193</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga1a8c9a1fbf3ffc656a1ab53ab1585df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">&#9670;&nbsp;</a></span>event_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking. </p>
<p>This function will block until an event becomes available.</p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="section warning"><dt>Warning</dt><dd>There can only be a single waiter on a queue!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to get event from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd></dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00329">329</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gaf549606f1a9059f0b1b0cef87ca6a95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf549606f1a9059f0b1b0cef87ca6a95b">&#9670;&nbsp;</a></span>event_wait_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from the given event queues, blocking. </p>
<p>This function will block until an event becomes available. If more than one queue contains an event, the queue with the lowest index is chosen. Thus, a lower index in the <code>queues</code> array translates into a higher priority of the queue.</p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="section warning"><dt>Warning</dt><dd>There can only be a single waiter on a queue!</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function <em>can</em> be suitable for having a single thread handling both real-time and non-real-time events. However, a real time event can be delayed for the whole duration a single non-real-time event takes (in addition to all other sources of latency). Thus, the slowest to handle non-real-time event must still execute fast enough to add an amount of latency (on top of other sources of latency) that is acceptable to the real-time event with the strictest requirements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Array of event queues to get event from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>Number of event queues passed in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd></dl>

</div>
</div>
<a id="gaf979ad68f1d4ef379de1f0da0644ff72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf979ad68f1d4ef379de1f0da0644ff72">&#9670;&nbsp;</a></span>event_wait_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking until timeout expires. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to query for an event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum time to wait for an event to be posted in us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event if event was taken from the queue </dd>
<dd>
NULL if timeout expired before an event was posted </dd></dl>

</div>
</div>
<a id="ga22551716e8df163590e16bf2cc5ff590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22551716e8df163590e16bf2cc5ff590">&#9670;&nbsp;</a></span>event_wait_timeout64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_timeout64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking until timeout expires. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to query for an event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum time to wait for an event to be posted in us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event if event was taken from the queue </dd>
<dd>
NULL if timeout expired before an event was posted </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__sys__event_html_ga609d4085b10b48c8b8725dab5b465896"><div class="ttname"><a href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a></div><div class="ttdeci">static void event_queue_init(event_queue_t *queue)</div><div class="ttdoc">Initialize an event queue.</div><div class="ttdef"><b>Definition:</b> <a href="event_8h_source.html#l00182">event.h:182</a></div></div>
<div class="ttc" id="astructevent_html"><div class="ttname"><a href="structevent.html">event</a></div><div class="ttdoc">event structure</div><div class="ttdef"><b>Definition:</b> <a href="event_8h_source.html#l00142">event.h:142</a></div></div>
<div class="ttc" id="agroup__sys__event_html_ga321751eb630a363f187305e098229e7d"><div class="ttname"><a href="group__sys__event.html#ga321751eb630a363f187305e098229e7d">event_loop</a></div><div class="ttdeci">static void event_loop(event_queue_t *queue)</div><div class="ttdoc">Simple event loop.</div><div class="ttdef"><b>Definition:</b> <a href="event_8h_source.html#l00404">event.h:404</a></div></div>
<div class="ttc" id="astructevent__queue__t_html"><div class="ttname"><a href="structevent__queue__t.html">event_queue_t</a></div><div class="ttdoc">event queue structure</div><div class="ttdef"><b>Definition:</b> <a href="event_8h_source.html#l00150">event.h:150</a></div></div>
<div class="ttc" id="agroup__sys__event_html_gaf549606f1a9059f0b1b0cef87ca6a95b"><div class="ttname"><a href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b">event_wait_multi</a></div><div class="ttdeci">event_t * event_wait_multi(event_queue_t *queues, size_t n_queues)</div><div class="ttdoc">Get next event from the given event queues, blocking.</div></div>
<div class="ttc" id="agroup__sys__event_html_ga2053ce1facf709fffd024bee9e2383ba"><div class="ttname"><a href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a></div><div class="ttdeci">void event_post(event_queue_t *queue, event_t *event)</div><div class="ttdoc">Queue an event.</div></div>
<div class="ttc" id="agroup__sys__event_html_ga1a8c9a1fbf3ffc656a1ab53ab1585df3"><div class="ttname"><a href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">event_wait</a></div><div class="ttdeci">static event_t * event_wait(event_queue_t *queue)</div><div class="ttdoc">Get next event from event queue, blocking.</div><div class="ttdef"><b>Definition:</b> <a href="event_8h_source.html#l00329">event.h:329</a></div></div>
<div class="ttc" id="astructevent_html_a09014dfe22d45e0d11b3d71f0361dbb7"><div class="ttname"><a href="structevent.html#a09014dfe22d45e0d11b3d71f0361dbb7">event::handler</a></div><div class="ttdeci">event_handler_t handler</div><div class="ttdoc">pointer to event handler function</div><div class="ttdef"><b>Definition:</b> <a href="event_8h_source.html#l00144">event.h:144</a></div></div>
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Tue Nov 24 2020 19:47:01 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.17</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
