<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Event Queue</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <!--BEGIN SEARCHENGINE hidden-sm hidden-xs"-->
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        var rhtml=document.getElementById('MSearchResults').contentWindow.document.body.innerHTML;
                        document.getElementById('MSearchResultsWindow').style.display='none';
                        document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
                        document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
                        document.getElementById('doc-content').innerHTML=rhtml;
                        }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event);
                              r=document.getElementById('MSearchResultsWindow');
                              if(parseInt(r.style.left)<0)r.style.left=0;">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__sys__event.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event Queue<div class="ingroups"><a class="el" href="group__sys.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides an Event loop.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides an Event loop. </p>
<p>This module offers an event queue framework like libevent or libuev.</p>
<p>An event queue is basically a FIFO queue of events, with some functions to efficiently and safely handle adding and getting events to / from such a queue.</p>
<p>An event queue is bound to a thread, but any thread or ISR can put events into a queue. In most cases, the owning thread of a queue is set during the queue's initialization. But it is also possible to initialize a queue in a detached state from a different context and to set the owning thread at a later point of time using the <a class="el" href="group__sys__event.html#gad442134f1a7617708db908523145a45b" title="Bind an event queue to the calling thread. ">event_queue_claim()</a> function.</p>
<p>An event is a structure containing a pointer to an event handler. It can be extended to provide context or arguments to the handler. It can also be embedded into existing structures (see examples).</p>
<p>Compared to msg or mbox, this some fundamental differences:</p>
<ol type="1">
<li>events are "sender allocated". Unlike <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8" title="Send a message (blocking). ">msg_send()</a>, <a class="el" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba" title="Queue an event. ">event_post()</a> never blocks or fails.</li>
<li>events contain everything necessary to handle them, thus a thread processing the events of an event queue doesn't need to be changed in order to support new event types.</li>
<li>events can be safely used (and actually perform best) when used within one thread, e.g., in order to create a state-machine like process flow. This is not (easily) possible using msg queues, as they might fill up.</li>
<li>an event can only be queued in one event queue at the same time. Notifying many queues using only one event object is not possible with this implementation.</li>
</ol>
<p>At the core, <a class="el" href="group__sys__event.html#ga434b72eb98d39688bef9d0d485a5989c" title="Get next event from event queue, blocking. ">event_wait()</a> uses thread flags to implement waiting for events to be queued. Thus event queues can be used safely and efficiently in combination with thread flags and msg queues.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// simple event handler</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handler(<a class="code" href="structevent.html">event_t</a> *<a class="code" href="structevent.html">event</a>)</div><div class="line">{</div><div class="line">   printf(<span class="stringliteral">&quot;triggered 0x%08x\n&quot;</span>, (<span class="keywordtype">unsigned</span>)event);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="structevent.html">event_t</a> <span class="keyword">event</span> = { .<a class="code" href="structevent.html#a09014dfe22d45e0d11b3d71f0361dbb7">handler</a> = handler };</div><div class="line"><span class="keyword">static</span> <a class="code" href="structevent__queue__t.html">event_queue_t</a> queue;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__sys__event.html#ga51eb9a1c10b91fffe4cade8e521cec60">event_queue_init</a>(&amp;queue);</div><div class="line">    <a class="code" href="group__sys__event.html#ga7142d0aa584d1174bf15e5dbf36372e9">event_loop</a>(&amp;queue);</div><div class="line">}</div><div class="line"></div><div class="line">[...] <a class="code" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a>(&amp;queue, &amp;event);</div><div class="line"></div><div class="line"><span class="comment">// example for event extended event struct</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    <a class="code" href="structevent.html">event_t</a> super;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *text;</div><div class="line">} custom_event_t;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> custom_handler(<a class="code" href="structevent.html">event_t</a> *event)</div><div class="line">{</div><div class="line">    custom_event_t *custom_event = (custom_event_t *)event;</div><div class="line">    printf(<span class="stringliteral">&quot;triggered custom event with text: \&quot;%s\&quot;\n&quot;</span>, custom_event-&gt;text);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> custom_event_t custom_event = { .super.handler = custom_handler, .text = <span class="stringliteral">&quot;CUSTOM EVENT&quot;</span> };</div><div class="line"></div><div class="line">[...] <a class="code" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a>(&amp;queue, &amp;custom_event)</div></div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:callback_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="callback_8h.html">callback.h</a></td></tr>
<tr class="memdesc:callback_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a callback-with-argument event type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sys_2include_2event_2thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_2include_2event_2thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:sys_2include_2event_2thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides utility functions for event handler threads. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_2timeout_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_2timeout_8h.html">timeout.h</a></td></tr>
<tr class="memdesc:event_2timeout_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality to trigger events after timeout. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html">event.h</a></td></tr>
<tr class="memdesc:event_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent.html">event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">event structure  <a href="structevent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__queue__t.html">event_queue_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">event queue structure  <a href="structevent__queue__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="memItemLeft" align="right" valign="top"><a id="gaafa9b96ad0e2d68d166b6ba394660a4b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaafa9b96ad0e2d68d166b6ba394660a4b">THREAD_FLAG_EVENT</a>&#160;&#160;&#160;(0x1)</td></tr>
<tr class="memdesc:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread flag use to notify available events in an event queue. <br /></td></tr>
<tr class="separator:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc0919266554541d5723bed79b1e3ed"><td class="memItemLeft" align="right" valign="top"><a id="gafbc0919266554541d5723bed79b1e3ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gafbc0919266554541d5723bed79b1e3ed">EVENT_QUEUE_INIT</a>&#160;&#160;&#160;{ .waiter = (<a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *)<a class="el" href="group__core__sched.html#ga5aed9d30fb31c14c7ddff73c35f85818">sched_active_thread</a> }</td></tr>
<tr class="memdesc:gafbc0919266554541d5723bed79b1e3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structevent__queue__t.html" title="event queue structure ">event_queue_t</a> static initializer <br /></td></tr>
<tr class="separator:gafbc0919266554541d5723bed79b1e3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e41a0654cf42441ef0a640053894911"><td class="memItemLeft" align="right" valign="top"><a id="ga4e41a0654cf42441ef0a640053894911"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga4e41a0654cf42441ef0a640053894911">EVENT_QUEUE_INIT_DETACHED</a>&#160;&#160;&#160;{ .waiter = NULL }</td></tr>
<tr class="memdesc:ga4e41a0654cf42441ef0a640053894911"><td class="mdescLeft">&#160;</td><td class="mdescRight">static initializer for detached event queues <br /></td></tr>
<tr class="separator:ga4e41a0654cf42441ef0a640053894911"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad0c066ffb009d3286186a124d37a0c2d"><td class="memItemLeft" align="right" valign="top"><a id="gad0c066ffb009d3286186a124d37a0c2d"></a>
typedef struct <a class="el" href="structevent.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a></td></tr>
<tr class="memdesc:gad0c066ffb009d3286186a124d37a0c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">event structure forward declaration <br /></td></tr>
<tr class="separator:gad0c066ffb009d3286186a124d37a0c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c9f34f565c834ed82a585d154d0010"><td class="memItemLeft" align="right" valign="top"><a id="ga60c9f34f565c834ed82a585d154d0010"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga60c9f34f565c834ed82a585d154d0010">event_handler_t</a>) (<a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *)</td></tr>
<tr class="memdesc:ga60c9f34f565c834ed82a585d154d0010"><td class="mdescLeft">&#160;</td><td class="mdescRight">event handler type definition <br /></td></tr>
<tr class="separator:ga60c9f34f565c834ed82a585d154d0010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga51eb9a1c10b91fffe4cade8e521cec60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga51eb9a1c10b91fffe4cade8e521cec60">event_queue_init</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga51eb9a1c10b91fffe4cade8e521cec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an event queue.  <a href="#ga51eb9a1c10b91fffe4cade8e521cec60">More...</a><br /></td></tr>
<tr class="separator:ga51eb9a1c10b91fffe4cade8e521cec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf593793b08910f3a87963f381b146a40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaf593793b08910f3a87963f381b146a40">event_queue_init_detached</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gaf593793b08910f3a87963f381b146a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an event queue not binding it to a thread.  <a href="#gaf593793b08910f3a87963f381b146a40">More...</a><br /></td></tr>
<tr class="separator:gaf593793b08910f3a87963f381b146a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad442134f1a7617708db908523145a45b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gad442134f1a7617708db908523145a45b">event_queue_claim</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gad442134f1a7617708db908523145a45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an event queue to the calling thread.  <a href="#gad442134f1a7617708db908523145a45b">More...</a><br /></td></tr>
<tr class="separator:gad442134f1a7617708db908523145a45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2053ce1facf709fffd024bee9e2383ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="memdesc:ga2053ce1facf709fffd024bee9e2383ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue an event.  <a href="#ga2053ce1facf709fffd024bee9e2383ba">More...</a><br /></td></tr>
<tr class="separator:ga2053ce1facf709fffd024bee9e2383ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696280baa5719e3c5ef75fec41e81b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga696280baa5719e3c5ef75fec41e81b3a">event_cancel</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="memdesc:ga696280baa5719e3c5ef75fec41e81b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a queued event.  <a href="#ga696280baa5719e3c5ef75fec41e81b3a">More...</a><br /></td></tr>
<tr class="separator:ga696280baa5719e3c5ef75fec41e81b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b6336946a171046f7626f476fba292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gae5b6336946a171046f7626f476fba292">event_get</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gae5b6336946a171046f7626f476fba292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, non-blocking.  <a href="#gae5b6336946a171046f7626f476fba292">More...</a><br /></td></tr>
<tr class="separator:gae5b6336946a171046f7626f476fba292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434b72eb98d39688bef9d0d485a5989c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga434b72eb98d39688bef9d0d485a5989c">event_wait</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga434b72eb98d39688bef9d0d485a5989c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking.  <a href="#ga434b72eb98d39688bef9d0d485a5989c">More...</a><br /></td></tr>
<tr class="separator:ga434b72eb98d39688bef9d0d485a5989c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaf979ad68f1d4ef379de1f0da0644ff72">event_wait_timeout</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, uint32_t timeout)</td></tr>
<tr class="memdesc:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking until timeout expires.  <a href="#gaf979ad68f1d4ef379de1f0da0644ff72">More...</a><br /></td></tr>
<tr class="separator:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22551716e8df163590e16bf2cc5ff590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga22551716e8df163590e16bf2cc5ff590">event_wait_timeout64</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue, uint64_t timeout)</td></tr>
<tr class="memdesc:ga22551716e8df163590e16bf2cc5ff590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking until timeout expires.  <a href="#ga22551716e8df163590e16bf2cc5ff590">More...</a><br /></td></tr>
<tr class="separator:ga22551716e8df163590e16bf2cc5ff590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7142d0aa584d1174bf15e5dbf36372e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga7142d0aa584d1174bf15e5dbf36372e9">event_loop</a> (<a class="el" href="structevent__queue__t.html">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga7142d0aa584d1174bf15e5dbf36372e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple event loop.  <a href="#ga7142d0aa584d1174bf15e5dbf36372e9">More...</a><br /></td></tr>
<tr class="separator:ga7142d0aa584d1174bf15e5dbf36372e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga696280baa5719e3c5ef75fec41e81b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga696280baa5719e3c5ef75fec41e81b3a">&#9670;&nbsp;</a></span>event_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a queued event. </p>
<p>This will remove a queued event from an event queue.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the underlying list implementation, this will run in O(n).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to remove event from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event to remove from queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5b6336946a171046f7626f476fba292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b6336946a171046f7626f476fba292">&#9670;&nbsp;</a></span>event_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, non-blocking. </p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to get event from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd>
<dd>
NULL if no event available </dd></dl>

</div>
</div>
<a id="ga7142d0aa584d1174bf15e5dbf36372e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7142d0aa584d1174bf15e5dbf36372e9">&#9670;&nbsp;</a></span>event_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple event loop. </p>
<p>This function will forever sit in a loop, waiting for events to be queued and executing their handlers.</p>
<p>It is pretty much defined as:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> ((event = <a class="code" href="group__sys__event.html#ga434b72eb98d39688bef9d0d485a5989c">event_wait</a>(queue))) {</div><div class="line">    <span class="keyword">event</span>-&gt;handler(event);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2053ce1facf709fffd024bee9e2383ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2053ce1facf709fffd024bee9e2383ba">&#9670;&nbsp;</a></span>event_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue an event. </p>
<p>The given event will be posted on the given <code>queue</code>. If the event is already queued when calling this function, the event will not be touched and remain in the previous position on the queue. So reposting an event while it is already on the queue will have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to queue event in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event to queue in event queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad442134f1a7617708db908523145a45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad442134f1a7617708db908523145a45b">&#9670;&nbsp;</a></span>event_queue_claim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_queue_claim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind an event queue to the calling thread. </p>
<p>This function must only be called once and only if the given queue is not yet bound to a thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>(queue-&gt;waiter == NULL)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to bind to a thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51eb9a1c10b91fffe4cade8e521cec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51eb9a1c10b91fffe4cade8e521cec60">&#9670;&nbsp;</a></span>event_queue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_queue_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an event queue. </p>
<p>This will set the calling thread as owner of <code>queue</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf593793b08910f3a87963f381b146a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf593793b08910f3a87963f381b146a40">&#9670;&nbsp;</a></span>event_queue_init_detached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_queue_init_detached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an event queue not binding it to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga434b72eb98d39688bef9d0d485a5989c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga434b72eb98d39688bef9d0d485a5989c">&#9670;&nbsp;</a></span>event_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking. </p>
<p>This function will block until an event becomes available.</p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="section note"><dt>Note</dt><dd>There can only be a single waiter on a queue!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to get event from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd></dl>

</div>
</div>
<a id="gaf979ad68f1d4ef379de1f0da0644ff72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf979ad68f1d4ef379de1f0da0644ff72">&#9670;&nbsp;</a></span>event_wait_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking until timeout expires. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to query for an event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum time to wait for an event to be posted in us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event if event was taken from the queue </dd>
<dd>
NULL if timeout expired before an event was posted </dd></dl>

</div>
</div>
<a id="ga22551716e8df163590e16bf2cc5ff590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22551716e8df163590e16bf2cc5ff590">&#9670;&nbsp;</a></span>event_wait_timeout64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_timeout64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__queue__t.html">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking until timeout expires. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to query for an event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum time to wait for an event to be posted in us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event if event was taken from the queue </dd>
<dd>
NULL if timeout expired before an event was posted </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Wed Jul 1 2020 17:08:59 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
