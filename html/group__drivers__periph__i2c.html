<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>I2C</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        displaySR();
                    }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__drivers__periph__i2c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group__drivers.html">Drivers</a> &raquo; <a class="el" href="group__drivers__periph.html">Peripheral Driver Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low-level I2C peripheral driver.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low-level I2C peripheral driver. </p>
<p>This interface provides a simple abstraction to use the MCUs I2C peripherals. It provides support for 7-bit and 10-bit addressing and can be used for different kind of register addressing schemes.</p>
<h1><a class="anchor" id="sec_i2c_usage"></a>
Usage</h1>
<p>Example for reading a 8-bit register on a device, using a 10-bit device address and 8-bit register addresses and using a RESTART condition (CAUTION: this example does not check any return values...):</p>
<div class="fragment"><div class="line"><span class="comment">// initialize the bus (this is normally done during boot time)</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga2ce7cc916258e7c3fa0b60cba2e4895f">i2c_init</a>(dev);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// before accessing the bus, we need to acquire it</span></div>
<div class="line">i2c_acquire(dev);</div>
<div class="line"><span class="comment">// next we write the register address, but create no STOP condition when done</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga062b562b2d2cd123199a2890968ba272">i2c_write_byte</a>(dev, device_addr, reg_addr, (<a class="code" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a> | <a class="code" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a>));</div>
<div class="line"><span class="comment">// and now we read the register value</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga81fed3b6aec0ba0956ba6a1efbc74774">i2c_read_byte</a>(dev, device_addr, &amp;reg_value, <a class="code" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a>);</div>
<div class="line"><span class="comment">// finally we have to release the bus</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga824e1b86105462b0df022bcf3ea0634b">i2c_release</a>(dev);</div>
</div><!-- fragment --><p>Example for writing a 16-bit register with 16-bit register addressing and 7-bit device addressing:</p>
<div class="fragment"><div class="line"><span class="comment">// initialize the bus</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga2ce7cc916258e7c3fa0b60cba2e4895f">i2c_init</a>(dev);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// first, acquire the shared bus again</span></div>
<div class="line">i2c_acquire(dev);</div>
<div class="line"><span class="comment">// write the 16-bit register address to the device and prevent STOP condition</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga062b562b2d2cd123199a2890968ba272">i2c_write_byte</a>(dev, device_addr, reg_addr, <a class="code" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a>);</div>
<div class="line"><span class="comment">// and write the data after a REPEATED START</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga2d4c26cb8d79d7a46764fb832e93ff0b">i2c_write_bytes</a>(dev, device_addr, reg_data, 2, 0);</div>
<div class="line"><span class="comment">// and finally free the bus again</span></div>
<div class="line"><a class="code" href="group__drivers__periph__i2c.html#ga824e1b86105462b0df022bcf3ea0634b">i2c_release</a>(dev);</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_i2c_pull"></a>
Pull Resistors</h1>
<p>The I2C signal lines SDA/SCL need external pull-up resistors which connect the lines to the positive voltage supply Vcc. The I2C driver implementation should enable the pin's internal pull-up resistors. There are however some use cases for which the internal pull resistors are not strong enough and the I2C bus will show faulty behavior. This can for example happen when connecting a logic analyzer which will raise the capacitance of the bus. In this case you should make sure you connect external pull-up resistors to both I2C bus lines.</p>
<p>The minimum and maximum resistances are computed by: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} R_{min} &amp;=&amp; \frac{V_{DD} - V_{OL(max)}} {I_{OL}}\\ R_{max} &amp;=&amp; \frac{t_r} {(0.8473 \cdot C_b)} \end{eqnarray*}" src="form_11.png"/>
</p>
<p><br  />
 where:<br  />
 <img class="formulaInl" alt="$ V_{DD} =$" src="form_12.png"/> Supply voltage, <img class="formulaInl" alt="$ V_{OL(max)} =$" src="form_13.png"/> Low level voltage, <img class="formulaInl" alt="$ I_{OL} =$" src="form_14.png"/> Low level output current, <img class="formulaInl" alt="$ t_r =$" src="form_15.png"/> Signal rise time, <img class="formulaInl" alt="$ C_b =$" src="form_16.png"/> Bus capacitance <br  />
 <br  />
The pull-up resistors depend on the bus speed. Some typical values are:<br  />
 Normal mode: 10k&Omega;<br  />
 Fast mode: 2k&Omega;<br  />
 Fast plus mode: 2k&Omega;</p>
<p>For more details refer to section 7.1 in:<br  />
 <a href="http://www.nxp.com/documents/user_manual/UM10204.pdf">http://www.nxp.com/documents/user_manual/UM10204.pdf</a></p>
<h1><a class="anchor" id="sec_i2c_pm"></a>
(Low-) power implications</h1>
<p>The I2C interface realizes a transaction-based access scheme to the bus. From a power management perspective, we can leverage this by only powering on the I2C peripheral while it is actually used, that is inside an <a class="el" href="group__drivers__periph__i2c.html#ga01056db645f8e561ac8bdab1f531a6db" title="Get mutually exclusive access to the given I2C bus.">i2c_acquire()</a> - <a class="el" href="group__drivers__periph__i2c.html#ga824e1b86105462b0df022bcf3ea0634b" title="Release the given I2C device to be used by others.">i2c_release()</a> block.</p>
<p>After initialization, the I2C peripheral <b>should</b> be powered off (e.g. through peripheral clock gating). It should only be powered on once a transaction on the I2C bus starts, namely in the <a class="el" href="group__drivers__periph__i2c.html#ga01056db645f8e561ac8bdab1f531a6db" title="Get mutually exclusive access to the given I2C bus.">i2c_acquire()</a> function. Once the transaction is finished, the corresponding I2C peripheral <b>should</b> be powered off again in the <a class="el" href="group__drivers__periph__i2c.html#ga824e1b86105462b0df022bcf3ea0634b" title="Release the given I2C device to be used by others.">i2c_release()</a> function.</p>
<p>If the implementation puts the active thread to sleep while a transfer is in progress (e.g. when using DMA), the implementation might need to block certain power states. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:i2c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html">i2c.h</a></td></tr>
<tr class="memdesc:i2c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level I2C peripheral driver interface definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab5c0fbe837494c5f9130a5914854250d"><td class="memItemLeft" align="right" valign="top"><a id="gab5c0fbe837494c5f9130a5914854250d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#gab5c0fbe837494c5f9130a5914854250d">I2C_READ</a>&#160;&#160;&#160;(0x0001)</td></tr>
<tr class="memdesc:gab5c0fbe837494c5f9130a5914854250d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bit needs to be set when reading. <br /></td></tr>
<tr class="separator:gab5c0fbe837494c5f9130a5914854250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fc6df6bf09a50095f509cadc0083a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga45fc6df6bf09a50095f509cadc0083a8">I2C_10BIT_MAGIC</a>&#160;&#160;&#160;(0xF0u)</td></tr>
<tr class="memdesc:ga45fc6df6bf09a50095f509cadc0083a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special bit pattern indicating a 10 bit address is used.  <a href="group__drivers__periph__i2c.html#ga45fc6df6bf09a50095f509cadc0083a8">More...</a><br /></td></tr>
<tr class="separator:ga45fc6df6bf09a50095f509cadc0083a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2ce7cc916258e7c3fa0b60cba2e4895f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga2ce7cc916258e7c3fa0b60cba2e4895f">i2c_init</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev)</td></tr>
<tr class="memdesc:ga2ce7cc916258e7c3fa0b60cba2e4895f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the given I2C bus.  <a href="group__drivers__periph__i2c.html#ga2ce7cc916258e7c3fa0b60cba2e4895f">More...</a><br /></td></tr>
<tr class="separator:ga2ce7cc916258e7c3fa0b60cba2e4895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34bed3b0c852839ef35d52b017e2941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#gaa34bed3b0c852839ef35d52b017e2941">i2c_init_pins</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev)</td></tr>
<tr class="memdesc:gaa34bed3b0c852839ef35d52b017e2941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the used I2C bus pins.  <a href="group__drivers__periph__i2c.html#gaa34bed3b0c852839ef35d52b017e2941">More...</a><br /></td></tr>
<tr class="separator:gaa34bed3b0c852839ef35d52b017e2941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e65b8c4c0ecb24da892b8ec6bb3f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga40e65b8c4c0ecb24da892b8ec6bb3f45">i2c_deinit_pins</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev)</td></tr>
<tr class="memdesc:ga40e65b8c4c0ecb24da892b8ec6bb3f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the pins of the given I2C bus back to plain GPIO functionality.  <a href="group__drivers__periph__i2c.html#ga40e65b8c4c0ecb24da892b8ec6bb3f45">More...</a><br /></td></tr>
<tr class="separator:ga40e65b8c4c0ecb24da892b8ec6bb3f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455b18bbedf5f41ce47a72009d27fe08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga455b18bbedf5f41ce47a72009d27fe08">i2c_pin_sda</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev)</td></tr>
<tr class="memdesc:ga455b18bbedf5f41ce47a72009d27fe08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SDA pin of the given I2C bus.  <a href="group__drivers__periph__i2c.html#ga455b18bbedf5f41ce47a72009d27fe08">More...</a><br /></td></tr>
<tr class="separator:ga455b18bbedf5f41ce47a72009d27fe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae671dd338e186c01439ee9fc1628a72d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#gae671dd338e186c01439ee9fc1628a72d">i2c_pin_scl</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev)</td></tr>
<tr class="memdesc:gae671dd338e186c01439ee9fc1628a72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SCL pin of the given I2C bus.  <a href="group__drivers__periph__i2c.html#gae671dd338e186c01439ee9fc1628a72d">More...</a><br /></td></tr>
<tr class="separator:gae671dd338e186c01439ee9fc1628a72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01056db645f8e561ac8bdab1f531a6db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga01056db645f8e561ac8bdab1f531a6db">i2c_acquire</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev)</td></tr>
<tr class="memdesc:ga01056db645f8e561ac8bdab1f531a6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mutually exclusive access to the given I2C bus.  <a href="group__drivers__periph__i2c.html#ga01056db645f8e561ac8bdab1f531a6db">More...</a><br /></td></tr>
<tr class="separator:ga01056db645f8e561ac8bdab1f531a6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824e1b86105462b0df022bcf3ea0634b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga824e1b86105462b0df022bcf3ea0634b">i2c_release</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev)</td></tr>
<tr class="memdesc:ga824e1b86105462b0df022bcf3ea0634b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the given I2C device to be used by others.  <a href="group__drivers__periph__i2c.html#ga824e1b86105462b0df022bcf3ea0634b">More...</a><br /></td></tr>
<tr class="separator:ga824e1b86105462b0df022bcf3ea0634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ab6e73e05b22c2da0c2f178da06d7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#gac4ab6e73e05b22c2da0c2f178da06d7b">i2c_read_reg</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, uint16_t reg, void *data, uint8_t flags)</td></tr>
<tr class="memdesc:gac4ab6e73e05b22c2da0c2f178da06d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading one byte from a given register address.  <a href="group__drivers__periph__i2c.html#gac4ab6e73e05b22c2da0c2f178da06d7b">More...</a><br /></td></tr>
<tr class="separator:gac4ab6e73e05b22c2da0c2f178da06d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e65efc34a8bd77223795faadc29d304"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga5e65efc34a8bd77223795faadc29d304">i2c_read_regs</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, uint16_t reg, void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:ga5e65efc34a8bd77223795faadc29d304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading several bytes from a given register address.  <a href="group__drivers__periph__i2c.html#ga5e65efc34a8bd77223795faadc29d304">More...</a><br /></td></tr>
<tr class="separator:ga5e65efc34a8bd77223795faadc29d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81fed3b6aec0ba0956ba6a1efbc74774"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga81fed3b6aec0ba0956ba6a1efbc74774">i2c_read_byte</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, void *data, uint8_t flags)</td></tr>
<tr class="memdesc:ga81fed3b6aec0ba0956ba6a1efbc74774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading one byte from a device.  <a href="group__drivers__periph__i2c.html#ga81fed3b6aec0ba0956ba6a1efbc74774">More...</a><br /></td></tr>
<tr class="separator:ga81fed3b6aec0ba0956ba6a1efbc74774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196b4508511c41822eddf6b43b008e90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga196b4508511c41822eddf6b43b008e90">i2c_read_bytes</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:ga196b4508511c41822eddf6b43b008e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for reading bytes from a device.  <a href="group__drivers__periph__i2c.html#ga196b4508511c41822eddf6b43b008e90">More...</a><br /></td></tr>
<tr class="separator:ga196b4508511c41822eddf6b43b008e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062b562b2d2cd123199a2890968ba272"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga062b562b2d2cd123199a2890968ba272">i2c_write_byte</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, uint8_t data, uint8_t flags)</td></tr>
<tr class="memdesc:ga062b562b2d2cd123199a2890968ba272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing a single byte onto the bus.  <a href="group__drivers__periph__i2c.html#ga062b562b2d2cd123199a2890968ba272">More...</a><br /></td></tr>
<tr class="separator:ga062b562b2d2cd123199a2890968ba272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4c26cb8d79d7a46764fb832e93ff0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga2d4c26cb8d79d7a46764fb832e93ff0b">i2c_write_bytes</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, const void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:ga2d4c26cb8d79d7a46764fb832e93ff0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing several bytes onto the bus.  <a href="group__drivers__periph__i2c.html#ga2d4c26cb8d79d7a46764fb832e93ff0b">More...</a><br /></td></tr>
<tr class="separator:ga2d4c26cb8d79d7a46764fb832e93ff0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02b8328d5e823d972e1e1234965daab1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga02b8328d5e823d972e1e1234965daab1">i2c_write_reg</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, uint16_t reg, uint8_t data, uint8_t flags)</td></tr>
<tr class="memdesc:ga02b8328d5e823d972e1e1234965daab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing one byte to a given register address.  <a href="group__drivers__periph__i2c.html#ga02b8328d5e823d972e1e1234965daab1">More...</a><br /></td></tr>
<tr class="separator:ga02b8328d5e823d972e1e1234965daab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e12c6df3bc117d5e46d1e98a5a7f08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#gac7e12c6df3bc117d5e46d1e98a5a7f08">i2c_write_regs</a> (<a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a> dev, uint16_t addr, uint16_t reg, const void *data, size_t len, uint8_t flags)</td></tr>
<tr class="memdesc:gac7e12c6df3bc117d5e46d1e98a5a7f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for writing data to a given register address.  <a href="group__drivers__periph__i2c.html#gac7e12c6df3bc117d5e46d1e98a5a7f08">More...</a><br /></td></tr>
<tr class="separator:gac7e12c6df3bc117d5e46d1e98a5a7f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14916eda80b19ff41d08e25eee56fb"><td class="memItemLeft" align="right" valign="top"><a id="ga9f14916eda80b19ff41d08e25eee56fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb">I2C_DEV</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:ga9f14916eda80b19ff41d08e25eee56fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default I2C device access macro. <br /></td></tr>
<tr class="separator:ga9f14916eda80b19ff41d08e25eee56fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad224a6eaa456b1a9682b1ca17c4aacc3"><td class="memItemLeft" align="right" valign="top"><a id="gad224a6eaa456b1a9682b1ca17c4aacc3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#gad224a6eaa456b1a9682b1ca17c4aacc3">I2C_UNDEF</a>&#160;&#160;&#160;(UINT_MAX)</td></tr>
<tr class="memdesc:gad224a6eaa456b1a9682b1ca17c4aacc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default I2C undefined value. <br /></td></tr>
<tr class="separator:gad224a6eaa456b1a9682b1ca17c4aacc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c002f11842c26b1ee7048ef51bdc35b"><td class="memItemLeft" align="right" valign="top"><a id="ga8c002f11842c26b1ee7048ef51bdc35b"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a></td></tr>
<tr class="memdesc:ga8c002f11842c26b1ee7048ef51bdc35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default i2c_t type definition. <br /></td></tr>
<tr class="separator:ga8c002f11842c26b1ee7048ef51bdc35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6a870f98abb8cffa95373b69fb8243"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a> { <br />
&#160;&#160;<a class="el" href="group__drivers__periph__i2c.html#gga6e6a870f98abb8cffa95373b69fb8243a6b350d376580872bb53bdfc4ff41d9b0">I2C_SPEED_LOW</a> = 0, 
<a class="el" href="group__drivers__periph__i2c.html#gga6e6a870f98abb8cffa95373b69fb8243a0826bf5711e82ba26b4ada6104260583">I2C_SPEED_NORMAL</a>, 
<a class="el" href="group__drivers__periph__i2c.html#gga6e6a870f98abb8cffa95373b69fb8243a8dc6cae939d20d56a78d123365caa4ca">I2C_SPEED_FAST</a>, 
<a class="el" href="group__drivers__periph__i2c.html#gga6e6a870f98abb8cffa95373b69fb8243a42e708fe61f237d88f6cf53f32e17e8e">I2C_SPEED_FAST_PLUS</a>, 
<br />
&#160;&#160;<a class="el" href="group__drivers__periph__i2c.html#gga6e6a870f98abb8cffa95373b69fb8243a745e792241485f11092fabd600fd6b48">I2C_SPEED_HIGH</a>
<br />
 }</td></tr>
<tr class="memdesc:ga6e6a870f98abb8cffa95373b69fb8243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default mapping of I2C bus speed values.  <a href="group__drivers__periph__i2c.html#ga6e6a870f98abb8cffa95373b69fb8243">More...</a><br /></td></tr>
<tr class="separator:ga6e6a870f98abb8cffa95373b69fb8243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed58f160035134076b56c8907cf0c6b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a> { <a class="el" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a> = 0x01, 
<a class="el" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6ba1dc3546ab9d927d48d26781bdc4ad84e">I2C_REG16</a> = 0x02, 
<a class="el" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a> = 0x04, 
<a class="el" href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6bad5799291fd9b37b7cc3a381636be9c53">I2C_NOSTART</a> = 0x08
 }</td></tr>
<tr class="memdesc:ga9ed58f160035134076b56c8907cf0c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer flags.  <a href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">More...</a><br /></td></tr>
<tr class="separator:ga9ed58f160035134076b56c8907cf0c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga45fc6df6bf09a50095f509cadc0083a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45fc6df6bf09a50095f509cadc0083a8">&#9670;&nbsp;</a></span>I2C_10BIT_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_10BIT_MAGIC&#160;&#160;&#160;(0xF0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special bit pattern indicating a 10 bit address is used. </p>
<p>Should only be used internally in CPU driver implementations, this is not intended to be used by applications.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.i2c-bus.org/addressing/10-bit-addressing/">https://www.i2c-bus.org/addressing/10-bit-addressing/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c_8h_source.html#l00168">168</a> of file <a class="el" href="i2c_8h_source.html">i2c.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9ed58f160035134076b56c8907cf0c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed58f160035134076b56c8907cf0c6b">&#9670;&nbsp;</a></span>i2c_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2"></a>I2C_ADDR10&#160;</td><td class="fielddoc"><p>use 10-bit device addressing </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6ba1dc3546ab9d927d48d26781bdc4ad84e"></a>I2C_REG16&#160;</td><td class="fielddoc"><p>use 16-bit register addressing, big-endian </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3"></a>I2C_NOSTOP&#160;</td><td class="fielddoc"><p>do not issue a STOP condition after transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ed58f160035134076b56c8907cf0c6bad5799291fd9b37b7cc3a381636be9c53"></a>I2C_NOSTART&#160;</td><td class="fielddoc"><p>skip START sequence, ignores address field </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c_8h_source.html#l00190">190</a> of file <a class="el" href="i2c_8h_source.html">i2c.h</a>.</p>

</div>
</div>
<a id="ga6e6a870f98abb8cffa95373b69fb8243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e6a870f98abb8cffa95373b69fb8243">&#9670;&nbsp;</a></span>i2c_speed_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drivers__periph__i2c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default mapping of I2C bus speed values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a6b350d376580872bb53bdfc4ff41d9b0"></a>I2C_SPEED_LOW&#160;</td><td class="fielddoc"><p>low speed mode: ~10 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a0826bf5711e82ba26b4ada6104260583"></a>I2C_SPEED_NORMAL&#160;</td><td class="fielddoc"><p>normal mode: ~100 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a8dc6cae939d20d56a78d123365caa4ca"></a>I2C_SPEED_FAST&#160;</td><td class="fielddoc"><p>fast mode: ~400 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a42e708fe61f237d88f6cf53f32e17e8e"></a>I2C_SPEED_FAST_PLUS&#160;</td><td class="fielddoc"><p>fast plus mode: ~1000 kbit/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a745e792241485f11092fabd600fd6b48"></a>I2C_SPEED_HIGH&#160;</td><td class="fielddoc"><p>high speed mode: ~3400 kbit/s </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c_8h_source.html#l00175">175</a> of file <a class="el" href="i2c_8h_source.html">i2c.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga01056db645f8e561ac8bdab1f531a6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01056db645f8e561ac8bdab1f531a6db">&#9670;&nbsp;</a></span>i2c_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get mutually exclusive access to the given I2C bus. </p>
<p>In case the I2C device is busy, this function will block until the bus is free again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C device to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a id="ga40e65b8c4c0ecb24da892b8ec6bb3f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40e65b8c4c0ecb24da892b8ec6bb3f45">&#9670;&nbsp;</a></span>i2c_deinit_pins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_deinit_pins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the pins of the given I2C bus back to plain GPIO functionality. </p>
<p>The pin mux of the SDA and SCL pins of the bus will be changed back to default (GPIO) mode and the I2C bus is powered off. This allows to use the I2C pins for another function and return to I2C functionality again by calling <a class="el" href="group__drivers__periph__i2c.html#gaa34bed3b0c852839ef35d52b017e2941" title="Initialize the used I2C bus pins.">i2c_init_pins()</a></p>
<p>If you want the pin to be in a defined state, call <a class="el" href="group__drivers__periph__gpio.html#gab7d8ecaeb639070a28027a8fd31a0955" title="Initialize the given pin as general purpose input or output.">gpio_init()</a> on it.</p>
<p>The bus MUST not be acquired before initializing it, as this is handled internally by the i2c_deinit function!</p>
<p>Calls to <a class="el" href="group__drivers__periph__i2c.html#ga01056db645f8e561ac8bdab1f531a6db" title="Get mutually exclusive access to the given I2C bus.">i2c_acquire()</a> will block until <a class="el" href="group__drivers__periph__i2c.html#gaa34bed3b0c852839ef35d52b017e2941" title="Initialize the used I2C bus pins.">i2c_init_pins()</a> is called.</p>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_i2c_reconfigure feature to be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>the device to de-initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ce7cc916258e7c3fa0b60cba2e4895f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce7cc916258e7c3fa0b60cba2e4895f">&#9670;&nbsp;</a></span>i2c_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the given I2C bus. </p>
<p>The given I2C device will be initialized with the parameters as specified in the boards periph_conf.h, using the pins and the speed value given there.</p>
<p>The bus MUST not be acquired before initializing it, as this is handled internally by the i2c_init function!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>the device to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa34bed3b0c852839ef35d52b017e2941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa34bed3b0c852839ef35d52b017e2941">&#9670;&nbsp;</a></span>i2c_init_pins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_init_pins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the used I2C bus pins. </p>
<p>After calling i2c_init, the pins must be initialized (i.e. spi_init is calling this function internally). In normal cases, this function will not be used. But there are some devices (e.g. ATECC608A), that use I2C bus lines also for other purposes and need the option to dynamically re-configure one or more of the used pins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C device the pins are configure for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae671dd338e186c01439ee9fc1628a72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae671dd338e186c01439ee9fc1628a72d">&#9670;&nbsp;</a></span>i2c_pin_scl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> i2c_pin_scl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SCL pin of the given I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_i2c_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the I2C clock line. </dd></dl>

</div>
</div>
<a id="ga455b18bbedf5f41ce47a72009d27fe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455b18bbedf5f41ce47a72009d27fe08">&#9670;&nbsp;</a></span>i2c_pin_sda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> i2c_pin_sda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SDA pin of the given I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_i2c_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the I2C data line. </dd></dl>

</div>
</div>
<a id="ga81fed3b6aec0ba0956ba6a1efbc74774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81fed3b6aec0ba0956ba6a1efbc74774">&#9670;&nbsp;</a></span>i2c_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading one byte from a device. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
<a id="ga196b4508511c41822eddf6b43b008e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga196b4508511c41822eddf6b43b008e90">&#9670;&nbsp;</a></span>i2c_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading bytes from a device. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to read into <code>data</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
<a id="gac4ab6e73e05b22c2da0c2f178da06d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ab6e73e05b22c2da0c2f178da06d7b">&#9670;&nbsp;</a></span>i2c_read_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading one byte from a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
<a id="ga5e65efc34a8bd77223795faadc29d304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e65efc34a8bd77223795faadc29d304">&#9670;&nbsp;</a></span>i2c_read_regs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_regs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for reading several bytes from a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a repeated start sequence for reading from the specified register address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to read into <code>data</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
<a id="ga824e1b86105462b0df022bcf3ea0634b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga824e1b86105462b0df022bcf3ea0634b">&#9670;&nbsp;</a></span>i2c_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the given I2C device to be used by others. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C device to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga062b562b2d2cd123199a2890968ba272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga062b562b2d2cd123199a2890968ba272">&#9670;&nbsp;</a></span>i2c_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing a single byte onto the bus. </p>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>byte to write to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
<a id="ga2d4c26cb8d79d7a46764fb832e93ff0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d4c26cb8d79d7a46764fb832e93ff0b">&#9670;&nbsp;</a></span>i2c_write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing several bytes onto the bus. </p>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>array holding the bytes to write to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
<a id="ga02b8328d5e823d972e1e1234965daab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02b8328d5e823d972e1e1234965daab1">&#9670;&nbsp;</a></span>i2c_write_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing one byte to a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a continuous sequence for writing to the specified register address. It first writes the register then data.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>byte to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
<a id="gac7e12c6df3bc117d5e46d1e98a5a7f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7e12c6df3bc117d5e46d1e98a5a7f08">&#9670;&nbsp;</a></span>i2c_write_regs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_regs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__i2c.html#ga8c002f11842c26b1ee7048ef51bdc35b">i2c_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for writing data to a given register address. </p>
<dl class="section note"><dt>Note</dt><dd>This function is using a continuous sequence for writing to the specified register address. It first writes the register then data.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>i2c_acquire must be called before accessing the bus</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>I2C peripheral device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to read from (8- or 16-bit, right-aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>7-bit or 10-bit device address (right-aligned) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>memory location to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags (see <a class="el" href="group__drivers__periph__i2c.html#ga9ed58f160035134076b56c8907cf0c6b">i2c_flags_t</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 When success </dd>
<dd>
-EIO When slave device doesn't ACK the byte </dd>
<dd>
-ENXIO When no devices respond on the address sent on the bus </dd>
<dd>
-ETIMEDOUT When timeout occurs before device's response </dd>
<dd>
-EINVAL When an invalid argument is given </dd>
<dd>
-EOPNOTSUPP When MCU driver doesn't support the flag operation </dd>
<dd>
-EAGAIN When a lost bus arbitration occurs </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga81fed3b6aec0ba0956ba6a1efbc74774"><div class="ttname"><a href="group__drivers__periph__i2c.html#ga81fed3b6aec0ba0956ba6a1efbc74774">i2c_read_byte</a></div><div class="ttdeci">int i2c_read_byte(i2c_t dev, uint16_t addr, void *data, uint8_t flags)</div><div class="ttdoc">Convenience function for reading one byte from a device.</div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2"><div class="ttname"><a href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6ba1d95c3f463d6bbe98c1a8fbcd5d1e1f2">I2C_ADDR10</a></div><div class="ttdeci">@ I2C_ADDR10</div><div class="ttdoc">use 10-bit device addressing</div><div class="ttdef"><b>Definition:</b> <a href="i2c_8h_source.html#l00191">i2c.h:191</a></div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3"><div class="ttname"><a href="group__drivers__periph__i2c.html#gga9ed58f160035134076b56c8907cf0c6bad24d4523893d22e101e27bfc546234c3">I2C_NOSTOP</a></div><div class="ttdeci">@ I2C_NOSTOP</div><div class="ttdoc">do not issue a STOP condition after transfer</div><div class="ttdef"><b>Definition:</b> <a href="i2c_8h_source.html#l00193">i2c.h:193</a></div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga824e1b86105462b0df022bcf3ea0634b"><div class="ttname"><a href="group__drivers__periph__i2c.html#ga824e1b86105462b0df022bcf3ea0634b">i2c_release</a></div><div class="ttdeci">void i2c_release(i2c_t dev)</div><div class="ttdoc">Release the given I2C device to be used by others.</div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga2d4c26cb8d79d7a46764fb832e93ff0b"><div class="ttname"><a href="group__drivers__periph__i2c.html#ga2d4c26cb8d79d7a46764fb832e93ff0b">i2c_write_bytes</a></div><div class="ttdeci">int i2c_write_bytes(i2c_t dev, uint16_t addr, const void *data, size_t len, uint8_t flags)</div><div class="ttdoc">Convenience function for writing several bytes onto the bus.</div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga062b562b2d2cd123199a2890968ba272"><div class="ttname"><a href="group__drivers__periph__i2c.html#ga062b562b2d2cd123199a2890968ba272">i2c_write_byte</a></div><div class="ttdeci">int i2c_write_byte(i2c_t dev, uint16_t addr, uint8_t data, uint8_t flags)</div><div class="ttdoc">Convenience function for writing a single byte onto the bus.</div></div>
<div class="ttc" id="agroup__drivers__periph__i2c_html_ga2ce7cc916258e7c3fa0b60cba2e4895f"><div class="ttname"><a href="group__drivers__periph__i2c.html#ga2ce7cc916258e7c3fa0b60cba2e4895f">i2c_init</a></div><div class="ttdeci">void i2c_init(i2c_t dev)</div><div class="ttdoc">Initialize the given I2C bus.</div></div>
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Tue Nov 24 2020 19:47:01 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.17</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
