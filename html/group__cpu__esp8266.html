<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>ESP8266 / ESP8285</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <!--BEGIN SEARCHENGINE hidden-sm hidden-xs"-->
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        var rhtml=document.getElementById('MSearchResults').contentWindow.document.body.innerHTML;
                        document.getElementById('MSearchResultsWindow').style.display='none';
                        document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
                        document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
                        document.getElementById('doc-content').innerHTML=rhtml;
                        }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event);
                              var r=document.getElementById('MSearchResultsWindow');
                              if(parseInt(r.style.left)<0)r.style.left=0;
                              var x=document.getElementById('MSearchResults');
                              if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                              var f=document.getElementById('riot-searchform');
                              if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cpu__esp8266.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">ESP8266 / ESP8285<div class="ingroups"><a class="el" href="group__cpu.html">CPU</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>RIOT-OS port for Espressif's ESP8266 / ESP8285 MCUs.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>RIOT-OS port for Espressif's ESP8266 / ESP8285 MCUs. </p>
<h1><a class="anchor" id="esp8266_riot"></a>
RIOT-OS on ESP8266 and ESP8285 boards</h1>
<h2><a class="anchor" id="esp8266_toc"></a> Table of Contents </h2>
<ol type="1">
<li><a href="#esp8266_overview">Overview</a></li>
<li><a href="#esp8266_short_configuration_reference">Short Configuration Reference</a></li>
<li><a href="#esp8266_mcu_esp8266">MCU ESP8266</a></li>
<li><a href="#esp8266_toolchain">Toolchain</a><ol type="a">
<li><a href="#esp8266_riot_docker_toolchain">RIOT Docker Toolchain (riotdocker)</a></li>
<li><a href="#esp8266_manual_toolchain_installation">Manual Toolchain Installation</a></li>
</ol>
</li>
<li><a href="#esp8266_flashing_the_device">Flashing the Device</a><ol type="a">
<li><a href="#esp8266_toolchain_usage">Toolchain Usage</a></li>
<li><a href="#esp8266_compile_options">Compile Options</a></li>
<li><a href="#esp8266_flash_modes">Flash Modes</a></li>
<li><a href="#esp8266_erasing">Erasing the Device</a></li>
</ol>
</li>
<li><a href="#esp8266_peripherals">Peripherals</a><ol type="a">
<li><a href="#esp8266_gpio_pins">GPIO pins</a></li>
<li><a href="#esp8266_adc_channels">ADC Channels</a></li>
<li><a href="#esp8266_spi_interfaces">SPI Interfaces</a></li>
<li><a href="#esp8266_i2c_interfaces">I2C Interfaces</a></li>
<li><a href="#esp8266_pwm_channels">PWM Channels</a></li>
<li><a href="#esp8266_timers">Timers</a></li>
<li><a href="#esp8266_spiffs_device">SPIFFS Device</a></li>
<li><a href="#esp8266_other_peripherals">Other Peripherals</a></li>
</ol>
</li>
<li><a href="#esp8266_network_interfaces">Network Interfaces</a><ol type="a">
<li><a href="#esp8266_wifi_network_interface">WiFi Network Interface</a></li>
<li><a href="#esp8266_esp_now_network_interface">ESP-NOW Network Interface</a></li>
</ol>
</li>
<li><a href="#esp8266_preconfigured_devices">Preconfigured Devices</a><ol type="a">
<li><a href="#esp8266_network_devices">Network Devices</a></li>
<li><a href="#esp8266_sd_card_device">SD-Card Device</a></li>
</ol>
</li>
<li><a href="#esp8266_application_specific_configurations">Application-Specific Configurations</a><ol type="a">
<li><a href="#esp8266_application_specific_board_configuration">Application-Specific Board Configuration</a></li>
<li><a href="#esp8266_application_specific_driver_configuration">Application-Specific Driver Configuration</a></li>
</ol>
</li>
<li><a href="#esp8266_sdk_specifics">SDK Specific Information</a><ol type="a">
<li><a href="#esp8266_sdk_tasks">Tasks</a></li>
<li><a href="#esp8266_esp_idf_heap_implementation">Heap</a></li>
</ol>
</li>
<li><a href="#esp8266_debugging">Debugging</a><ol type="a">
<li><a href="#esp8266_qemu_mode_and_gdb">QEMU Mode and GDB</a></li>
<li><a href="#esp8266_esp_gdbstub">Module esp_gdbstub</a></li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="esp8266_overview"></a> Overview  &#160;&#160; [<a href="#esp8266_toc">TOC</a>]</h1>
<p><b>RIOT-Xtensa-ESP</b> is a bare metal implementation of <b>RIOT-OS</b> for <b>ESP8266 / ESP8285</b> SOCs which supports most features of RIOT-OS. The peripheral SPI and I2C interfaces allow to connect all external hardware modules supported by RIOT-OS, such as sensors and actuators. SPI interface can also be used to connect external IEEE802.15.4 modules to integrate ESP8266 boards into a GNRC network.</p>
<p>The RIOT-OS port for ESP8266 supports ESP8266 as well as ESP8285 MCUs and requires the <a href="https://github.com/gschorcht/RIOT-Xtensa-ESP8266-RTOS-SDK.git">ESP8266 RTOS SDK v3.x</a>. To build a RIOT application, simply use the <code>make</code> command and specify an existing ESP8266 board, for example:</p>
<div class="fragment"><div class="line">make flash BOARD=esp8266-esp-12x -C tests/shell ...</div></div><!-- fragment --><p>For more information about the <code>make</code> command variables and specific compile options, see section <a href="#esp8266_compile_options">Compile Options</a>.</p>
<p>Although the port does not use the official <b>ESP8266 RTOS SDK</b> directly, it must be installed for compilation. The reason is that the port uses most of the <b>ESP8266 SOC definitions</b> provided by SDK header files. In addition, it needs the hardware abstraction library (libhal), and <b>ESP8266 WiFi stack binary</b> libraries which are part of the SDK.</p>
<h1><a class="anchor" id="esp8266_mcu_esp8266"></a> MCU ESP8266  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>ESP8266 is a low-cost, ultra-low-power, single-core SoCs with an integrated WiFi module from Espressif Systems. The processor core is based on the Tensilica Xtensa Diamond Standard 106Micro 32-bit Controller Processor Core, which Espressif calls L106. The key features of ESP8266 are:</p>
<h1><a class="anchor" id="esp8266_short_configuration_reference"></a> Short Configuration Reference  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>The following table gives a short reference of all board configuration parameters used by the ESP8266 port in alphabetical order.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Short Description </th><th>Type*  </th></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C0_SPEED</a></td><td>Bus speed of <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C0_SCL</a> </td><td>GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C0_SDA</a> </td><td>GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C1_SPEED</a></td><td>Bus speed of <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(1)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C1_SCL</a> </td><td>GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(1)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_i2c_interfaces">I2C1_SDA</a> </td><td>GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(1)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_pwm_channels">PWM0_GPIOS</a> </td><td>GPIOs that can be used at channels of <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a> </td><td>o </td></tr>
<tr>
<td><a href="#esp8266_spi_interfaces">SPI0_CS0</a> </td><td>GPIO used as default CS for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> </td><td>o </td></tr>
</table>
</center><p><b>*Type:</b> m - mandatory, o - optional</p>
<p>The following table gives a short reference in alphabetical order of modules that can be enabled/disabled by board configurations and/or application's makefile using <code>USEMODULE</code> and <code>DISABLE_MODULE</code>.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Module </th><th>Default </th><th>Short description  </th></tr>
<tr>
<td><a href="#esp8266_qemu_mode_and_gdb">esp_gdb</a> </td><td>not used </td><td>enable the compilation with debug information for debugging </td></tr>
<tr>
<td><a href="#esp8266_esp_gdbstub">esp_gdbstub</a> </td><td>not used </td><td>enable the compilation of the <code>gdbstub</code> interface </td></tr>
<tr>
<td><a href="#esp8266_esp_idf_heap_implementation">esp_idf_heap</a> </td><td>not used </td><td>use SDK heap implementation </td></tr>
<tr>
<td><a href="#esp8266_esp_now_network_interface">esp_now</a> </td><td>not used </td><td>enable the ESP-NOW network device </td></tr>
<tr>
<td><a href="#esp8266_qemu_mode_and_gdb">esp_qemu</a> </td><td>not used </td><td>generate image for <code>QEMU</code> and <code>GDB</code> debugging </td></tr>
<tr>
<td><a href="#esp8266_spiffs_device">esp_spiffs</a> </td><td>not used </td><td>enable SPIFFS for on-board flash memory </td></tr>
<tr>
<td><a href="#esp8266_wifi_network_interface">esp_wifi</a> </td><td>not used </td><td>enable the Wifi network device </td></tr>
</table>
</center><center></center><center><table class="doxtable">
<tr>
<th>MCU </th><th>ESP8266EX  </th></tr>
<tr>
<td>Vendor </td><td>Espressif </td></tr>
<tr>
<td>Cores </td><td>1 x Tensilica Xtensa LX106 </td></tr>
<tr>
<td>FPU </td><td>no </td></tr>
<tr>
<td>RAM </td><td>80 kByte user-data RAM <br />
 32 kByte instruction RAM <br />
 32 kByte instruction cache <br />
 16 kByte EST system-data RAM </td></tr>
<tr>
<td>Flash </td><td>512 kByte ... 16 MByte </td></tr>
<tr>
<td>Frequency </td><td>80 MHz or 160 MHz </td></tr>
<tr>
<td>Power Consumption </td><td>70 mA in normal operating mode <br />
 20 uA in deep sleep mode </td></tr>
<tr>
<td>Timers </td><td>1 x 32 bit </td></tr>
<tr>
<td>ADCs </td><td>1 x 10 bit (1 channel) </td></tr>
<tr>
<td>GPIOs </td><td>16 </td></tr>
<tr>
<td>I2Cs </td><td>2 (software implementation) </td></tr>
<tr>
<td>SPIs </td><td>2 </td></tr>
<tr>
<td>UARTs </td><td>1 (console) + 1 transmit-only </td></tr>
<tr>
<td>WiFi </td><td>IEEE 802.11 b/g/n built in </td></tr>
<tr>
<td>Vcc </td><td>2.5 - 3.6 V </td></tr>
<tr>
<td>Datasheet </td><td><a href="https://www.espressif.com/sites/default/files/documentation/0a-esp8266ex_datasheet_en.pdf">Datasheet</a> </td></tr>
<tr>
<td>Technical Reference </td><td><a href="https://www.espressif.com/sites/default/files/documentation/esp8266-technical_reference_en.pdf">Technical Reference</a> </td></tr>
</table>
</center><p><br />
</p>
<dl class="section note"><dt>Note</dt><dd>ESP8285 is simply an ESP8266 SoC with 1 MB built-in flash. Therefore, the documentation also applies to the SoC ESP8285, even if only the ESP8266 SoC is described below.</dd></dl>
<h1><a class="anchor" id="esp8266_toolchain"></a> Toolchain </h1>
<p>The following software components are required for compilation:</p>
<ul>
<li><b>Xtensa GCC</b> compiler suite for ESP8266</li>
<li>Modified <b>ESP8266 RTOS SDK</b> which includes all SOC definitions and some binary libraries</li>
<li>Modified version of ESP flash programmer tool <b><code>esptool.py</code></b></li>
</ul>
<p>There are two options to install the toolchain:</p>
<ul>
<li>using RIOT Docker (<b>riotdocker</b>), see section <a href="#esp8266_riot_docker_toolchain">RIOT Docker Toolchain (riotdocker)</a></li>
<li><b>manual installation</b>, see section <a href="#esp8266_manual_toolchain_installation">Manual Toolchain Installation</a></li>
</ul>
<p>In both cases, the ESP flash programmer tool <code>esptool.py</code> is required, see section <a href="#esp8266_installation_of_esptool">Installation of <code>esptool.py</code></a>.</p>
<h2><a class="anchor" id="esp8266_riot_docker_toolchain"></a> RIOT Docker Toolchain (riotdocker)  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The easiest way to install the toolchain is to use RIOT Docker <code>riotdocker</code>. The compilation process using RIOT Docker consists of two steps</p>
<ol type="1">
<li>making the RIOT application in RIOT Docker with command <code>make BOARD=...</code></li>
<li>flashing the RIOT application on the host computer with command <code>make flash-only BOARD=...</code></li>
</ol>
<p>where step 2 requires that the ESP flash programmer tool <code>esptool.py</code> is installed. Both steps can also be performed with a single command on the host system using the <code>BUILD_IN_DOCKER</code> variable:</p>
<div class="fragment"><div class="line">BUILD_IN_DOCKER=1 make BOARD=... flash</div></div><!-- fragment --><h3><a class="anchor" id="esp8266_preparing_the_environment"></a> Preparing the Environment  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>Using RIOT Docker requires at least the following software components:</p>
<ul>
<li><b>Docker</b> container virtualization software</li>
<li>RIOT Docker image (<b><code>riotdocker</code></b>)</li>
<li>ESP flash programmer tool <b><code>esptool.py</code></b></li>
</ul>
<p>For information about installing Docker on your host, refer to the appropriate manuals for your operating system. The easiest way to install Docker on an Ubuntu/Debian system is for example:</p>
<div class="fragment"><div class="line">sudo apt-<span class="keyword">get</span> install docker.io</div></div><!-- fragment --><p>For information on how to install <code>esptool.py</code>, see section <a href="#esp8266_installation_of_esptool">Installation of <code>esptool.py</code></a>.</p>
<h3><a class="anchor" id="esp8266_using_existing_docker_image"></a> Using an Existing RIOT Docker Image  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>The easiest way to use RIOT Docker is to use an existing <code>riotdocker</code> image. You can either pull and start the <a href="https://hub.docker.com/r/schorcht/riotbuild_esp8266_rtos">schorcht/riotbuild_esp8266_rtos</a> Docker image which only contains the toolchain for ESP8266 RTOS SDK using</p>
<div class="fragment"><div class="line">cd /path/to/RIOT</div><div class="line">docker run -i -t -u $UID -v $(pwd):/data/riotbuild schorcht/riotbuild_esp8266_rtos_sdk</div></div><!-- fragment --><p>or the <a href="https://hub.docker.com/r/riot/riotbuild/">riot/riotbuild</a> Docker image (size is about 1.5 GB) which contains the toolchains for all platforms using</p>
<div class="fragment"><div class="line">cd /path/to/RIOT</div><div class="line">docker run -i -t -u $UID -v $(pwd):/data/riotbuild <a class="code" href="namespaceriot.html">riot</a>/riotbuild</div></div><!-- fragment --><h3><a class="anchor" id="esp8266_generating_docker_image"></a> Generating a riotdocker Image  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>Alternatively, you can generate the <code>riotdocker</code> image by yourself. A <code>riotdocker</code> fork that only installs the toolchain for ESP8266 RTOS SDK is available at <a href="https://github.com/gschorcht/riotdocker-Xtensa-ESP.git">GitHub</a>. After cloning this repository, checkout branch <code>esp8266_only_rtos_sdk</code> to generate a Docker image with a size of "only" 890 MByte:</p>
<div class="fragment"><div class="line">cd $HOME/esp</div><div class="line">git clone https:<span class="comment">//github.com/gschorcht/riotdocker-Xtensa-ESP.git</span></div><div class="line">cd riotdocker-Xtensa-ESP</div><div class="line">git checkout esp8266_only_rtos_sdk</div><div class="line">docker build -t riotbuild .</div></div><!-- fragment --><p>A <code>riotdocker</code> version that contains toolchains for all platforms supported by RIOT can be found at <a href="https://github.com/RIOT-OS/riotdocker">GitHub</a>. However, the Docker image generated from this Docker file has a size of about 1.5 GByte.</p>
<p>Once the Docker image has been created, it can be started with the following commands while in the RIOT root directory:</p>
<div class="fragment"><div class="line">cd /path/to/RIOT</div><div class="line">docker run -i -t -u $UID -v $(pwd):/data/riotbuild riotbuild</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>RIOT's root directory <code>/path/to/RIOT</code> becomes visible as the home directory of the <code>riotbuild</code> user in the Docker. That is, the output of compilations in RIOT Docker are also accessible on the host system.</dd></dl>
<p>Please refer the <a href="https://github.com/RIOT-OS/RIOT/wiki/Use-Docker-to-build-RIOT">RIOT wiki</a> on how to use the Docker image to compile RIOT OS.</p>
<h3><a class="anchor" id="esp8266_flashing_using_docker"></a> Make Process with RIOT Docker &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>Using RIOT Docker, the make process consists of the following two steps:</p>
<ol type="1">
<li><b>making</b> the RIOT binary <b>within RIOT Docker</b></li>
<li><b>flashing</b> the RIOT binary using a flasher program <b>on the host system</b></li>
</ol>
<p>Once the according RIOT Docker image has been started from RIOT's root directory, a RIOT application can be compiled inside RIOT Docker using the make command as usual, for example:</p>
<div class="fragment"><div class="line">make BOARD=esp8266-esp-12x -C tests/shell ...</div></div><!-- fragment --><p> This will generate a RIOT binary in ELF format.</p>
<dl class="section note"><dt>Note</dt><dd>You can't use the <code>flash</code> target inside RIOT Docker.</dd></dl>
<p>The RIOT binary has to be flash outside RIOT Docker on the host system. Since the RIOT Docker image was started while in RIOT's root directory, the output of the compilations is also accessible on the host system. On the host system, the <code>flash-only</code> target can then be used to flash the binary.</p>
<div class="fragment"><div class="line">make flash-only BOARD=esp8266-esp-12x -C tests/shell</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Both steps can also be performed with a single command on the host system using the <code>BUILD_IN_DOCKER</code> variable: <div class="fragment"><div class="line">`BUILD_IN_DOCKER=1 make BOARD=... flash</div></div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="esp8266_manual_toolchain_installation"></a> Manual Toolchain Installation  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>A more difficult way to install the toolchain is the manual installation of all required components as described below.</p>
<dl class="section note"><dt>Note</dt><dd>To install the toolchain manually, a 64-bit Linux system is required. Furthermore, the following packages (Debian/Ubuntu) have to be installed:<br />
 <code>build-essential</code>, <code>cppcheck</code>, <code>coccinelle</code>, <code>curl</code>, <code>doxygen</code>, <code>git</code>, <code>graphviz</code>, <code>make</code>, <code>pcregrep</code>, <code>python</code>, <code>python-serial</code>, <code>python3</code>, <code>python3-flake8</code>, <code>unzip</code>, <code>wget</code></dd></dl>
<h3><a class="anchor" id="esp8266_installation_of_xtensa_gcc"></a> Installation of Xtensa GCC compiler suite  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>The Xtensa GCC compiler for ESP8266 configured for use with RIOT-OS can be downloaded and installed as precompiled binary archive from <a href="https://github.com/gschorcht/xtensa-esp8266-elf">GitHub</a>:</p>
<div class="fragment"><div class="line">mkdir -p $HOME/esp</div><div class="line">cd $HOME/esp</div><div class="line">git clone https:<span class="comment">//github.com/gschorcht/xtensa-esp8266-elf</span></div></div><!-- fragment --><p>Once the compiler is installed, you have to expand your <code>PATH</code> variable by the directory with Xtensa GCC binaries:</p>
<div class="fragment"><div class="line">export PATH=$HOME/esp/xtensa-esp8266-elf/bin:$PATH</div></div><!-- fragment --><h3><a class="anchor" id="esp8266_installation_of_esp_idf"></a> Installation of the ESP8266 RTOS SDK &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>To compile RIOT-OS with the ESP8266 RTOS SDK, a modified version of the SDK is required. This modified version can also be downloaded as <a href="https://github.com/gschorcht/RIOT-Xtensa-ESP8266-RTOS-SDK.git">GIT</a> repository.</p>
<div class="fragment"><div class="line">cd $HOME/esp</div><div class="line">git clone https:<span class="comment">//github.com/gschorcht/RIOT-Xtensa-ESP8266-RTOS-SDK.git ESP8266_RTOS_SDK</span></div><div class="line">cd ESP8266_RTOS_SDK/</div><div class="line">git checkout release/v3.1-<span class="keywordflow">for</span>-<a class="code" href="namespaceriot.html">riot</a>-os-v2</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>Please be sure to checkout the correct branch that was used for the RIOT-OS port. Other versions will not work because they do not have the necessary changes.</li>
<li>Since we only use a few header files and some binary libraries, ESP8266 RTOS SDK does not need to be compiled in any way.</li>
</ul>
</dd></dl>
<p>To use the installed ESP8266 RTOS SDK, set the environment variable <code>ESP8266_RTOS_SDK_DIR</code>.</p>
<div class="fragment"><div class="line">export ESP8266_RTOS_SDK_DIR=$HOME/esp/ESP8266_RTOS_SDK</div></div><!-- fragment --><h3><a class="anchor" id="esp8266_installation_of_esptool"></a> Installation of <code>esptool.py</code> (ESP flash programmer tool)  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>The RIOT port does not work with the <code>esptool.py</code> ESP flasher program available on <a href="https://github.com/espressif/esptool">GitHub</a> or as package for your OS. Instead, a modified version from the ESP8266 RTOS SDK is required.</p>
<p>To avoid the installation of the complete ESP8266 RTOS SDK, for example because RIOT Docker <code>riotdocker</code> is used for compilation, <code>esptool.py</code> has been extracted from the ESP8266 RTOS SDK and placed in RIOT's directory <code>dist/tools/esptool</code>. For convenience, the build system uses always the version from this directory.</p>
<p>Therefore, it is <b>not necessary to install</b> <code>esptool.py</code> explicitly. However <code>esptool.py</code> depends on <code>pySerial</code> which can be installed either using <code>pip</code></p>
<div class="fragment"><div class="line">sudo pip install pyserial</div></div><!-- fragment --><p> or the package manager of your OS, for example on Debian/Ubuntu systems: </p><div class="fragment"><div class="line">apt install python-pyserial</div></div><!-- fragment --><p> For more information on <code>esptool.py</code>, please refer the <a href="https://github.com/espressif/esptool">git repository</a>.</p>
<h1><a class="anchor" id="esp8266_flashing_the_device"></a> Flashing the Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<h2><a class="anchor" id="esp8266_toolchain_usage"></a> Toolchain Usage  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>Once you have installed all required components, you should have the following directories.</p>
<div class="fragment"><div class="line">/path/to/esp/xtensa-esp8266-elf</div><div class="line">/path/to/esp/ESP8266_RTOS_SDK</div></div><!-- fragment --><p>To use the toolchain, please ensure that your environment variables are set correctly to</p>
<div class="fragment"><div class="line">export PATH=/path/to/esp/xtensa-esp8266-elf/bin:$PATH</div><div class="line">export ESP8266_RTOS_SDK_DIR=/path/to/esp/ESP8266_RTOS_SDK</div></div><!-- fragment --><h2><a class="anchor" id="esp8266_compile_options"></a> Compile Options  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The compilation process can be controlled by following make variables:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Option </th><th>Values </th><th>Default </th><th>Description  </th></tr>
<tr>
<td>FLASH_MODE </td><td>dout, dio, qout, qio </td><td>dout </td><td>Set the flash mode, please take care with your module, see section <a href="#esp8266_flash_modes">Flash Modes</a> </td></tr>
<tr>
<td>PORT </td><td>/dev/&lt;port&gt; </td><td>/dev/USB0 </td><td>Set the USB port for flashing the firmware </td></tr>
</table>
</center><p><br />
</p>
<p>Optional features of ESP8266 can be enabled using <code>USEMODULE</code> definitions in the makefile of the application. These are:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Module </th><th>Description  </th></tr>
<tr>
<td><a href="#esp8266_qemu_mode_and_gdb">esp_gdb</a> </td><td>Enable the compilation with debug information </td></tr>
<tr>
<td><a href="#esp8266_esp_gdbstub">esp_gdbstub</a> </td><td>Enable the compilation of the <code>gdbstub</code> interface for debugging with <code>GDB</code> </td></tr>
<tr>
<td><a href="#esp8266_esp_idf_heap_implementation">esp_idf_heap</a> </td><td>Enable SDK heap implementation which provides remaining IRAM as additional heap region </td></tr>
<tr>
<td><a href="#esp8266_esp_now_network_interface">esp_now</a> </td><td>Enable the built-in WiFi module with the ESP-NOW protocol as <code>netdev</code> network device </td></tr>
<tr>
<td><a href="#esp8266_qemu_mode_and_gdb">esp_qemu</a> </td><td>Enable the compilation of an <code>QEMU</code> image for debugging with <code>GDB</code> </td></tr>
<tr>
<td><a href="#esp8266_spiffs_device">esp_spiffs</a> </td><td>Enable the SPIFFS drive in on-board flash memory </td></tr>
<tr>
<td><a href="#esp8266_timers">esp_sw_timer</a> </td><td>Enable software timer implementation </td></tr>
<tr>
<td><a href="#esp8266_wifi_network_interface">esp_wifi</a> </td><td>Enable the built-in WiFi module in infrastructure mode as <code>netdev</code> network device </td></tr>
</table>
</center><p><br />
</p>
<p>For example, to activate the SPIFFS drive in on-board flash memory, the makefile of application has simply to add the <code>esp_spiffs</code> module to <code>USEMODULE</code> make variable:</p>
<div class="fragment"><div class="line">USEMODULE += esp_spiffs</div></div><!-- fragment --><p>Modules can also be activated temporarily at the command line when calling the make command:</p>
<div class="fragment"><div class="line">USEMODULE=<span class="stringliteral">&quot;esp_spiffs&quot;</span> make BOARD=...</div></div><!-- fragment --><h2><a class="anchor" id="esp8266_flash_modes"></a> Flash Modes  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The <code>FLASH_MODE</code> make command variable determines the mode that is used for flash access in normal operation.</p>
<p>The flash mode determines whether 2 data lines (<code>dio</code> and <code>dout</code>) or 4 data lines (<code>qio</code> and <code>qout</code>) for addressing and data access. For each data line, one GPIO is required. Therefore, using <code>qio</code> or <code>qout</code> increases the performance of SPI Flash data transfers, but uses two additional GPIOs (GPIO9 and GPIO10). That is, in this flash modes these GPIOs are not available for other purposes. If you can live with lower flash data transfer rates, you should always use <code>dio</code> or <code>dout</code> to keep GPIO9 and GPIO10 free for other purposes.</p>
<p>For more information about these flash modes, refer the documentation of <a href="https://github.com/espressif/esptool/wiki/SPI-Flash-Modes">esptool.py</a>.</p>
<dl class="section note"><dt>Note</dt><dd>While ESP8266 modules can be flashed with <code>qio</code>, <code>qout</code>, <code>dio</code> and <code>dout</code>, ESP8285 modules have to be always flashed in <code>dout</code> mode. The default flash mode is <code>dout</code>.</dd></dl>
<h2><a class="anchor" id="esp8266_erasing"></a> Erasing the Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The flash memory of ESP8266 can be erased completely with following command: </p><div class="fragment"><div class="line">esptool.py erase_flash</div></div><!-- fragment --><h1><a class="anchor" id="esp8266_peripherals"></a> Peripherals  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<h2><a class="anchor" id="esp8266_gpio_pins"></a> GPIO pins  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 has 17 GPIO pins, which are all digital pins. Some of them can not be used at all or have bootstrapping capabilities and are therefore not available on all boards.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Pin </th><th>Remarks  </th></tr>
<tr>
<td>GPIO0 </td><td>usually pulled up </td></tr>
<tr>
<td>GPIO1 </td><td>UART TxD </td></tr>
<tr>
<td>GPIO2 </td><td>usually pulled up </td></tr>
<tr>
<td>GPIO3 </td><td>UART RxD </td></tr>
<tr>
<td>GPIO4 </td><td></td></tr>
<tr>
<td>GPIO5 </td><td></td></tr>
<tr>
<td>GPIO6 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO7 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO8 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO9 </td><td>Flash SPI in <code>qout</code> and <code>qio</code> mode, see section <a href="#esp8266_flash_modes">Flash Modes</a> </td></tr>
<tr>
<td>GPIO10 </td><td>Flash SPI in <code>qout</code> and <code>qio</code> mode, see section <a href="#esp8266_flash_modes">Flash Modes</a> </td></tr>
<tr>
<td>GPIO11 </td><td>Flash SPI </td></tr>
<tr>
<td>GPIO12 </td><td></td></tr>
<tr>
<td>GPIO13 </td><td></td></tr>
<tr>
<td>GPIO14 </td><td></td></tr>
<tr>
<td>GPIO15 </td><td>usually pulled down </td></tr>
<tr>
<td>GPIO16 </td><td>RTC pin and wake up signal in deep sleep mode </td></tr>
</table>
</center><p>GPIO0, GPIO2, and GPIO15 are bootstrapping pins which are used to boot ESP8266 in different modes:</p>
<center></center><center><table class="doxtable">
<tr>
<th align="center">GPIO0 </th><th align="center">GPIO2 </th><th align="center">GPIO15 (MTDO) </th><th align="left">Mode  </th></tr>
<tr>
<td align="center">1 </td><td align="center">X </td><td align="center">X </td><td align="left">boot in SDIO mode to start OCD </td></tr>
<tr>
<td align="center">0 </td><td align="center">0 </td><td align="center">1 </td><td align="left">boot in UART mode for flashing the firmware </td></tr>
<tr>
<td align="center">0 </td><td align="center">1 </td><td align="center">1 </td><td align="left">boot in FLASH mode to boot the firmware from flash (default mode) </td></tr>
</table>
</center><h2><a class="anchor" id="esp8266_adc_channels"></a> ADC Channels  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 has <b>one dedicated ADC</b> pin with a resolution of 10 bits. This ADC pin can measure voltages in the range of <b>0 V ... 1.1 V</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Some boards have voltage dividers to scale this range to a maximum of 3.3 V. For more information, see the hardware manual for the board.</dd></dl>
<h2><a class="anchor" id="esp8266_spi_interfaces"></a> SPI Interfaces  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 has two SPI controllers:</p>
<ul>
<li><em>CSPI</em> for caching and accessing the flash memory<br />
</li>
<li><em>HSPI</em> for peripherals</li>
</ul>
<p>Thus, <em>HSPI</em> is the only SPI interface that is available for peripherals. It is exposed as RIOT's <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a>. The pin configuration of the <em>HSPI</em> interface is fixed as shown in following table.</p>
<center></center><center><table class="doxtable">
<tr>
<th>Signal </th><th>Pin  </th></tr>
<tr>
<td><a class="el" href="boards_2esp32-wrover-kit_2include_2periph__conf_8h.html#aabba8137ea69a9180bedb49e83873988" title="SD Card MISO. ">SPI0_MISO</a> </td><td>GPIO12 </td></tr>
<tr>
<td><a class="el" href="boards_2esp32-wrover-kit_2include_2periph__conf_8h.html#a16ce69be83444ff939653090fb7fa151" title="SD Card MOSI. ">SPI0_MOSI</a> </td><td>GPIO13 </td></tr>
<tr>
<td><a class="el" href="boards_2esp32-wrover-kit_2include_2periph__conf_8h.html#a85a885041758879c90a08fed7a75d2e2" title="SD Card SCL. ">SPI0_SCK</a> </td><td>GPIO14 </td></tr>
<tr>
<td><a class="el" href="boards_2esp32-wrover-kit_2include_2periph__conf_8h.html#a5b44b397784631135a7c50730f5b8ffb" title="SD Card CS. ">SPI0_CS0</a> </td><td>GPIOn with n = 0, 2, 4, 5, 15, 16 (additionally 9, 10 in DOUT flash mode) </td></tr>
</table>
</center><p>The only pin definition that can be overridden by an application-specific board configuration is the CS signal defined by <a class="el" href="boards_2esp32-wrover-kit_2include_2periph__conf_8h.html#a5b44b397784631135a7c50730f5b8ffb" title="SD Card CS. ">SPI0_CS0</a>.</p>
<p>When the SPI is enabled using module <code>periph_spi</code>, these GPIOs cannot be used for any other purpose. GPIOs 0, 2, 4, 5, 15, and 16 can be used as CS signal. In <code>dio</code> and <code>dout</code> flash modes (see section <a href="#esp8266_flash_modes">Flash Modes</a>), GPIOs 9 and 10 can also be used as CS signal.</p>
<h2><a class="anchor" id="esp8266_i2c_interfaces"></a> I2C Interfaces  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>Since the ESP8266 does not or only partially support the I2C in hardware, I2C interfaces are realized as <b>bit-banging protocol in software</b>. The maximum usable bus speed is therefore <a class="el" href="group__drivers__periph__i2c.html#gga6e6a870f98abb8cffa95373b69fb8243a42e708fe61f237d88f6cf53f32e17e8e" title="fast plus mode: ~1000 kbit/s ">I2C_SPEED_FAST_PLUS</a>. The maximum number of buses that can be defined is 2, <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a> and <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(1)</a>.</p>
<p>GPIO pins (<a class="el" href="boards_2esp8266-sparkfun-thing_2include_2periph__conf_8h.html#a69f255245dd74fb6785ca39656cf9983" title="SCL signal of I2C_DEV(0) ">I2C0_SCL</a>, <a class="el" href="boards_2esp8266-sparkfun-thing_2include_2periph__conf_8h.html#af530325ce28cf25ce89308fbd9ac8c16" title="SDA signal of I2C_DEV(0) ">I2C0_SDA</a> and/or <code>I2C1_SCL</code>, <code>I2C1_SDA</code>) have to be defined in the board-specific peripheral configuration in <code>$BOARD/periph_conf.h</code>. Furthermore, the default I2C bus speed (<a class="el" href="boards_2esp8266-sparkfun-thing_2include_2periph__conf_8h.html#a0370de2a226ec75dd11d53d0915a7754" title="I2C bus speed of I2C_DEV(0) ">I2C0_SPEED</a> and/or <code>I2C1_SPEED</code>) that is used for I2C bus(ses) has to be defined. The number of configured buses <a class="el" href="esp8266_2include_2periph__conf__common_8h.html#abce62e16a6e3b3205801fed93c51692d" title="Number of I2C interfaces. ">I2C_NUMOF</a> is then determined automatically from these definitions.</p>
<p>In the following example, only one I2C bus is defined:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define I2C0_SPEED     I2C_SPEED_FAST</span></div><div class="line"><span class="preprocessor">#define I2C0_SDA       GPIO4</span></div><div class="line"><span class="preprocessor">#define I2C0_SCL       GPIO5</span></div></div><!-- fragment --><p> A configuration with two I2C buses would look like the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define I2C0_SPEED     I2C_SPEED_FAST</span></div><div class="line"><span class="preprocessor">#define I2C0_SDA       GPIO4</span></div><div class="line"><span class="preprocessor">#define I2C0_SCL       GPIO5</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define I2C1_SPEED     I2C_SPEED_NORMAL</span></div><div class="line"><span class="preprocessor">#define I2C1_SDA       GPIO2</span></div><div class="line"><span class="preprocessor">#define I2C1_SCL       GPIO14</span></div></div><!-- fragment --><p>All these configurations can be overridden by an <a href="#esp8266_application_specific_board_configuration">application-specific board configuration</a>.</p>
<h2><a class="anchor" id="esp8266_pwm_channels"></a> PWM Channels  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The hardware implementation of ESP8266 PWM supports only frequencies as power of two. Therefore, a <b>software implementation</b> of <b>one PWM device</b> (<a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a>) with up to <b>8 PWM channels</b> (<a class="el" href="esp8266_2include_2periph__cpu_8h.html#a8b967c03fbfe9d5b391c689b9b060b55" title="Maximum number of channels per PWM device. ">PWM_CHANNEL_NUM_MAX</a>) is used.</p>
<dl class="section note"><dt>Note</dt><dd>The minimum PWM period that can be realized with this software implementation is 10 us or 100.000 PWM clock cycles per second. Therefore, the product of frequency and resolution should not be greater than 100.000. Otherwise the frequency is scaled down automatically.</dd></dl>
<p>The GPIOs that can be used as channels of the PWM device <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a> are defined by <a class="el" href="boards_2esp8266-sparkfun-thing_2include_2periph__conf_8h.html#a6d98f0e073d8b7dee809df091e612d0e" title="Declaration of the channels for device PWM_DEV(0), at maximum 8 channels. ">PWM0_GPIOS</a>. By default, all GPIOs that are not used as I2C, SPI, or UART signals are defined as PWM channels in board definition. As long as these channels are not initialized with function <a class="el" href="group__drivers__periph__pwm.html#ga205eedf5331e5646b330d986f2b691f9" title="Initialize a PWM device. ">pwm_init</a>, they can be used as normal GPIOs for other purposes. Even if they are already initialized, but have a duty cycle value of 0 can be used as output GPIOs for other purposes. GPIOs in <a class="el" href="boards_2esp8266-sparkfun-thing_2include_2periph__conf_8h.html#a6d98f0e073d8b7dee809df091e612d0e" title="Declaration of the channels for device PWM_DEV(0), at maximum 8 channels. ">PWM0_GPIOS</a> that are used for other purposes, e.g., I2C or SPI, are no longer available as PWM channels.</p>
<p>To define other GPIOs as PWM channels, just overwrite the definition of <a class="el" href="boards_2esp8266-sparkfun-thing_2include_2periph__conf_8h.html#a6d98f0e073d8b7dee809df091e612d0e" title="Declaration of the channels for device PWM_DEV(0), at maximum 8 channels. ">PWM0_GPIOS</a> in an <a href="#esp8266_application_specific_board_configuration">application-specific board configuration</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#define PWM0_GPIOS { GPIO12, GPIO13, GPIO14, GPIO15 }</span></div></div><!-- fragment --><h2><a class="anchor" id="esp8266_timers"></a> Timers  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>There are two timer implementations:</p>
<ul>
<li><b>hardware timer</b> implementation with <b>1 timer device</b> and only <b>1 channel</b> (default)</li>
<li><b>software timer</b> implementation with <b>1 timer device</b> and <b>10 channels</b></li>
</ul>
<p>By default, the <b>hardware timer implementation</b> is used.</p>
<p>Software timers use SDK's timers to implement the timer device and the channels. Although these SDK timers usually have a precision of a few microseconds, they can deviate up to 500 microseconds. So if you need a timer with high accuracy, you'll need to use the hardware timer with only one timer channel.</p>
<h2><a class="anchor" id="esp8266_spiffs_device"></a> SPIFFS Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>If SPIFFS module is enabled (<code>USEMODULE += esp_spiffs</code>), the implemented MTD system drive <a class="el" href="sensebox__samd21_2include_2board_8h.html#aff5f5efe3abd184592b11d520918dc44" title="MTD device 0 (SD Card) definition. ">mtd0</a> for the on-board SPI flash memory is used together with modules <code>spiffs</code> and <code>vfs</code> to realize a persistent file system.</p>
<p>For this purpose, the flash memory is formatted as SPIFFS starting at the address <code>0x80000</code> (512 kByte) on first boot. All sectors up to the last 5 sectors of the flash memory are then used for the file system. With a fixed sector size of 4096 bytes, the top address of the SPIFF is <code>flash_size - 5 * 4096</code>, e.g., <code>0xfb000</code> for a flash memory of 1 MByte. The size of the SPIFF then results from: </p><div class="fragment"><div class="line">flash_size - 5 * 4096 - 512 kByte</div></div><!-- fragment --><p>Please refer file <code>$RIOTBASE/tests/unittests/test-spiffs/tests-spiffs.c</code> for more information on how to use SPIFFS and VFS together with a MTD device <a class="el" href="sensebox__samd21_2include_2board_8h.html#aff5f5efe3abd184592b11d520918dc44" title="MTD device 0 (SD Card) definition. ">mtd0</a> alias <code>MTD_0</code>.</p>
<h2><a class="anchor" id="esp8266_other_peripherals"></a> Other Peripherals  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The ESP8266 port of RIOT also supports</p>
<ul>
<li>one hardware number generator with 32 bit,</li>
<li>one UART interface (GPIO1 and GPIO3),</li>
<li>a CPU-ID function, and</li>
<li>power management functions.</li>
</ul>
<p>RTC is not yet implemented.</p>
<h1><a class="anchor" id="esp8266_network_interfaces"></a> Network Interfaces  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>ESP8266 provides different built-in possibilities to realize network devices:</p>
<ul>
<li><b>ESP WiFi</b>, usual AP-based wireless LAN (not yet supported)</li>
<li><b>ESP-NOW</b>, a WiFi based AP-less and connectionless peer to peer communication protocol</li>
</ul>
<p><a class="anchor" id="esp8266_wifi_network_interface"></a></p><h2><a class="anchor" id="esp8266_wifi_network_interface"></a> WiFi Network Interface  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>The RIOT port for ESP8266 implements in module <code>esp_wifi</code> a <code>netdev</code> driver for the built-in WiFi interface.</p>
<dl class="section note"><dt>Note</dt><dd>Module <code>esp_wifi</code> is not automatically enabled when module <code>netdev_default</code> is used. Instead, if necessary, the application has to add the module <code>esp_wifi</code> in the Makefile.</dd></dl>
<div class="fragment"><div class="line">USEMODULE += esp_wifi</div></div><!-- fragment --><p>Furthermore, the following configuration parameters have to be defined:</p>
<center></center><center><table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Default </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><a class="el" href="esp__wifi__params_8h.html#ad2883d0cae1d96edaefd3b0a46b5ee46" title="SSID of the AP to be used. ">ESP_WIFI_SSID</a> </td><td align="left">"RIOT_AP" </td><td align="left">SSID of the AP to be used. </td></tr>
<tr>
<td align="left"><a class="el" href="esp__wifi__params_8h.html#ac0354e38c60a7a189ea8653efc4e0cd6" title="Passphrase used for the AP as clear text (max. ">ESP_WIFI_PASS</a> </td><td align="left">- </td><td align="left">Passphrase used for the AP as clear text (max. 64 chars). </td></tr>
<tr>
<td align="left"><a class="el" href="esp__wifi__params_8h.html#a46b0a15e70e1fb388c7ba70f5df96e29" title="The size of the stack used for the ESP WIFI netdev driver thread. ">ESP_WIFI_STACKSIZE</a> </td><td align="left"><a class="el" href="native_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f" title="CPU specific default stack sizes. ">THREAD_STACKSIZE_DEFAULT</a> </td><td align="left">Stack size used for the WiFi netdev driver thread. </td></tr>
</table>
</center><p>These configuration parameter definitions, as well as enabling the <code>esp_wifi</code> module, can be done either in the makefile of the project or at make command line, e.g.:</p>
<div class="fragment"><div class="line">USEMODULE=esp_wifi \</div><div class="line">CFLAGS=<span class="stringliteral">&#39;-DESP_WIFI_SSID=\&quot;MySSID\&quot; -DESP_WIFI_PASS=\&quot;MyPassphrase\&quot;&#39;</span> \</div><div class="line">make -C examples/gnrc_networking BOARD=...</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>Module <code>esp_wifi</code> is not enabled automatically when module <code>netdev_default</code> is used.</li>
<li>Leave 'ESP_WIFI_PASS' undefined to connect to an open WiFi access point.</li>
<li>The Wifi network interface (module <code>esp_wifi</code>) and the <a href="#esp8266_esp_now_network_interface">ESP-NOW network interface</a> (module <code>esp_now</code>) can be used simultaneously, for example, to realize a border router for a mesh network which uses ESP-NOW. In this case the ESP-NOW interface must use the same channel as the AP of the infrastructure WiFi network. All ESP-NOW nodes must therefore be compiled with the channel of the AP asvalue for the parameter 'ESP_NOW_CHANNEL'.</li>
</ul>
</dd></dl>
<p><a class="anchor" id="esp8266_esp_now_network_interface"></a></p><h2><a class="anchor" id="esp8266_esp_now_network_interface"></a> ESP-NOW Network Interface  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>With ESP-NOW, the ESP8266 provides a connectionless communication technology, featuring short packet transmission. It applies the IEEE802.11 Action Vendor frame technology, along with the IE function developed by Espressif, and CCMP encryption technology, realizing a secure, connectionless communication solution.</p>
<p>The RIOT port for ESP8266 implements in module <code>esp_now</code> a <code>netdev</code> driver which uses ESP-NOW to provide a link layer interface to a meshed network of ESP8266 nodes. In this network, each node can send short packets with up to 250 data bytes to all other nodes that are visible in its range.</p>
<dl class="section note"><dt>Note</dt><dd>Module <code>esp_now</code> is not enabled automatically if the <code>netdev_default</code> module is used. Instead, the application has to add the <code>esp_now</code> module in its makefile when needed.<br />
 <div class="fragment"><div class="line">USEMODULE += esp_now</div></div><!-- fragment --></dd></dl>
<p>For ESP-NOW, ESP8266 nodes are used in WiFi SoftAP + Station mode to advertise their SSID and become visible to other ESP8266 nodes. The SSID of an ESP8266 node is the concatenation of the prefix <code>RIOT_ESP_</code> with the MAC address of its SoftAP WiFi interface. The driver periodically scans all visible ESP8266 nodes.</p>
<p>The following parameters are defined for ESP-NOW nodes. These parameters can be overridden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<center></center><center><table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Default </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><a class="el" href="group__cpu__esp__common__conf.html#ga9c408e15c6391a0882903cebf057c8e9" title="Period in microseconds at which an ESP-NOW node scans for other ESP-NOW nodes in its range...">ESP_NOW_SCAN_PERIOD</a> </td><td align="left">10000000UL </td><td align="left">Defines the period in us at which an node scans for other nodes in its range. The default period is 10 s. </td></tr>
<tr>
<td align="left"><a class="el" href="group__cpu__esp__common__conf.html#ga2b6cc90c624c3d61d1baf0f45e5da843" title="Passphrase used for the SoftAP interface of for all ESP-NOW nodes. ">ESP_NOW_SOFT_AP_PASS</a> </td><td align="left">"ThisistheRIOTporttoESP" </td><td align="left">Defines the passphrase as clear text (max. 64 chars) that is used for the SoftAP interface of ESP-NOW nodes. It has to be same for all nodes in one network. </td></tr>
<tr>
<td align="left"><a class="el" href="group__cpu__esp__common__conf.html#ga9934ff67b258c730d3ad8ea2895948ce" title="Channel used as broadcast medium by all ESP-NOW nodes together. ">ESP_NOW_CHANNEL</a> </td><td align="left">6 </td><td align="left">Defines the channel that is used as the broadcast medium by all nodes together. </td></tr>
<tr>
<td align="left"><a class="el" href="group__cpu__esp__common__conf.html#gaa16006b12797275688a12d728de0982a" title="Key used for the communication between ESP-NOW nodesThe key has to be defined to enable encrypted com...">ESP_NOW_KEY</a> </td><td align="left">NULL </td><td align="left">Defines a key that is used for encrypted communication between nodes. If it is NULL, encryption is disabled. The key has to be of type <code>uint8_t[16]</code> and has to be exactly 16 bytes long. </td></tr>
</table>
</center><dl class="section note"><dt>Note</dt><dd>The ESP-NOW network interface (module <code>esp_now</code>) and the <a href="#esp8266_wifi_network_interface">Wifi network interface</a> (module <code>esp_wifi</code>) can be used simultaneously, for example, to realize a border router for a mesh network which uses ESP-NOW. In this case the ESP-NOW interface must use the same channel as the AP of the infrastructure WiFi network. All ESP-NOW nodes must therefore be compiled with the channel of the AP asvalue for the parameter 'ESP_NOW_CHANNEL'.</dd></dl>
<h1><a class="anchor" id="esp8266_preconfigured_devices"></a> Preconfigured Devices  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>The ESP8266 port of RIOT has been tested with several common external devices that can be connected to ESP8266 boards and are preconfigured accordingly.</p>
<h2><a class="anchor" id="esp8266_network_devices"></a> Network Devices  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>RIOT provides a number of driver modules for different types of network devices, e.g., IEEE 802.15.4 radio modules and Ethernet modules. The RIOT port for ESP8266 has been tested with the following network devices:</p>
<ul>
<li><a href="https://riot-os.org/api/group__drivers__mrf24j40.html">mrf24j40</a> (driver for Microchip MRF24j40 based IEEE 802.15.4</li>
<li><a href="https://riot-os.org/api/group__drivers__enc28j60.html">enc28j60</a> (driver for Microchip ENC28J60 based Ethernet modules)</li>
</ul>
<h3><a class="anchor" id="esp8266_using_mrf24j40"></a> Using MRF24J40 (module <code>mrf24j40</code>)  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>To use MRF24J40 based IEEE 802.15.4 modules as network device, the <code>mrf24j40</code> driver module has to be added to the makefile of the application:</p>
<div class="fragment"><div class="line">USEMODULE += mrf24j40</div></div><!-- fragment --><p>The <code>mrf24j40</code> driver module uses the following preconfigured interface parameters for ESP8266 boards:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Default </th><th>Remarks  </th></tr>
<tr>
<td><a class="el" href="esp32-mh-et-live-minikit_2include_2board__modules_8h.html#adc25f454d67c95e26607a64b782f78b5" title="SPI_DEV(0) is used (fixed) ">MRF24J40_PARAM_SPI</a> </td><td><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> </td><td>fixed, see section <a href="#esp8266_spi_interfaces">SPI Interfaces</a> </td></tr>
<tr>
<td><a class="el" href="esp32-mh-et-live-minikit_2include_2board__modules_8h.html#a4363d5c3db082bc24a232b015365cc6b" title="SPI bus speed used (can be overridden) ">MRF24J40_PARAM_SPI_CLK</a> </td><td>SPI_CLK_1MHZ </td><td>fixed </td></tr>
<tr>
<td><a class="el" href="esp32-mh-et-live-minikit_2include_2board__modules_8h.html#ad933b1703bf819e4995879a82dfaba06" title="MRF24J40 CS signal (can be overridden) ">MRF24J40_PARAM_CS</a> </td><td>GPIO16 </td><td>can be overridden </td></tr>
<tr>
<td><a class="el" href="esp32-mh-et-live-minikit_2include_2board__modules_8h.html#a11bdc69c3749ec56478167c8df9c48e3" title="MRF24J40 INT signal (can be overridden) ">MRF24J40_PARAM_INT</a> </td><td>GPIO0 </td><td>can be overridden </td></tr>
<tr>
<td><a class="el" href="esp32-mh-et-live-minikit_2include_2board__modules_8h.html#aed16735393af8e3349d066f5eaf02009" title="MRF24J40 RESET signal (can be overridden) ">MRF24J40_PARAM_RESET</a> </td><td>GPIO2 </td><td>can be overridden </td></tr>
</table>
</center><p><br />
</p>
<p>The GPIOs in this configuration can be overridden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<h3><a class="anchor" id="esp8266_using_enc28j60"></a> Using ENC28J60 (module <code>enc28j60</code>)  &#160;[<a href="#esp8266_toc">TOC</a>]</h3>
<p>To use ENC28J60 Ethernet modules as network device, the <code>enc28j60</code> driver module has to be added to the makefile of the application:</p>
<div class="fragment"><div class="line">USEMODULE += enc28j60</div></div><!-- fragment --><p>The <code>enc28j60</code> driver module uses the following preconfigured interface parameters for ESP8266 boards:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Default </th><th>Remarks  </th></tr>
<tr>
<td><a class="el" href="common_2esp8266_2include_2board__modules_8h.html#a7df487af5f0d54d37787380f9348c75b" title="SPI_DEV(0) is used (fixed) ">ENC28J60_PARAM_SPI</a> </td><td><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> </td><td>fixed, see section <a href="#esp8266_spi_interfaces">SPI Interfaces</a> </td></tr>
<tr>
<td><a class="el" href="common_2esp8266_2include_2board__modules_8h.html#a5f1b20d513f9a6e87db738b2d89e235c" title="ENC28J60 CS signal (can be overridden) ">ENC28J60_PARAM_CS</a> </td><td>GPIO4 </td><td>can be overridden </td></tr>
<tr>
<td><a class="el" href="common_2esp8266_2include_2board__modules_8h.html#a6743718b5e5891f0465dbf5c57e59dd3" title="ENC28J60 INT signal (can be overridden) ">ENC28J60_PARAM_INT</a> </td><td>GPIO9 </td><td>can be overridden </td></tr>
<tr>
<td><a class="el" href="common_2esp8266_2include_2board__modules_8h.html#add18cefd21f0a31dc22cde3d25cc6ca4" title="ENC28J60 RESET signal (can be overridden) ">ENC28J60_PARAM_RESET</a> </td><td>GPIO10 </td><td>can be overridden </td></tr>
</table>
</center><p>The GPIOs in this configuration can be overridden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<h2><a class="anchor" id="esp8266_sd_card_device"></a> SD-Card Device  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 port of RIOT is preconfigured for RIOT applications that use the <a href="https://riot-os.org/api/group__drivers__sdcard__spi.html">SPI SD-Card driver</a>. To use SPI SD-Card driver, the <code>sdcard_spi</code> module has to be added to a makefile:</p>
<div class="fragment"><div class="line">USEMODULE += sdcard_spi</div></div><!-- fragment --><p>The <code>sdcard_spi</code> driver module uses the following preconfigured interface parameters for ESP8266 boards:</p>
<center></center><center><table class="doxtable">
<tr>
<th>Parameter </th><th>Default </th><th>Remarks  </th></tr>
<tr>
<td><a class="el" href="esp32-wrover-kit_2include_2board_8h.html#a41cbf87bcb5db3d76e7bce9db6718437" title="SPI_DEV(0) is used when camera is connected. ">SDCARD_SPI_PARAM_SPI</a> </td><td><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> </td><td>fix, see section <a href="#esp8266_spi_interfaces">SPI Interfaces</a> </td></tr>
<tr>
<td><a class="el" href="esp32-wrover-kit_2include_2board_8h.html#a98bbf84fda3506835da403b773e5bedf" title="HSPI CS1 is used (fixed) ">SDCARD_SPI_PARAM_CS</a> </td><td><a class="el" href="boards_2esp32-wrover-kit_2include_2periph__conf_8h.html#a5b44b397784631135a7c50730f5b8ffb" title="SD Card CS. ">SPI0_CS0</a> </td><td>can be overridden </td></tr>
</table>
</center><p>The GPIO used as CS signal can be overridden by <a href="#esp8266_application_specific_board_configuration">application-specific board configurations</a>.</p>
<p><a class="anchor" id="esp8266_app_spec_conf"></a></p><h1><a class="anchor" id="esp8266_application_specific_configurations"></a> Application-Specific Configurations  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>The board-specific configuration files <code>board.h</code> and <code>periph_conf.h</code> as well as the driver parameter configuration files <code>&lt;driver&gt;_params.h</code> define the default configurations for peripherals and device driver modules. These are, for example, the GPIOs used, bus interfaces used or available bus speeds. Because there are many possible configurations and many different application requirements, these default configurations are usually only a compromise between different requirements.</p>
<p>Therefore, it is often necessary to change some of these default configurations for individual applications. For example, while many PWM channels are needed in one application, another application does not need PWM channels, but many ADC channels.</p>
<h2><a class="anchor" id="esp8266_application_specific_board_configuration"></a> Application-Specific Board Configuration  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>To override default board configurations, simply create an application-specific board configuration file <code>$APPDIR/board.h</code> in the source directory <code>$APPDIR</code> of the application and add the definitions to be overridden. To force the preprocessor to include board's original <code>board.h</code> after that, add the <code>include_next</code> preprocessor directive as the <b>last</b> line.</p>
<p>For example to override the default definition of the GPIOs that are used as PWM channels, the application-specific board configuration file <code>$APPDIR/board.h</code> could look like the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line"><span class="preprocessor">#define PWM0_GPIOS { GPIO12, GPIO13, GPIO14, GPIO15 }</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include_next &quot;board.h&quot;</span></div></div><!-- fragment --><p>It is important to ensure that the application-specific board configuration <code>$APPDIR/board.h</code> is included first. Insert the following line as the <b>first</b> line to the application makefile <code>$APPDIR/Makefile</code>. </p><div class="fragment"><div class="line">INCLUDES += -I$(APPDIR)</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>To make such application-specific board configurations dependent on the ESP8266 MCU or a particular ESP8266 board, you should always enclose these definitions in the following constructs <div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line">...</div><div class="line">#endif</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef BOARD_ESP8266_ESP-12X</span></div><div class="line">...</div><div class="line">#endif</div></div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="esp8266_application_specific_driver_configuration"></a> Application-Specific Driver Configuration  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>Using the approach for overriding board configurations, the parameters of drivers that are typically defined in <code>drivers/&lt;device&gt;/include/&lt;device&gt;_params.h</code> can be overridden. For that purpose just create an application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> in the source directory <code>$APPDIR</code> of the application and add the definitions to be overridden. To force the preprocessor to include driver's original <code>&lt;device&gt;_params.h</code> after that, add the <code>include_next</code> preprocessor directive as the <b>last</b> line.</p>
<p>For example, to override a GPIO used for LIS3DH sensor, the application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> could look like the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line"><span class="preprocessor">#define LIS3DH_PARAM_INT2           (GPIO_PIN(0, 4))</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include_next &quot;lis3dh_params.h&quot;</span></div></div><!-- fragment --><p>It is important to ensure that the application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> is included first. Insert the following line as the <b>first</b> line to the application makefile <code>$APPDIR/Makefile</code>. </p><div class="fragment"><div class="line">INCLUDES += -I$(APPDIR)</div></div><!-- fragment --><p>Please note:** To make such application-specific board configurations dependent on the ESP8266 MCU or a particular ESP8266 board, you should always enclose these definitions in the following constructs: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP8266</span></div><div class="line">...</div><div class="line">#endif</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef BOARD_ESP8266_ESP-12X</span></div><div class="line">...</div><div class="line">#endif</div></div><!-- fragment --><h1><a class="anchor" id="esp8266_sdk_specifics"></a> SDK Specific Information  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<h2><a class="anchor" id="esp8266_sdk_tasks"></a> SDK Tasks  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>ESP8266 RTOS SDK libraries create a number of high-priority threads, see the listing below, which handle high priority interrupts from SoC and WiFi hardware. These threads are also created, if the WiFi hardware is not used.</p>
<div class="fragment"><div class="line">pid | name                 | state    Q | pri | stack  ( used) | base addr  | current</div><div class="line">  - | isr_stack            | -        - |   - |   2048 (  832) | 0x3ffe8420 | 0x3ffe8c20</div><div class="line">  1 | ppT                  | bl rx    _ |   2 |   3632 ( 1296) | 0x3fff5df0 | 0x3fff6ac0</div><div class="line">  2 | pmT                  | bl rx    _ |   4 |   1072 (  320) | 0x3fff6c70 | 0x3fff6f70</div><div class="line">  3 | rtT                  | bl rx    _ |   3 |   2096 ( 1376) | 0x3fff70b0 | 0x3fff77b0</div><div class="line">  4 | esp_events           | bl rx    _ |   5 |   2096 (  864) | 0x3fff7f20 | 0x3fff8600</div></div><!-- fragment --><h2><a class="anchor" id="esp8266_esp_idf_heap_implementation"></a> SDK Heap Implementation  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<p>Using module <code>esp_idf_heap</code> enables the compilation of SDK heap handling instead of memory management provided by <code>newlibc</code>.</p>
<p>Normally, the remaining ESP8266 DRAM, which is not used by static variables, is provided as heap memory. The SDK heap implementation also provides the unused ESP8266 IRAM (Command RAM) as the additional heap memory region.</p>
<dl class="section note"><dt>Note</dt><dd>The heap in IRAM allows only 32-bit-aligned word access.</dd></dl>
<p>The following example shows the heap when the <code>esp_idf_heap</code> is used:</p>
<div class="fragment"><div class="line">Heap region 0 @40107690: 18800 (used 8, <a class="code" href="group__oneway__malloc.html#gafbedc913aa4651b3c3b4b3aecd9b4711">free</a> 18792) [bytes]</div><div class="line">Heap region 1 @3fff1760: 59552 (used 8520, <a class="code" href="group__oneway__malloc.html#gafbedc913aa4651b3c3b4b3aecd9b4711">free</a> 51032) [bytes]</div></div><!-- fragment --><p>In this example, heap region 0 at address <code>0x401xxxxx</code> is located in IRAM and heap region 1 at address <code>0x3fffxxxx</code> in DRAM. While memory management functions of <code>newlibc</code> use always heap region 1 in DRAM, functions of binary SDK libraries like the WiFi stack can also also heap region 0 for 32-bit aligned data.</p>
<h1><a class="anchor" id="esp8266_debugging"></a> Debugging  &#160;[<a href="#esp8266_toc">TOC</a>]</h1>
<p>There are two options to debug your RIOT application for ESP8266 either</p>
<ul>
<li>using <code>QEMU</code> and module <code>esp_gdb</code>, see <a href="#esp8266_qemu_mode_and_gdb">QEMU Mode andB</a> or</li>
<li>using module <code>esp_gdbstub</code>, see <a href="#esp8266_esp_gdbstub">Module esp_gdbstub</a>.</li>
</ul>
<h2><a class="anchor" id="esp8266_qemu_mode_and_gdb"></a> QEMU Mode and GDB  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<h3>Compilation for <code>QEMU</code></h3>
<p>When <code>QEMU</code> mode is enabled by using the <code>esp_qemu</code> module, <code>make flash</code> does not try to download the image of your RIOT application to the target hardware. Instead, a binary image <code>$ELFFILE.bin</code> as well as the 1 MByte flash image <code>esp8266flash.bin</code> is created in the application build directory <code></code>. This flash image can be used together with <code>QEMU</code> and <code>GDB</code> to debug the application.</p>
<p>For debugging purposes, the application should be compiled with debugging information. This can either be done by using the <code>esp_gdb</code> module, for example:</p>
<div class="fragment"><div class="line">USEMODULE=esp_gdb make flash BOARD=esp8266-esp-12x -C tests/shell</div></div><!-- fragment --><h3>Installation of <code>QEMU</code></h3>
<p>To use <code>QEMU</code>, you have to install <code>QEMU</code> for Xtensa with ESP8266 machine implementation first as following.</p>
<div class="fragment"><div class="line">cd /my/source/dir</div><div class="line">git clone https:<span class="comment">//github.com/gschorcht/qemu-xtensa</span></div><div class="line">cd qemu-xtensa/</div><div class="line">git checkout xtensa-esp8266</div><div class="line">export QEMU=/path/to/esp/qemu</div><div class="line">./configure --prefix=$QEMU --target-list=xtensa-softmmu --disable-werror</div><div class="line">make</div><div class="line">make install</div></div><!-- fragment --><h3>Start Debugging with <code>QEMU</code></h3>
<p>Once the compilation has been finished, <code>QEMU</code> for Xtensa with ESP8266 machine implementation should be available in <code>/path/to/esp/qemu/bin</code> and you can start it in first terminal with</p>
<div class="fragment"><div class="line">term1&gt; $QEMU/bin/qemu-system-xtensa -M esp8266 -nographic -serial stdio -monitor none -s -S \</div><div class="line">                                    -kernel /path/to/build/dir/esp8266flash.bin</div></div><!-- fragment --><p>where <code>/path/to/build/dir</code> is the path to the application build directory <code></code> where <code>$ELFFILE.bin</code> is generated by the <code>make</code> command, for example <code>/tests/shell/bin/esp8266-esp-12x</code>. After that you can start <code>GDB</code> in second terminal window using command:</p>
<div class="fragment"><div class="line">term2&gt; xtensa-esp8266-elf-gdb /path/to/build/dir/image.elf</div></div><!-- fragment --><p>To start debugging, you have to connect to <code>QEMU</code> from <code>GDB</code> with command: </p><div class="fragment"><div class="line">(gdb) target remote :1234</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>: <code>QEMU</code> does not support the emulation of hardware interrupts or special hardware modules like the WiFi module. Applications that rely on interrupts or the WiFi interface can only be debugged with restrictions with <code>QEMU</code> and <code>GDB</code>.</dd></dl>
<h2><a class="anchor" id="esp8266_esp_gdbstub"></a> Module <code>esp_gdbstub</code>  &#160;[<a href="#esp8266_toc">TOC</a>]</h2>
<h3>Compilation with <code>esp_gdbstub</code></h3>
<p>Using the <code>esp_gdbstub</code> module enables the compilation of the <code>gdbstub</code> interface for ESP8266. This interface implements the target side of the <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html#Remote-Protocol">GDB Remote Protocol</a>. The initial <code>gdbstub</code> implementation for ESP8266 was provided by <a href="https://github.com/espressif/esp-gdbstub">Espressif</a>. However, for using it with RIOT it had to be changed a lot.</p>
<dl class="section note"><dt>Note</dt><dd>Enabling the <code>gdbstub</code> interface automatically enables the compilation with debug information (module <code>esp_gdb</code>) <code>gdbstub</code>.</dd></dl>
<h3>Start Debugging with <code>esp_gdbstub</code></h3>
<p>To start debugging, the application has to be compiled using module <code>esp_gdbstub</code>, for example:</p>
<div class="fragment"><div class="line">USEMODULE=esp_gdbstub make flash BOARD=esp8266-esp-12x -C tests/shell</div></div><!-- fragment --><p>Once, the application is flashed to ESP82666, debugging can be started as following.</p>
<ol type="1">
<li>Start in first terminal window a terminal program which connects to the port of the ESP8266 module as console window: <div class="fragment"><div class="line">term1&gt; python -m serial.tools.miniterm &amp;lt;port&amp;gt; 115200</div></div><!-- fragment --> where <code>&lt;port&gt;</code> is the serial interface to which the ESP8266 module is connected, e.g., <code>/dev/ttyUSB0</code>.</li>
<li>Start GDB with the application in a second terminal window: <div class="fragment"><div class="line">term2&gt; xtensa-esp8266-elf-gdb /path/to/the/build/dir/image.elf</div></div><!-- fragment --> where <code>/path/to/build/dir</code> is the path to the application build directory <code></code> where <code>$ELFFILE.bin</code> is generated by the <code>make</code> command, for example <code>/tests/shell/bin/esp8266-esp-12x</code>.</li>
<li>Connect from <code>GDB</code> to the ESP8266 module with command: <div class="fragment"><div class="line">(gdb) target remote &amp;lt;port&amp;gt;</div></div><!-- fragment --> where <code>&lt;port&gt;</code> is the serial interface to which the ESP8266 module is connected, e.g., <code>/dev/ttyUSB0</code>.</li>
</ol>
<p>By default, <code>gdbstub</code> stops the execution automatically using function <code>gdbstub_do_break</code> after the board initialization and before the kernel is initialized.</p>
<div class="fragment"><div class="line">(gdb) tar rem /dev/ttyUSB0</div><div class="line">Remote debugging <span class="keyword">using</span> /dev/ttyUSB0</div><div class="line">gdbstub_do_break_breakpoint_addr () at cpu/esp8266/vendor/esp-gdbstub/gdbstub-entry.S:400</div><div class="line">400     <span class="keywordflow">break</span> 0,0</div><div class="line">(gdb) bt</div><div class="line">#0  gdbstub_do_break_breakpoint_addr () at cpu/esp8266/vendor/esp-gdbstub/gdbstub-entry.S:400</div><div class="line"><span class="preprocessor">#1  0x40100f89 in gdbstub_init () at cpu/esp8266/vendor/esp-gdbstub/gdbstub.c:985</span></div></div><!-- fragment --><p> At this time, you can set breakpoints, execute the application stepwise or just continue the execution using the <code>continue</code> command. Please note the limitations below. Once you have started the execution in <code>GDB</code>, you can use <code>Ctrl-C</code> in <code>GDB</code> or the console window to break it anytime.</p>
<p>If your application uses console inputs (stdio), such as the <code>tests/shell</code> application, you can type characters in the console window that gdbstub will forward to the application. However, the echo of these inputs occur in <code>GDB</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Since the terminal program and <code>GDB</code> are using the same serial port, typed characters can be lost sporadically.</dd></dl>
<p>When you reset the ESP8266 module, you will observe a message such as the following after boot messages in the console window. </p><div class="fragment"><div class="line">$T05#b9</div></div><!-- fragment --><p> This is simply the first GDB Remote Protocol packet that is generated as a result of the automatic break during the initialization when the GDB is not yet connected to the ESP8266 module.</p>
<h3>Limitations of <code>esp_gdbstub</code></h3>
<p>Due to hardware limitations of the Xtensa architecture, <code>esp_gdbstub</code> debugging has the following limitations:</p>
<ul>
<li>Software breakpoints (command <code>br</code>) only work for code in IRAM with addresses <code>0x4010xxxx</code>, see below.</li>
<li>Code in IROM (flash) with addresses <code>0x402xxxxx</code> require a hardware breakpoint (command <code>hbr</code>), see below.</li>
<li>There is only one hardware breakpoint (command <code>hbr</code>).</li>
<li>There is only one hardware watchpoint (command <code>watch</code>).</li>
<li>Stepwise execution on source code level is only possible in IRAM with addresses <code>0x4010xxxx</code>, see below.</li>
</ul>
<p>If you want to use multiple software breakpoints or execute stepwise on source code level, you have to ensure that the function you want to debug is located in RAM. For that purpose, add the <code>IRAM</code> attribute to that function, for example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;esp/common_macros.h&quot;</span></div><div class="line">...</div><div class="line">void IRAM my_func(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>Then you should be able to set a breakpoint to this function using command <code>bp</code> and to execute it stepwise after break.</p>
<p>Another option is to use <code>gdbstub_do_break()</code> wherever you want to break the execution. If you know where you want to break before downloading the program to the target, you can use <code>gdbstub_do_break()</code> as much as you want. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__cpu__esp__common__esp__now"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp__common__esp__now.html">ESP-NOW netdev interface</a></td></tr>
<tr class="memdesc:group__cpu__esp__common__esp__now"><td class="mdescLeft">&#160;</td><td class="mdescRight">WiFi based ESP-NOW network device driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp__common__esp__wifi"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp__common__esp__wifi.html">ESP-WiFi netdev interface</a></td></tr>
<tr class="memdesc:group__cpu__esp__common__esp__wifi"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network device driver for the ESP SoC WiFi interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp8266__sdk"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp8266__sdk.html">ESP8266 SDK interface</a></td></tr>
<tr class="memdesc:group__cpu__esp8266__sdk"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function declarations and mappings for compatibility with ESP8266 SDK. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp8266__conf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp8266__conf.html">ESP8266 compile configurations</a></td></tr>
<tr class="memdesc:group__cpu__esp8266__conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time configuration macros for ESP8266 modules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:esp8266_2include_2gpio__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2gpio__arch_8h.html">gpio_arch.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2gpio__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture specific GPIO functions for ESP8266. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2irq__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2irq__arch_8h.html">irq_arch.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2irq__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the kernels irq interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2periph__cpu_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2periph__cpu_8h.html">periph_cpu.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2periph__cpu_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU specific definitions and functions for peripheral handling. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2sdk__conf_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2sdk__conf_8h.html">sdk_conf.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2sdk__conf_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDK configuration compatible to the ESP-IDF. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp8266_2include_2syscalls_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp8266_2include_2syscalls_8h.html">syscalls.h</a></td></tr>
<tr class="memdesc:esp8266_2include_2syscalls_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of required system calls. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Jul 2 2020 15:49:28 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
