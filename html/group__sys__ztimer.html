<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>ztimer high level timer abstraction layer</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        displaySR();
                    }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__sys__ztimer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ztimer high level timer abstraction layer<div class="ingroups"><a class="el" href="group__sys.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>High level timer abstraction layer.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>High level timer abstraction layer. </p>
<h1>Introduction</h1>
<p>ztimer provides a high level abstraction of hardware timers for application timing needs.</p>
<p>The basic functions of the ztimer module are <a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8" title="Get the current time from a clock. ">ztimer_now()</a>, <a class="el" href="group__sys__ztimer.html#gade98636e198f2d571c8acd861d29d360" title="Put the calling thread to sleep for the specified number of ticks. ">ztimer_sleep()</a>, <a class="el" href="group__sys__ztimer.html#gaa2b547ebf6f464b317c07e53f6a5933a" title="Set a timer on a clock. ">ztimer_set()</a> and <a class="el" href="group__sys__ztimer.html#gaa1a5c0e4f8ffd3b87ae189420f4c3cad" title="Remove a timer from a clock. ">ztimer_remove()</a>.</p>
<p>They all take a pointer to a clock device (or virtual timer device) as first parameter.</p>
<p>RIOT provides ZTIMER_USEC, ZTIMER_MSEC, ZTIMER_SEC by default, which can be used in an application by depending on the modules ztimer_usec, ztimer_msec or ztimer_sec. They will then automatically get configured.</p>
<p>Every ztimer clock allows multiple timeouts to be scheduled. They all provide unsigned 32bit range. In this documentation, a timeout or its corresponding struct will be called <code>timer</code>, and when the time out has passed, it has <code>triggered</code>.</p>
<p>As ztimer can use arbitrarily configurable backends, a ztimer clock instance can run at configurable frequencies. Throughout this documentation, one clock step is called <code>tick</code>. For the pre-defined clocks ZTIMER_USEC, ZTIMER_MSEC and ZTIMER_SEC, one clock tick corresponds to one microsecond, one millisecond or one second, respectively.</p>
<p><a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8" title="Get the current time from a clock. ">ztimer_now()</a> returns the current clock tick count as uint32_t.</p>
<p><a class="el" href="group__sys__ztimer.html#gade98636e198f2d571c8acd861d29d360" title="Put the calling thread to sleep for the specified number of ticks. ">ztimer_sleep()</a> pauses the current thread for the passed amount of clock ticks. E.g., <code>ztimer_sleep(ZTIMER_SEC, 5);</code> will suspend the currently running thread for five seconds.</p>
<p><a class="el" href="group__sys__ztimer.html#gaa2b547ebf6f464b317c07e53f6a5933a" title="Set a timer on a clock. ">ztimer_set()</a> takes a <a class="el" href="structztimer__t.html" title="ztimer structure ">ztimer_t</a> object (containing a function pointer and void * argument) and an interval as arguments. After at least the interval (in number of ticks for the corresponding clock) has passed, the callback will be called in interrupt context. A timer can be cancelled using <a class="el" href="group__sys__ztimer.html#gaa1a5c0e4f8ffd3b87ae189420f4c3cad" title="Remove a timer from a clock. ">ztimer_remove()</a>.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ztimer_8h.html">ztimer.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> callback(<span class="keywordtype">void</span> *arg)</div><div class="line">{</div><div class="line">   puts(arg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="structztimer__t.html">ztimer_t</a> timeout = { .callback=callback, .arg=<span class="stringliteral">&quot;Hello ztimer!&quot;</span> };</div><div class="line">    <a class="code" href="group__sys__ztimer.html#gaa2b547ebf6f464b317c07e53f6a5933a">ztimer_set</a>(ZTIMER_SEC, &amp;timeout, 2);</div><div class="line"></div><div class="line">    <a class="code" href="group__sys__ztimer.html#gade98636e198f2d571c8acd861d29d360">ztimer_sleep</a>(ZTIMER_SEC, 5);</div><div class="line">}</div></div><!-- fragment --><h1>Design</h1>
<h2>clocks, virtual timers, chaining</h2>
<p>The system is composed of clocks (virtual ztimer devices) which can be chained to create an abstract view of a hardware timer/counter device. Each ztimer clock acts as a operation on the next clock in the chain. At the end of each ztimer chain there is always some kind of counter device object.</p>
<p>Each clock device handles multiplexing (allowing multiple timers to be set) and extension to full 32bit.</p>
<p>Hardware interface submodules:</p>
<ul>
<li><a class="el" href="group__sys__ztimer__periph__rtt.html#ga8a621eeefd4bb3ca67c914c1dd12a997">ztimer_periph_rtt</a> interface for periph_rtt</li>
<li><a class="el" href="group__sys__ztimer__periph__rtc.html#ga2614a7e5cd1c5e9f792d6c4b675fa01e">ztimer_periph_rtc</a> interface for periph_rtc</li>
<li><a class="el" href="group__sys__ztimer__periph__timer.html#ga886f48d4bc367087681d31e1c24499da">ztimer_periph_timer</a> interface for periph_timer</li>
</ul>
<p>Filter submodules:</p>
<ul>
<li><a class="el" href="group__sys__ztimer__convert__frac.html#gae5236d7f947ab29a467a91c60600acd6">ztimer_convert_frac</a> for fast frequency conversion using the frac library</li>
<li><a class="el" href="group__sys__ztimer__convert__muldiv64.html#ga436d01676d7383cccb86df744068db1c">ztimer_convert_muldiv64</a> for accurate but slow frequency conversion using 64bit division</li>
</ul>
<p>A common chain could be:</p>
<ol type="1">
<li>ztimer_periph_timer (e.g., on top of an 1024Hz 16bit hardware timer)</li>
<li>ztimer_convert_frac (to convert 1024 to 1000Hz)</li>
</ol>
<p>This is how e.g., the clock ZTIMER_MSEC might be configured on a specific system.</p>
<p>Every clock in the chain can always be used on its own. E.g. in the example above, the ztimer_periph object can be used as ztimer clock with 1024Hz ticks in addition to the ztimer_convert_frac with 1000Hz.</p>
<h2>Timer handling</h2>
<p>Timers in ztimer are stored in a clock using a linked list for which each entry stores the difference to the previous entry in the timer (T[n]). The clock also stores the absolute time on which the relative offsets are based (B), effectively storing the absolute target time for each entry (as B + sum(T[0-n])). Storing the entries in this way allows all entries to use the full width of the used uint32_t, compared to storing the absolute time.</p>
<p>In order to prevent timer processing offset to add up, whenever a timer triggers, the list's absolute base time is set to the <em>expected</em> trigger time (B + T[0]). The underlying clock is then set to alarm at (<a class="el" href="chrono_8hpp.html#a9b88c54f8020b254c8791325c525634e" title="Returns the current time saved in a time point. ">now()</a> + (<a class="el" href="chrono_8hpp.html#a9b88c54f8020b254c8791325c525634e" title="Returns the current time saved in a time point. ">now()</a> - B) + T[1]). Thus even though the list is keeping relative offsets, the time keeping is done by keeping track of the absolute times.</p>
<h2>Clock extension</h2>
<p>The API always allows setting full 32bit relative offsets for every clock.</p>
<p>In some cases (e.g., a hardware timer only allowing getting/setting smaller values or a conversion which would overflow uint32_t for large intervals), ztimer takes care of extending timers. This is enabled automatically for every ztimer clock that has a "max_value" setting smaller than 2**32-1. If a <a class="el" href="group__sys__ztimer.html#gaa2b547ebf6f464b317c07e53f6a5933a" title="Set a timer on a clock. ">ztimer_set()</a> would overflow that value, intermediate intervals of length (max_value / 2) are set until the remaining interval fits into max_value. If extension is enabled for a clock, <a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8" title="Get the current time from a clock. ">ztimer_now()</a> uses interval checkpointing, storing the current time and corresponding clock tick value on each call and using that information to calculate the current time. This ensures correct <a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8" title="Get the current time from a clock. ">ztimer_now()</a> values if <a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8" title="Get the current time from a clock. ">ztimer_now()</a> is called at least once every "max_value" ticks. This is ensured by scheduling intermediate callbacks every (max_value / 2) ticks (even if no timeout is configured).</p>
<h2>Reliability</h2>
<p>Care has been taken to avoid any unexpected behaviour of ztimer. In particular, ztimer tries hard to avoid underflows (setting a backend timer to a value at or behind the current time, causing the timer interrupt to trigger one whole timer period too late). This is done by always setting relative timeouts to backend timers, with interrupts disabled and ensuring that very small values don't cause underflows.</p>
<h2>Configuration and convention</h2>
<p>As timer hardware and capabilities is diverse and ztimer allows configuring and using arbitrary clock backends and conversions, it is envisioned to provide default configurations that application developers can assume to be available.</p>
<p>These are implemented by using pointers to ztimer clocks using default names.</p>
<p>For now, there are:</p>
<p>ZTIMER_USEC: clock providing microsecond ticks</p>
<p>ZTIMER_MSEC: clock providing millisecond ticks, using a low power timer if available on the platform</p>
<p>ZTIMER_SEC: clock providing second time, possibly using epoch semantics</p>
<p>These pointers are defined in <code><a class="el" href="ztimer_8h.html" title="ztimer API ">ztimer.h</a></code> and can be used like this: </p><pre class="fragment">ztimer_now(ZTIMER_USEC);
</pre><p>They also need to be added to USEMODULE using the names <code>ztimer_usec</code>, <code>ztimer_msec</code> and <code>ztimer_sec</code>.</p>
<h2>Some notes on ztimer's accuracy</h2>
<ol type="1">
<li>ztimer <em>should</em> wait "at least" the specified timeout</li>
<li>due to its implementation details, expect +-1 clock tick systemic inaccuracy for all clocks.</li>
<li>for the predefined clocks (ZTIMER_USEC, ZTIMER_MSEC, ZTIMER_SEC), tick conversion might be applied using ztimer_convert_*, causing errors due to integer conversion and rounding. In particular, most RTT's closest match for milliseconds are 1024Hz, which will be converted using convert_frac to provide the 1ms clock.</li>
<li>Some platforms don't have any timer that can be configured to 1us. E.g., the fe310 (hifive1/b) only supports a 32kHz timer, and most atmegas only support 250kHz. In order to not completely break all applications using ZTIMER_USEC, that clock will only provide ~30.5ms respectively 4us maximum accuracy on those boards. With DEVELHELP=1, a warning will be printed at boot time.</li>
<li>Due to +-1 systemic inaccuracies, it is advisable to use ZTIMER_MSEC for second timers up to 49 days (instead of ZTIMER_SEC). </li>
</ol>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__sys__ztimer__convert"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer__convert.html">ztimer frequency conversion modules</a></td></tr>
<tr class="memdesc:group__sys__ztimer__convert"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer frequency conversion modules <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__ztimer__mock"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer__mock.html">ztimer mock clock backend</a></td></tr>
<tr class="memdesc:group__sys__ztimer__mock"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer mock clock backend <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__ztimer__overhead"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer__overhead.html">ztimer overhead utility</a></td></tr>
<tr class="memdesc:group__sys__ztimer__overhead"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer overhead measurement functionality <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__ztimer__periph__rtc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer__periph__rtc.html">ztimer periph/rtc backend</a></td></tr>
<tr class="memdesc:group__sys__ztimer__periph__rtc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer periph/rtc backend <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__ztimer__periph__rtt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer__periph__rtt.html">ztimer periph/rtt backend</a></td></tr>
<tr class="memdesc:group__sys__ztimer__periph__rtt"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer periph/rtt backend <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__ztimer__periph__timer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer__periph__timer.html">ztimer periph/timer backend</a></td></tr>
<tr class="memdesc:group__sys__ztimer__periph__timer"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer periph/timer backend <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sys_2include_2ztimer_2config_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_2include_2ztimer_2config_8h.html">config.h</a></td></tr>
<tr class="memdesc:sys_2include_2ztimer_2config_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer default configuration <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ztimer_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ztimer_8h.html">ztimer.h</a></td></tr>
<tr class="memdesc:ztimer_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer API <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structztimer__base.html">ztimer_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum information for each timer.  <a href="structztimer__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structztimer__t.html">ztimer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer structure  <a href="structztimer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structztimer__ops__t.html">ztimer_ops_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer backend method structure  <a href="structztimer__ops__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structztimer__clock.html">ztimer_clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer device structure  <a href="structztimer__clock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga31826ee80148499098015ed01ce503d6"><td class="memItemLeft" align="right" valign="top"><a id="ga31826ee80148499098015ed01ce503d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga31826ee80148499098015ed01ce503d6">ZTIMER_CLOCK_NO_REQUIRED_PM_MODE</a>&#160;&#160;&#160;(UINT8_MAX)</td></tr>
<tr class="memdesc:ga31826ee80148499098015ed01ce503d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables interaction with pm_layered for a clock. <br /></td></tr>
<tr class="separator:ga31826ee80148499098015ed01ce503d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85289624f0c958bc0174f61bd728b582"><td class="memItemLeft" align="right" valign="top"><a id="ga85289624f0c958bc0174f61bd728b582"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga85289624f0c958bc0174f61bd728b582">MSG_ZTIMER</a>&#160;&#160;&#160;0xc83e</td></tr>
<tr class="memdesc:ga85289624f0c958bc0174f61bd728b582"><td class="mdescLeft">&#160;</td><td class="mdescRight">msg type used by ztimer_msg_receive_timeout <br /></td></tr>
<tr class="separator:ga85289624f0c958bc0174f61bd728b582"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0f3984c505b85ddf76049771c0bd6222"><td class="memItemLeft" align="right" valign="top"><a id="ga0f3984c505b85ddf76049771c0bd6222"></a>
typedef struct <a class="el" href="structztimer__base.html">ztimer_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga0f3984c505b85ddf76049771c0bd6222">ztimer_base_t</a></td></tr>
<tr class="memdesc:ga0f3984c505b85ddf76049771c0bd6222"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer_base_t forward declaration <br /></td></tr>
<tr class="separator:ga0f3984c505b85ddf76049771c0bd6222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3639ce794c3bd80a6e9bbe88a7db4a88"><td class="memItemLeft" align="right" valign="top"><a id="ga3639ce794c3bd80a6e9bbe88a7db4a88"></a>
typedef struct <a class="el" href="structztimer__clock.html">ztimer_clock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a></td></tr>
<tr class="memdesc:ga3639ce794c3bd80a6e9bbe88a7db4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">ztimer_clock_t forward declaration <br /></td></tr>
<tr class="separator:ga3639ce794c3bd80a6e9bbe88a7db4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10130a9b13fd88ea06a2889e63342f6"><td class="memItemLeft" align="right" valign="top"><a id="gab10130a9b13fd88ea06a2889e63342f6"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gab10130a9b13fd88ea06a2889e63342f6">ztimer_now_t</a></td></tr>
<tr class="memdesc:gab10130a9b13fd88ea06a2889e63342f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for <a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8" title="Get the current time from a clock. ">ztimer_now()</a> result <br /></td></tr>
<tr class="separator:gab10130a9b13fd88ea06a2889e63342f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae2432e9f2e227fce4a4730afdbe59cb6"><td class="memItemLeft" align="right" valign="top"><a id="gae2432e9f2e227fce4a4730afdbe59cb6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gae2432e9f2e227fce4a4730afdbe59cb6">ztimer_handler</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock)</td></tr>
<tr class="memdesc:gae2432e9f2e227fce4a4730afdbe59cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">main ztimer callback handler <br /></td></tr>
<tr class="separator:gae2432e9f2e227fce4a4730afdbe59cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b547ebf6f464b317c07e53f6a5933a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gaa2b547ebf6f464b317c07e53f6a5933a">ztimer_set</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, <a class="el" href="structztimer__t.html">ztimer_t</a> *timer, uint32_t val)</td></tr>
<tr class="memdesc:gaa2b547ebf6f464b317c07e53f6a5933a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timer on a clock.  <a href="#gaa2b547ebf6f464b317c07e53f6a5933a">More...</a><br /></td></tr>
<tr class="separator:gaa2b547ebf6f464b317c07e53f6a5933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a5c0e4f8ffd3b87ae189420f4c3cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gaa1a5c0e4f8ffd3b87ae189420f4c3cad">ztimer_remove</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, <a class="el" href="structztimer__t.html">ztimer_t</a> *timer)</td></tr>
<tr class="memdesc:gaa1a5c0e4f8ffd3b87ae189420f4c3cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a timer from a clock.  <a href="#gaa1a5c0e4f8ffd3b87ae189420f4c3cad">More...</a><br /></td></tr>
<tr class="separator:gaa1a5c0e4f8ffd3b87ae189420f4c3cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595ba6d03ea9052dd3e67d55b0b0dcf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga595ba6d03ea9052dd3e67d55b0b0dcf7">ztimer_set_msg</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, <a class="el" href="structztimer__t.html">ztimer_t</a> *timer, uint32_t offset, <a class="el" href="structmsg__t.html">msg_t</a> *msg, <a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> target_pid)</td></tr>
<tr class="memdesc:ga595ba6d03ea9052dd3e67d55b0b0dcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a message after a delay.  <a href="#ga595ba6d03ea9052dd3e67d55b0b0dcf7">More...</a><br /></td></tr>
<tr class="separator:ga595ba6d03ea9052dd3e67d55b0b0dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe88b7f7076d2b48bb17912b78bdc336"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gabe88b7f7076d2b48bb17912b78bdc336">ztimer_msg_receive_timeout</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, <a class="el" href="structmsg__t.html">msg_t</a> *msg, uint32_t timeout)</td></tr>
<tr class="memdesc:gabe88b7f7076d2b48bb17912b78bdc336"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive a message (blocking, with timeout)  <a href="#gabe88b7f7076d2b48bb17912b78bdc336">More...</a><br /></td></tr>
<tr class="separator:gabe88b7f7076d2b48bb17912b78bdc336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2f7c7499bb59b188ad910063ee881fe"><td class="memItemLeft" align="right" valign="top"><a id="gae2f7c7499bb59b188ad910063ee881fe"></a>
<a class="el" href="group__sys__ztimer.html#gab10130a9b13fd88ea06a2889e63342f6">ztimer_now_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gae2f7c7499bb59b188ad910063ee881fe">_ztimer_now_extend</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock)</td></tr>
<tr class="memdesc:gae2f7c7499bb59b188ad910063ee881fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8" title="Get the current time from a clock. ">ztimer_now()</a> for extending timers <br /></td></tr>
<tr class="separator:gae2f7c7499bb59b188ad910063ee881fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd8174ea28626e102b40143075ed9c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__sys__ztimer.html#gab10130a9b13fd88ea06a2889e63342f6">ztimer_now_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gabcd8174ea28626e102b40143075ed9c8">ztimer_now</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock)</td></tr>
<tr class="memdesc:gabcd8174ea28626e102b40143075ed9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current time from a clock.  <a href="#gabcd8174ea28626e102b40143075ed9c8">More...</a><br /></td></tr>
<tr class="separator:gabcd8174ea28626e102b40143075ed9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40107ed3e27898606f8bfc69d01fb39e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga40107ed3e27898606f8bfc69d01fb39e">ztimer_periodic_wakeup</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, uint32_t *last_wakeup, uint32_t period)</td></tr>
<tr class="memdesc:ga40107ed3e27898606f8bfc69d01fb39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the calling thread until the time (<code>last_wakeup</code> + <code>period</code>)  <a href="#ga40107ed3e27898606f8bfc69d01fb39e">More...</a><br /></td></tr>
<tr class="separator:ga40107ed3e27898606f8bfc69d01fb39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade98636e198f2d571c8acd861d29d360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gade98636e198f2d571c8acd861d29d360">ztimer_sleep</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, uint32_t duration)</td></tr>
<tr class="memdesc:gade98636e198f2d571c8acd861d29d360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the calling thread to sleep for the specified number of ticks.  <a href="#gade98636e198f2d571c8acd861d29d360">More...</a><br /></td></tr>
<tr class="separator:gade98636e198f2d571c8acd861d29d360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b1929e8ff4a920020e3111bbd8050e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga50b1929e8ff4a920020e3111bbd8050e">ztimer_set_wakeup</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, <a class="el" href="structztimer__t.html">ztimer_t</a> *timer, uint32_t offset, <a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga50b1929e8ff4a920020e3111bbd8050e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timer that wakes up a thread.  <a href="#ga50b1929e8ff4a920020e3111bbd8050e">More...</a><br /></td></tr>
<tr class="separator:ga50b1929e8ff4a920020e3111bbd8050e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b87b65d13b41cdaacde7385afd4a60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gaf3b87b65d13b41cdaacde7385afd4a60">ztimer_set_timeout_flag</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, <a class="el" href="structztimer__t.html">ztimer_t</a> *timer, uint32_t timeout)</td></tr>
<tr class="memdesc:gaf3b87b65d13b41cdaacde7385afd4a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout thread flag after <code>timeout</code>.  <a href="#gaf3b87b65d13b41cdaacde7385afd4a60">More...</a><br /></td></tr>
<tr class="separator:gaf3b87b65d13b41cdaacde7385afd4a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0d5d3e93aae8f37e46b357a52c74fa"><td class="memItemLeft" align="right" valign="top"><a id="ga1a0d5d3e93aae8f37e46b357a52c74fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga1a0d5d3e93aae8f37e46b357a52c74fa">ztimer_update_head_offset</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock)</td></tr>
<tr class="memdesc:ga1a0d5d3e93aae8f37e46b357a52c74fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ztimer clock head list offset. <br /></td></tr>
<tr class="separator:ga1a0d5d3e93aae8f37e46b357a52c74fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0774ba6e5613bad33dc855c0f73565cc"><td class="memItemLeft" align="right" valign="top"><a id="ga0774ba6e5613bad33dc855c0f73565cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga0774ba6e5613bad33dc855c0f73565cc">ztimer_init</a> (void)</td></tr>
<tr class="memdesc:ga0774ba6e5613bad33dc855c0f73565cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the board-specific default ztimer configuration. <br /></td></tr>
<tr class="separator:ga0774ba6e5613bad33dc855c0f73565cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd4826cb78f398402a587718254b141"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gacdd4826cb78f398402a587718254b141">ztimer_init_extend</a> (<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock)</td></tr>
<tr class="memdesc:gacdd4826cb78f398402a587718254b141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize possible ztimer extension intermediate timer.  <a href="#gacdd4826cb78f398402a587718254b141">More...</a><br /></td></tr>
<tr class="separator:gacdd4826cb78f398402a587718254b141"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga9da8117fed13070316af0e816403a986"><td class="memItemLeft" align="right" valign="top"><a id="ga9da8117fed13070316af0e816403a986"></a>
<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga9da8117fed13070316af0e816403a986">ZTIMER_USEC</a></td></tr>
<tr class="memdesc:ga9da8117fed13070316af0e816403a986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ztimer microsecond clock. <br /></td></tr>
<tr class="separator:ga9da8117fed13070316af0e816403a986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89aa36047e5e6859e5b08c9bacd1c3e"><td class="memItemLeft" align="right" valign="top"><a id="gaf89aa36047e5e6859e5b08c9bacd1c3e"></a>
<a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gaf89aa36047e5e6859e5b08c9bacd1c3e">ZTIMER_MSEC</a></td></tr>
<tr class="memdesc:gaf89aa36047e5e6859e5b08c9bacd1c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ztimer millisecond clock. <br /></td></tr>
<tr class="separator:gaf89aa36047e5e6859e5b08c9bacd1c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93f084aed0c7c9ebcaedf5ed0e9971d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#gae93f084aed0c7c9ebcaedf5ed0e9971d">ZTIMER_USEC_BASE</a></td></tr>
<tr class="memdesc:gae93f084aed0c7c9ebcaedf5ed0e9971d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base ztimer for the microsecond clock (ZTIMER_USEC)  <a href="#gae93f084aed0c7c9ebcaedf5ed0e9971d">More...</a><br /></td></tr>
<tr class="separator:gae93f084aed0c7c9ebcaedf5ed0e9971d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5adbd6f8c80cee6a72e346e176e8ead7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__ztimer.html#ga5adbd6f8c80cee6a72e346e176e8ead7">ZTIMER_MSEC_BASE</a></td></tr>
<tr class="memdesc:ga5adbd6f8c80cee6a72e346e176e8ead7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base ztimer for the millisecond clock (ZTIMER_MSEC)  <a href="#ga5adbd6f8c80cee6a72e346e176e8ead7">More...</a><br /></td></tr>
<tr class="separator:ga5adbd6f8c80cee6a72e346e176e8ead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacdd4826cb78f398402a587718254b141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdd4826cb78f398402a587718254b141">&#9670;&nbsp;</a></span>ztimer_init_extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ztimer_init_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize possible ztimer extension intermediate timer. </p>
<p>This will basically just set a timer to (clock-&gt;max_value &gt;&gt; 1), <em>if</em> max_value is not UINT32_MAX.</p>
<p>This is called automatically by all ztimer backends and extension modules. </p>

<p class="definition">Definition at line <a class="el" href="ztimer_8h_source.html#l00498">498</a> of file <a class="el" href="ztimer_8h_source.html">ztimer.h</a>.</p>

</div>
</div>
<a id="gabe88b7f7076d2b48bb17912b78bdc336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe88b7f7076d2b48bb17912b78bdc336">&#9670;&nbsp;</a></span>ztimer_msg_receive_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ztimer_msg_receive_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>receive a message (blocking, with timeout) </p>
<p>Similar to <a class="el" href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a" title="Receive a message. ">msg_receive()</a>, but with a timeout parameter. The function will return after waiting at most <code>timeout</code> ticks.</p>
<dl class="section note"><dt>Note</dt><dd>: This might function might leave a message with type MSG_ZTIMER in the thread's message queue, which must be handled (ignored).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>pointer to buffer which will be filled if a message is received </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>relative timeout, in <code>clock</code> time units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 if a message was received </dd>
<dd>
-ETIME on timeout </dd></dl>

</div>
</div>
<a id="gabcd8174ea28626e102b40143075ed9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd8174ea28626e102b40143075ed9c8">&#9670;&nbsp;</a></span>ztimer_now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__sys__ztimer.html#gab10130a9b13fd88ea06a2889e63342f6">ztimer_now_t</a> ztimer_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current time from a clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current count on <code>clock</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ztimer_8h_source.html#l00402">402</a> of file <a class="el" href="ztimer_8h_source.html">ztimer.h</a>.</p>

</div>
</div>
<a id="ga40107ed3e27898606f8bfc69d01fb39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40107ed3e27898606f8bfc69d01fb39e">&#9670;&nbsp;</a></span>ztimer_periodic_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztimer_periodic_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>last_wakeup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the calling thread until the time (<code>last_wakeup</code> + <code>period</code>) </p>
<p>This function can be used to create periodic wakeups.</p>
<p>When the function returns, <code>last_wakeup</code> is set to (<code>last_wakeup</code> + <code>period</code>).</p>
<p><code>last_wakeup</code> should be set to ztimer_now(<code>clock</code>) before first call of the function.</p>
<p>If the time (<code>last_wakeup</code> + <code>period</code>) has already passed, the function sets <code>last_wakeup</code> to <code>last_wakeup</code> + <code>period</code> and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_wakeup</td><td>base time stamp for the wakeup </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>time in ticks that will be added to <code>last_wakeup</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1a5c0e4f8ffd3b87ae189420f4c3cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a5c0e4f8ffd3b87ae189420f4c3cad">&#9670;&nbsp;</a></span>ztimer_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztimer_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structztimer__t.html">ztimer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a timer from a clock. </p>
<p>This will place <code>timer</code> in the timer targets queue for <code>clock</code>.</p>
<p>This function does nothing if <code>timer</code> is not found in the timer queue of <code>clock</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer entry to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2b547ebf6f464b317c07e53f6a5933a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b547ebf6f464b317c07e53f6a5933a">&#9670;&nbsp;</a></span>ztimer_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztimer_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structztimer__t.html">ztimer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a timer on a clock. </p>
<p>This will place <code>timer</code> in the timer targets queue of <code>clock</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The memory pointed to by <code>timer</code> is not copied and must remain in scope until the callback is fired or the timer is removed via <a class="el" href="group__sys__ztimer.html#gaa1a5c0e4f8ffd3b87ae189420f4c3cad">ztimer_remove</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer entry to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>timer target (relative ticks from now) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga595ba6d03ea9052dd3e67d55b0b0dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga595ba6d03ea9052dd3e67d55b0b0dcf7">&#9670;&nbsp;</a></span>ztimer_set_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztimer_set_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structztimer__t.html">ztimer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>target_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a message after a delay. </p>
<p>This function sets a timer that will send a message <code>offset</code> ticks from now.</p>
<dl class="section note"><dt>Note</dt><dd>The memory pointed to by <code>timer</code> and <code>msg</code> will not be copied, i.e. <code>*timer</code> and <code>*msg</code> needs to remain valid until the timer has triggered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>ztimer timer struct to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>ticks from now </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>pointer to msg that will be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_pid</td><td>pid the message will be sent to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3b87b65d13b41cdaacde7385afd4a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b87b65d13b41cdaacde7385afd4a60">&#9670;&nbsp;</a></span>ztimer_set_timeout_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztimer_set_timeout_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structztimer__t.html">ztimer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set timeout thread flag after <code>timeout</code>. </p>
<p>This function will set THREAD_FLAG_TIMEOUT on the current thread after <code>timeout</code> usec have passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer struct to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>timeout in <a class="el" href="structztimer__clock.html" title="ztimer device structure ">ztimer_clock</a>'s ticks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50b1929e8ff4a920020e3111bbd8050e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50b1929e8ff4a920020e3111bbd8050e">&#9670;&nbsp;</a></span>ztimer_set_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztimer_set_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structztimer__t.html">ztimer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a timer that wakes up a thread. </p>
<p>This function sets a timer that will wake up a thread when the timer has expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer struct to work with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>clock ticks from now </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>pid of the thread that will be woken up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade98636e198f2d571c8acd861d29d360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade98636e198f2d571c8acd861d29d360">&#9670;&nbsp;</a></span>ztimer_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztimer_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the calling thread to sleep for the specified number of ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>duration of sleep, in <code>ztimer</code> time units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5adbd6f8c80cee6a72e346e176e8ead7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5adbd6f8c80cee6a72e346e176e8ead7">&#9670;&nbsp;</a></span>ZTIMER_MSEC_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a>* const ZTIMER_MSEC_BASE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base ztimer for the millisecond clock (ZTIMER_MSEC) </p>
<p>This ztimer will reference the counter device object at the end of the chain of ztimer_clock_t for ZTIMER_MSEC.</p>
<p>If ztimer_periph_rtt is not used then ZTIMER_MSEC_BASE will reference the same base as ZTIMER_USEC_BASE.</p>
<p>If the base counter device object's frequency (CONFIG_ZTIMER_MSEC_BASE_FREQ) is not 1KHz then ZTIMER_MSEC will be converted on top of this one. Otherwise they will reference the same <a class="el" href="structztimer__clock.html" title="ztimer device structure ">ztimer_clock</a>.</p>
<p>To avoid chained conversions its better to base new <a class="el" href="structztimer__clock.html" title="ztimer device structure ">ztimer_clock</a> on top of ZTIMER_MSEC_BASE running at CONFIG_ZTIMER_MSEC_BASE_FREQ. </p>

</div>
</div>
<a id="gae93f084aed0c7c9ebcaedf5ed0e9971d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae93f084aed0c7c9ebcaedf5ed0e9971d">&#9670;&nbsp;</a></span>ZTIMER_USEC_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a>* const ZTIMER_USEC_BASE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base ztimer for the microsecond clock (ZTIMER_USEC) </p>
<p>This ztimer will reference the counter device object at the end of the chain of ztimer_clock_t for ZTIMER_USEC.</p>
<p>If the base counter device object's frequency (CONFIG_ZTIMER_USEC_BASE_FREQ) is not 1MHz then ZTIMER_USEC will be converted on top of this one. Otherwise they will reference the same <a class="el" href="structztimer__clock.html" title="ztimer device structure ">ztimer_clock</a>.</p>
<p>To avoid chained conversions its better to base new <a class="el" href="structztimer__clock.html" title="ztimer device structure ">ztimer_clock</a> on top of ZTIMER_USEC_BASE running at CONFIG_ZTIMER_USEC_BASE_FREQ. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Fri Jul 3 2020 23:49:40 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
