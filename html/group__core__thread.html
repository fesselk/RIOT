<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Threading</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <!--BEGIN SEARCHENGINE hidden-sm hidden-xs"-->
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        var rhtml=document.getElementById('MSearchResults').contentWindow.document.body.innerHTML;
                        document.getElementById('MSearchResultsWindow').style.display='none';
                        document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
                        document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
                        document.getElementById('doc-content').innerHTML=rhtml;
                        }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event);
                              var r=document.getElementById('MSearchResultsWindow');
                              if(parseInt(r.style.left)<0)r.style.left=0;
                              var x=document.getElementById('MSearchResults');
                              if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                              var f=document.getElementById('riot-searchform');
                              if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__core__thread.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Threading<div class="ingroups"><a class="el" href="group__core.html">Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Support for multi-threading.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Support for multi-threading. </p>
<h1>Priorities </h1>
<p>As RIOT is using a fixed priority <a class="el" href="group__core__sched.html">scheduling algorithm</a>, threads are scheduled based on their priority. The priority is fixed for every thread and specified during the thread's creation by the <code>priority</code> parameter.</p>
<p>The lower the priority value, the higher the priority of the thread, with 0 being the highest possible priority.</p>
<p>The lowest possible priority is <a class="el" href="group__core__thread.html#gaff75fcd47eeb1872daf68978351983fb">THREAD_PRIORITY_IDLE</a> - 1.</p>
<dl class="section note"><dt>Note</dt><dd>Assigning the same priority to two or more threads is usually not a good idea. A thread in RIOT may run until it yields (<a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699">thread_yield</a>) or another thread with higher priority is runnable (<a class="el" href="group__core__sched.html#gaf4e431441709328f9355dfb7e21a0eb9">STATUS_ON_RUNQUEUE</a>) again. Multiple threads with the same priority will therefore be scheduled cooperatively: when one of them is running, all others with the same priority depend on it to yield (or be interrupted by a thread with higher priority). This may make it difficult to determine when which of them gets scheduled and how much CPU time they will get. In most applications, the number of threads in application is significantly smaller than the number of available priorities, so assigning distinct priorities per thread should not be a problem. Only assign the same priority to multiple threads if you know what you are doing!</dd></dl>
<h1>Thread Behavior </h1>
<p>In addition to the priority, flags can be used when creating a thread to alter the thread's behavior after creation. The following flags are available:</p>
<table class="doxtable">
<tr>
<th>Flags </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="group__core__thread.html#ga31d767ff839598270044e04a53ffa7f4">THREAD_CREATE_SLEEPING</a> </td><td>the thread will sleep until woken up manually </td></tr>
<tr>
<td><a class="el" href="group__core__thread.html#ga55062dd3d2da4ee10c96a5ff39505ff4">THREAD_CREATE_WOUT_YIELD</a> </td><td>the thread might not run immediately after creation </td></tr>
<tr>
<td><a class="el" href="group__core__thread.html#ga51f8182fbb138fd27746e509b69d3aed">THREAD_CREATE_STACKTEST</a> </td><td>measures the stack's memory usage </td></tr>
</table>
<h1>Thread creation </h1>
<p>Creating a new thread is internally done in two steps:</p><ol type="1">
<li>the new thread's stack is initialized depending on the platform</li>
<li>the new thread is added to the scheduler and the scheduler is run (if not indicated otherwise)</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Creating threads from within an ISR is currently supported, however it is considered to be a bad programming practice and we strongly discourage you from doing so.</dd></dl>
<h2>Usage </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> rcv_thread_stack[<a class="code" href="group__core__thread.html#ga0dc9cf6e8b0b4da823649d78403fff90">THREAD_STACKSIZE_MAIN</a>];</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> *rcv_thread(<span class="keywordtype">void</span> *arg)</div><div class="line">{</div><div class="line">    (void) arg;</div><div class="line">    <a class="code" href="structmsg__t.html">msg_t</a> m;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        <a class="code" href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a">msg_receive</a>(&amp;m);</div><div class="line">        printf(<span class="stringliteral">&quot;Got msg from %&quot;</span> <a class="code" href="kernel__types_8h.html#acbdb91f768b6240701dcb6cfaf0216ac">PRIkernel_pid</a> <span class="stringliteral">&quot;\n&quot;</span>, m.<a class="code" href="structmsg__t.html#a6c7d65a0a86c7b69ed58f9f71a043028">sender_pid</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">thread_create</a>(rcv_thread_stack, <span class="keyword">sizeof</span>(rcv_thread_stack),</div><div class="line">                  <a class="code" href="group__core__thread.html#gac57374d1c51374ebf95d9679281af818">THREAD_PRIORITY_MAIN</a> - 1, <a class="code" href="group__core__thread.html#ga51f8182fbb138fd27746e509b69d3aed">THREAD_CREATE_STACKTEST</a>,</div><div class="line">                  rcv_thread, NULL, <span class="stringliteral">&quot;rcv_thread&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>Reading from the top down, you can see that first, stack memory for our thread <code>rcv_thread</code> is preallocated, followed by an implementation of the thread's function. Communication between threads is done using <a class="el" href="group__core__msg.html">Messaging / IPC</a>. In this case, <code>rcv_thread</code> will print the process id of each thread that sent a message to <code>rcv_thread</code>.</p>
<p>After it has been properly defined, <code>rcv_thread</code> is created with a call to <a class="el" href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">thread_create()</a> in <code>main()</code>. It is assigned a priority of <code>THREAD_PRIORITY_MAIN - 1</code>, i.e. a slightly <em>higher</em> priority than the main thread. Since neither the <code>THREAD_CREATE_SLEEPING</code> nor the <code>THREAD_CREATE_WOUT_YIELD</code> flag is set, <code>rcv_thread</code> will be executed immediately.</p>
<dl class="section note"><dt>Note</dt><dd>If the messages to the thread are sent using <a class="el" href="group__core__msg.html#ga99264bd4f263fa2b478308c1f7983c10">msg_try_send()</a> or from an ISR, activate your thread's message queue by calling <a class="el" href="group__core__msg.html#ga480e6f32c8ab18579b62a890f3fda2cd">msg_init_queue()</a> to prevent messages from being dropped when they can't be handled right away. The same applies if you'd like <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8" title="Send a message (blocking). ">msg_send()</a> to your thread to be non-blocking. For more details, see <a class="el" href="group__core__msg.html">the Messaging documentation</a>. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:core_2include_2thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_2include_2thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:core_2include_2thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threading API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__thread.html">_thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>thread_t</code> holds thread's context data.  <a href="struct__thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga713ebddc00581f4d415095cdbfd8791f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a></td></tr>
<tr class="memdesc:ga713ebddc00581f4d415095cdbfd8791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reasonable default stack size that will suffice most smaller tasks.  <a href="#ga713ebddc00581f4d415095cdbfd8791f">More...</a><br /></td></tr>
<tr class="separator:ga713ebddc00581f4d415095cdbfd8791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4f62f762a057d594ae0ee4522dd14c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gac4f62f762a057d594ae0ee4522dd14c2">THREAD_STACKSIZE_IDLE</a></td></tr>
<tr class="memdesc:gac4f62f762a057d594ae0ee4522dd14c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the idle task's stack in bytes.  <a href="#gac4f62f762a057d594ae0ee4522dd14c2">More...</a><br /></td></tr>
<tr class="separator:gac4f62f762a057d594ae0ee4522dd14c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30305c0f413c7da1e7445de2b5ea5a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaf30305c0f413c7da1e7445de2b5ea5a5">THREAD_EXTRA_STACKSIZE_PRINTF</a></td></tr>
<tr class="memdesc:gaf30305c0f413c7da1e7445de2b5ea5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the task's printf stack in bytes.  <a href="#gaf30305c0f413c7da1e7445de2b5ea5a5">More...</a><br /></td></tr>
<tr class="separator:gaf30305c0f413c7da1e7445de2b5ea5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc9cf6e8b0b4da823649d78403fff90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga0dc9cf6e8b0b4da823649d78403fff90">THREAD_STACKSIZE_MAIN</a></td></tr>
<tr class="memdesc:ga0dc9cf6e8b0b4da823649d78403fff90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the main task's stack in bytes.  <a href="#ga0dc9cf6e8b0b4da823649d78403fff90">More...</a><br /></td></tr>
<tr class="separator:ga0dc9cf6e8b0b4da823649d78403fff90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab9ad4e0af6c50af1ff9e1fb5ebfd1f"><td class="memItemLeft" align="right" valign="top"><a id="gafab9ad4e0af6c50af1ff9e1fb5ebfd1f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gafab9ad4e0af6c50af1ff9e1fb5ebfd1f">THREAD_STACKSIZE_LARGE</a>&#160;&#160;&#160;(<a class="el" href="group__core__thread.html#gaa471066daf0b0cb5982a87f0afdf754b">THREAD_STACKSIZE_MEDIUM</a> * 2)</td></tr>
<tr class="memdesc:gafab9ad4e0af6c50af1ff9e1fb5ebfd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Large stack size. <br /></td></tr>
<tr class="separator:gafab9ad4e0af6c50af1ff9e1fb5ebfd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa471066daf0b0cb5982a87f0afdf754b"><td class="memItemLeft" align="right" valign="top"><a id="gaa471066daf0b0cb5982a87f0afdf754b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaa471066daf0b0cb5982a87f0afdf754b">THREAD_STACKSIZE_MEDIUM</a>&#160;&#160;&#160;<a class="el" href="native_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a></td></tr>
<tr class="memdesc:gaa471066daf0b0cb5982a87f0afdf754b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Medium stack size. <br /></td></tr>
<tr class="separator:gaa471066daf0b0cb5982a87f0afdf754b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87fb14957addf8ea0f27ea7d18b27f5a"><td class="memItemLeft" align="right" valign="top"><a id="ga87fb14957addf8ea0f27ea7d18b27f5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga87fb14957addf8ea0f27ea7d18b27f5a">THREAD_STACKSIZE_SMALL</a>&#160;&#160;&#160;(<a class="el" href="group__core__thread.html#gaa471066daf0b0cb5982a87f0afdf754b">THREAD_STACKSIZE_MEDIUM</a> / 2)</td></tr>
<tr class="memdesc:ga87fb14957addf8ea0f27ea7d18b27f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small stack size. <br /></td></tr>
<tr class="separator:ga87fb14957addf8ea0f27ea7d18b27f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d454e716bc4417b11e69242603521c"><td class="memItemLeft" align="right" valign="top"><a id="gae0d454e716bc4417b11e69242603521c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gae0d454e716bc4417b11e69242603521c">THREAD_STACKSIZE_TINY</a>&#160;&#160;&#160;(<a class="el" href="group__core__thread.html#gaa471066daf0b0cb5982a87f0afdf754b">THREAD_STACKSIZE_MEDIUM</a> / 4)</td></tr>
<tr class="memdesc:gae0d454e716bc4417b11e69242603521c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiny stack size. <br /></td></tr>
<tr class="separator:gae0d454e716bc4417b11e69242603521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab771adde08a437e30fc39b67d6ca65ad"><td class="memItemLeft" align="right" valign="top"><a id="gab771adde08a437e30fc39b67d6ca65ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab771adde08a437e30fc39b67d6ca65ad">THREAD_STACKSIZE_MINIMUM</a>&#160;&#160;&#160;(sizeof(<a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a>))</td></tr>
<tr class="memdesc:gab771adde08a437e30fc39b67d6ca65ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum stack size. <br /></td></tr>
<tr class="separator:gab771adde08a437e30fc39b67d6ca65ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196e3293c94df476dd1dd0007013ad14"><td class="memItemLeft" align="right" valign="top"><a id="ga196e3293c94df476dd1dd0007013ad14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga196e3293c94df476dd1dd0007013ad14">THREAD_PRIORITY_MIN</a>&#160;&#160;&#160;(<a class="el" href="group__core__sched.html#ga1868da7c35ae4ff66fc899793d283dd6">SCHED_PRIO_LEVELS</a> - 1)</td></tr>
<tr class="memdesc:ga196e3293c94df476dd1dd0007013ad14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least priority a thread can have. <br /></td></tr>
<tr class="separator:ga196e3293c94df476dd1dd0007013ad14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff75fcd47eeb1872daf68978351983fb"><td class="memItemLeft" align="right" valign="top"><a id="gaff75fcd47eeb1872daf68978351983fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaff75fcd47eeb1872daf68978351983fb">THREAD_PRIORITY_IDLE</a>&#160;&#160;&#160;(<a class="el" href="group__core__thread.html#ga196e3293c94df476dd1dd0007013ad14">THREAD_PRIORITY_MIN</a>)</td></tr>
<tr class="memdesc:gaff75fcd47eeb1872daf68978351983fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority of the idle thread. <br /></td></tr>
<tr class="separator:gaff75fcd47eeb1872daf68978351983fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57374d1c51374ebf95d9679281af818"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gac57374d1c51374ebf95d9679281af818">THREAD_PRIORITY_MAIN</a></td></tr>
<tr class="memdesc:gac57374d1c51374ebf95d9679281af818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority of the main thread.  <a href="#gac57374d1c51374ebf95d9679281af818">More...</a><br /></td></tr>
<tr class="separator:gac57374d1c51374ebf95d9679281af818"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab1b7486500c7dbaabdd2ac9a085ac39a"><td class="memItemLeft" align="right" valign="top"><a id="gab1b7486500c7dbaabdd2ac9a085ac39a"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a>) (void *arg)</td></tr>
<tr class="memdesc:gab1b7486500c7dbaabdd2ac9a085ac39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for a thread entry function. <br /></td></tr>
<tr class="separator:gab1b7486500c7dbaabdd2ac9a085ac39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7e0403a9aa86ce0ec136f6b069d4434a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">thread_create</a> (char *stack, int stacksize, uint8_t priority, int flags, <a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a> task_func, void *arg, const char *name)</td></tr>
<tr class="memdesc:ga7e0403a9aa86ce0ec136f6b069d4434a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread.  <a href="#ga7e0403a9aa86ce0ec136f6b069d4434a">More...</a><br /></td></tr>
<tr class="separator:ga7e0403a9aa86ce0ec136f6b069d4434a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754515868f32530baa52ad2d05620205"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga754515868f32530baa52ad2d05620205">thread_get</a> (<a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga754515868f32530baa52ad2d05620205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a thread control block by PID.  <a href="#ga754515868f32530baa52ad2d05620205">More...</a><br /></td></tr>
<tr class="separator:ga754515868f32530baa52ad2d05620205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126920c73220c857489a340ee1a5072a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga126920c73220c857489a340ee1a5072a">thread_getstatus</a> (<a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga126920c73220c857489a340ee1a5072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of a process.  <a href="#ga126920c73220c857489a340ee1a5072a">More...</a><br /></td></tr>
<tr class="separator:ga126920c73220c857489a340ee1a5072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d16ab2564e99827b629f8cb1a253beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga8d16ab2564e99827b629f8cb1a253beb">thread_sleep</a> (void)</td></tr>
<tr class="memdesc:ga8d16ab2564e99827b629f8cb1a253beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the current thread into sleep mode.  <a href="#ga8d16ab2564e99827b629f8cb1a253beb">More...</a><br /></td></tr>
<tr class="separator:ga8d16ab2564e99827b629f8cb1a253beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9229e0f462f60bb9550919fa3d7699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699">thread_yield</a> (void)</td></tr>
<tr class="memdesc:gaaa9229e0f462f60bb9550919fa3d7699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets current thread yield.  <a href="#gaaa9229e0f462f60bb9550919fa3d7699">More...</a><br /></td></tr>
<tr class="separator:gaaa9229e0f462f60bb9550919fa3d7699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293ec7e262958787bc744f28d29588a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga293ec7e262958787bc744f28d29588a8">thread_yield_higher</a> (void)</td></tr>
<tr class="memdesc:ga293ec7e262958787bc744f28d29588a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets current thread yield in favor of a higher prioritized thread.  <a href="#ga293ec7e262958787bc744f28d29588a8">More...</a><br /></td></tr>
<tr class="separator:ga293ec7e262958787bc744f28d29588a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c8b55efc2c693fc6e2c6acd9ca2ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga76c8b55efc2c693fc6e2c6acd9ca2ddb">thread_zombify</a> (void)</td></tr>
<tr class="memdesc:ga76c8b55efc2c693fc6e2c6acd9ca2ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the current thread into zombie state.  <a href="#ga76c8b55efc2c693fc6e2c6acd9ca2ddb">More...</a><br /></td></tr>
<tr class="separator:ga76c8b55efc2c693fc6e2c6acd9ca2ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862dec3a65ad85c3b18bdf2d5450880e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga862dec3a65ad85c3b18bdf2d5450880e">thread_kill_zombie</a> (<a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga862dec3a65ad85c3b18bdf2d5450880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates zombie thread.  <a href="#ga862dec3a65ad85c3b18bdf2d5450880e">More...</a><br /></td></tr>
<tr class="separator:ga862dec3a65ad85c3b18bdf2d5450880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab65867d92604d57f6efb622586466f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaab65867d92604d57f6efb622586466f4">thread_wakeup</a> (<a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:gaab65867d92604d57f6efb622586466f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up a sleeping thread.  <a href="#gaab65867d92604d57f6efb622586466f4">More...</a><br /></td></tr>
<tr class="separator:gaab65867d92604d57f6efb622586466f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab68e945fba9216126e255648a9a4ee8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab68e945fba9216126e255648a9a4ee8a">thread_getpid</a> (void)</td></tr>
<tr class="memdesc:gab68e945fba9216126e255648a9a4ee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process ID of the currently running thread.  <a href="#gab68e945fba9216126e255648a9a4ee8a">More...</a><br /></td></tr>
<tr class="separator:gab68e945fba9216126e255648a9a4ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cf14bb228358de0e8a7a0e5425a466"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga46cf14bb228358de0e8a7a0e5425a466">thread_stack_init</a> (<a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a> task_func, void *arg, void *stack_start, int stack_size)</td></tr>
<tr class="memdesc:ga46cf14bb228358de0e8a7a0e5425a466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets called upon thread creation to set CPU registers.  <a href="#ga46cf14bb228358de0e8a7a0e5425a466">More...</a><br /></td></tr>
<tr class="separator:ga46cf14bb228358de0e8a7a0e5425a466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b51382807f0a214c15e282fec5476f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga66b51382807f0a214c15e282fec5476f">thread_add_to_list</a> (<a class="el" href="list_8h.html#ad8b8636e2e25308b521b32071e849c80">list_node_t</a> *list, <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:ga66b51382807f0a214c15e282fec5476f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add thread to list, sorted by priority (internal)  <a href="#ga66b51382807f0a214c15e282fec5476f">More...</a><br /></td></tr>
<tr class="separator:ga66b51382807f0a214c15e282fec5476f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95be7fb4afdce288dd85286c8591c8dd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga95be7fb4afdce288dd85286c8591c8dd">thread_getname</a> (<a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga95be7fb4afdce288dd85286c8591c8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a process.  <a href="#ga95be7fb4afdce288dd85286c8591c8dd">More...</a><br /></td></tr>
<tr class="separator:ga95be7fb4afdce288dd85286c8591c8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8daaf2e96831c06fe870e5bf3d40e33"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab8daaf2e96831c06fe870e5bf3d40e33">thread_measure_stack_free</a> (char *stack)</td></tr>
<tr class="memdesc:gab8daaf2e96831c06fe870e5bf3d40e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the stack usage of a stack.  <a href="#gab8daaf2e96831c06fe870e5bf3d40e33">More...</a><br /></td></tr>
<tr class="separator:gab8daaf2e96831c06fe870e5bf3d40e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb6763813ca04ff4b87b47f3d524505b"><td class="memItemLeft" align="right" valign="top"><a id="gabb6763813ca04ff4b87b47f3d524505b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gabb6763813ca04ff4b87b47f3d524505b">thread_isr_stack_usage</a> (void)</td></tr>
<tr class="memdesc:gabb6763813ca04ff4b87b47f3d524505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes used on the ISR stack. <br /></td></tr>
<tr class="separator:gabb6763813ca04ff4b87b47f3d524505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce2b0b9af6fd608f8135076aeaff674"><td class="memItemLeft" align="right" valign="top"><a id="ga7ce2b0b9af6fd608f8135076aeaff674"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7ce2b0b9af6fd608f8135076aeaff674">thread_isr_stack_pointer</a> (void)</td></tr>
<tr class="memdesc:ga7ce2b0b9af6fd608f8135076aeaff674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current ISR stack pointer. <br /></td></tr>
<tr class="separator:ga7ce2b0b9af6fd608f8135076aeaff674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd6618f65f13fd9a023b79da69545b1"><td class="memItemLeft" align="right" valign="top"><a id="ga7fd6618f65f13fd9a023b79da69545b1"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7fd6618f65f13fd9a023b79da69545b1">thread_isr_stack_start</a> (void)</td></tr>
<tr class="memdesc:ga7fd6618f65f13fd9a023b79da69545b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start of the ISR stack. <br /></td></tr>
<tr class="separator:ga7fd6618f65f13fd9a023b79da69545b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ea0c25c648d6990819d8502ae47696"><td class="memItemLeft" align="right" valign="top"><a id="ga05ea0c25c648d6990819d8502ae47696"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga05ea0c25c648d6990819d8502ae47696">thread_stack_print</a> (void)</td></tr>
<tr class="memdesc:ga05ea0c25c648d6990819d8502ae47696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current stack to stdout. <br /></td></tr>
<tr class="separator:ga05ea0c25c648d6990819d8502ae47696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80df800e5bde287544899ebea3af1c9"><td class="memItemLeft" align="right" valign="top"><a id="gad80df800e5bde287544899ebea3af1c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gad80df800e5bde287544899ebea3af1c9">thread_print_stack</a> (void)</td></tr>
<tr class="memdesc:gad80df800e5bde287544899ebea3af1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints human readable, ps-like thread information for debugging purposes. <br /></td></tr>
<tr class="separator:gad80df800e5bde287544899ebea3af1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d49bed9a012215e798f4ec4027bd4cd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7d49bed9a012215e798f4ec4027bd4cd">thread_has_msg_queue</a> (const volatile struct <a class="el" href="struct__thread.html">_thread</a> *thread)</td></tr>
<tr class="memdesc:ga7d49bed9a012215e798f4ec4027bd4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a thread has an initialized message queue.  <a href="#ga7d49bed9a012215e798f4ec4027bd4cd">More...</a><br /></td></tr>
<tr class="separator:ga7d49bed9a012215e798f4ec4027bd4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Optional flags for controlling a threads initial state</h2></td></tr>
<tr class="memitem:ga31d767ff839598270044e04a53ffa7f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga31d767ff839598270044e04a53ffa7f4">THREAD_CREATE_SLEEPING</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga31d767ff839598270044e04a53ffa7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new thread to sleeping.  <a href="#ga31d767ff839598270044e04a53ffa7f4">More...</a><br /></td></tr>
<tr class="separator:ga31d767ff839598270044e04a53ffa7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8901763d4bd30418a4ef730711b86ae"><td class="memItemLeft" align="right" valign="top"><a id="gaa8901763d4bd30418a4ef730711b86ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaa8901763d4bd30418a4ef730711b86ae">THREAD_AUTO_FREE</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:gaa8901763d4bd30418a4ef730711b86ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently not implemented. <br /></td></tr>
<tr class="separator:gaa8901763d4bd30418a4ef730711b86ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55062dd3d2da4ee10c96a5ff39505ff4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga55062dd3d2da4ee10c96a5ff39505ff4">THREAD_CREATE_WOUT_YIELD</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:ga55062dd3d2da4ee10c96a5ff39505ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not automatically call <a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield. ">thread_yield()</a> after creation: the newly created thread might not run immediately.  <a href="#ga55062dd3d2da4ee10c96a5ff39505ff4">More...</a><br /></td></tr>
<tr class="separator:ga55062dd3d2da4ee10c96a5ff39505ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f8182fbb138fd27746e509b69d3aed"><td class="memItemLeft" align="right" valign="top"><a id="ga51f8182fbb138fd27746e509b69d3aed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga51f8182fbb138fd27746e509b69d3aed">THREAD_CREATE_STACKTEST</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:ga51f8182fbb138fd27746e509b69d3aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write markers into the thread's stack to measure stack usage (for debugging and profiling purposes) <br /></td></tr>
<tr class="separator:ga51f8182fbb138fd27746e509b69d3aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga31d767ff839598270044e04a53ffa7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d767ff839598270044e04a53ffa7f4">&#9670;&nbsp;</a></span>THREAD_CREATE_SLEEPING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_CREATE_SLEEPING&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the new thread to sleeping. </p>
<p>It must be woken up manually. </p>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00298">298</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ga55062dd3d2da4ee10c96a5ff39505ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55062dd3d2da4ee10c96a5ff39505ff4">&#9670;&nbsp;</a></span>THREAD_CREATE_WOUT_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_CREATE_WOUT_YIELD&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not automatically call <a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield. ">thread_yield()</a> after creation: the newly created thread might not run immediately. </p>
<p>Purely for optimization. Any other context switch (i.e. an interrupt) can still start the thread at any time! </p>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00311">311</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="gaf30305c0f413c7da1e7445de2b5ea5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf30305c0f413c7da1e7445de2b5ea5a5">&#9670;&nbsp;</a></span>THREAD_EXTRA_STACKSIZE_PRINTF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_EXTRA_STACKSIZE_PRINTF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the task's printf stack in bytes. </p>
<dl class="section note"><dt>Note</dt><dd>This value must be defined by the CPU specific implementation, please take a look at <code>cpu/$CPU/include/cpu_conf</code>.h </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00223">223</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="gac57374d1c51374ebf95d9679281af818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac57374d1c51374ebf95d9679281af818">&#9670;&nbsp;</a></span>THREAD_PRIORITY_MAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIORITY_MAIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__core__thread.html#ga196e3293c94df476dd1dd0007013ad14">THREAD_PRIORITY_MIN</a> - \</div><div class="line">                                        (<a class="code" href="group__core__sched.html#ga1868da7c35ae4ff66fc899793d283dd6">SCHED_PRIO_LEVELS</a> / 2))</div><div class="ttc" id="group__core__thread_html_ga196e3293c94df476dd1dd0007013ad14"><div class="ttname"><a href="group__core__thread.html#ga196e3293c94df476dd1dd0007013ad14">THREAD_PRIORITY_MIN</a></div><div class="ttdeci">#define THREAD_PRIORITY_MIN</div><div class="ttdoc">Least priority a thread can have. </div><div class="ttdef"><b>Definition:</b> <a href="core_2include_2thread_8h_source.html#l00274">thread.h:274</a></div></div>
<div class="ttc" id="group__core__sched_html_ga1868da7c35ae4ff66fc899793d283dd6"><div class="ttname"><a href="group__core__sched.html#ga1868da7c35ae4ff66fc899793d283dd6">SCHED_PRIO_LEVELS</a></div><div class="ttdeci">#define SCHED_PRIO_LEVELS</div><div class="ttdoc">The number of thread priority levels. </div><div class="ttdef"><b>Definition:</b> <a href="sched_8h_source.html#l00134">sched.h:134</a></div></div>
</div><!-- fragment -->
<p>Priority of the main thread. </p>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00287">287</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ga713ebddc00581f4d415095cdbfd8791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713ebddc00581f4d415095cdbfd8791f">&#9670;&nbsp;</a></span>THREAD_STACKSIZE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_STACKSIZE_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A reasonable default stack size that will suffice most smaller tasks. </p>
<dl class="section note"><dt>Note</dt><dd>This value must be defined by the CPU specific implementation, please take a look at <code>cpu/$CPU/include/cpu_conf</code>.h </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00195">195</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="gac4f62f762a057d594ae0ee4522dd14c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4f62f762a057d594ae0ee4522dd14c2">&#9670;&nbsp;</a></span>THREAD_STACKSIZE_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_STACKSIZE_IDLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the idle task's stack in bytes. </p>
<dl class="section note"><dt>Note</dt><dd>This value must be defined by the CPU specific implementation, please take a look at <code>cpu/$CPU/include/cpu_conf</code>.h </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00209">209</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ga0dc9cf6e8b0b4da823649d78403fff90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc9cf6e8b0b4da823649d78403fff90">&#9670;&nbsp;</a></span>THREAD_STACKSIZE_MAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_STACKSIZE_MAIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__core__thread.html#ga713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a> + \</div><div class="line">                                    THREAD_EXTRA_STACKSIZE_PRINTF)</div><div class="ttc" id="group__core__thread_html_ga713ebddc00581f4d415095cdbfd8791f"><div class="ttname"><a href="group__core__thread.html#ga713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a></div><div class="ttdeci">#define THREAD_STACKSIZE_DEFAULT</div><div class="ttdoc">A reasonable default stack size that will suffice most smaller tasks. </div><div class="ttdef"><b>Definition:</b> <a href="core_2include_2thread_8h_source.html#l00195">thread.h:195</a></div></div>
</div><!-- fragment -->
<p>Size of the main task's stack in bytes. </p>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00231">231</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga66b51382807f0a214c15e282fec5476f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b51382807f0a214c15e282fec5476f">&#9670;&nbsp;</a></span>thread_add_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_add_to_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="list_8h.html#ad8b8636e2e25308b521b32071e849c80">list_node_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add thread to list, sorted by priority (internal) </p>
<p>This will add <code>thread</code> to <code>list</code> sorted by the thread priority. It reuses the thread's rq_entry field. Used internally by msg and mutex implementations.</p>
<dl class="section note"><dt>Note</dt><dd>Only use for threads <em>not on any runqueue</em> and with interrupts disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>ptr to list root node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>thread to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e0403a9aa86ce0ec136f6b069d4434a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0403a9aa86ce0ec136f6b069d4434a">&#9670;&nbsp;</a></span>thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> thread_create </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a>&#160;</td>
          <td class="paramname"><em>task_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new thread. </p>
<p>For an in-depth discussion of thread priorities, behavior and and flags, see <a class="el" href="group__core__thread.html">Threading</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid assigning the same priority to two or more threads. </dd>
<dd>
Creating threads from within an ISR is currently supported, however it is considered to be a bad programming practice and we strongly discourage you from doing so.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stack</td><td>start address of the preallocated stack memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stacksize</td><td>the size of the thread's stack in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>priority of the new thread, lower mean higher priority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags for the creation of the new thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_func</td><td>pointer to the code that is executed in the new thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>a human readable descriptor for the thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PID of newly created task on success </dd>
<dd>
-EINVAL, if <code>priority</code> is greater than or equal to <a class="el" href="group__core__sched.html#ga1868da7c35ae4ff66fc899793d283dd6">SCHED_PRIO_LEVELS</a> </dd>
<dd>
-EOVERFLOW, if there are too many threads running already </dd></dl>

</div>
</div>
<a id="ga754515868f32530baa52ad2d05620205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga754515868f32530baa52ad2d05620205">&#9670;&nbsp;</a></span>thread_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a>* thread_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a thread control block by PID. </p>
<p>This is a bound-checked variant of accessing <code>sched_threads[pid]</code> directly. If you know that the PID is valid, then don't use this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>Thread to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if the PID is invalid or there is no such thread. </dd></dl>

</div>
</div>
<a id="ga95be7fb4afdce288dd85286c8591c8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95be7fb4afdce288dd85286c8591c8dd">&#9670;&nbsp;</a></span>thread_getname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* thread_getname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a process. </p>
<dl class="section note"><dt>Note</dt><dd>when compiling without DEVELHELP, this <em>always</em> returns NULL!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to get the name from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the threads name </dd>
<dd>
<code>NULL</code> if pid is unknown </dd></dl>

</div>
</div>
<a id="gab68e945fba9216126e255648a9a4ee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab68e945fba9216126e255648a9a4ee8a">&#9670;&nbsp;</a></span>thread_getpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> thread_getpid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the process ID of the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>obviously you are not a golfer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00439">439</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ga126920c73220c857489a340ee1a5072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga126920c73220c857489a340ee1a5072a">&#9670;&nbsp;</a></span>thread_getstatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a> thread_getstatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of a process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to get the status from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the thread </dd>
<dd>
<code>STATUS_NOT_FOUND</code> if pid is unknown </dd></dl>

</div>
</div>
<a id="ga7d49bed9a012215e798f4ec4027bd4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d49bed9a012215e798f4ec4027bd4cd">&#9670;&nbsp;</a></span>thread_has_msg_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int thread_has_msg_queue </td>
          <td>(</td>
          <td class="paramtype">const volatile struct <a class="el" href="struct__thread.html">_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a thread has an initialized message queue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__msg.html#ga480e6f32c8ab18579b62a890f3fda2cd">msg_init_queue()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>== 0</code>, if <code>thread</code> has no initialized message queue </dd>
<dd>
<code>!= 0</code>, if <code>thread</code> has its message queue initialized </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2include_2thread_8h_source.html#l00534">534</a> of file <a class="el" href="core_2include_2thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ga862dec3a65ad85c3b18bdf2d5450880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862dec3a65ad85c3b18bdf2d5450880e">&#9670;&nbsp;</a></span>thread_kill_zombie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_kill_zombie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates zombie thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to terminate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> on success </dd>
<dd>
<code>STATUS_NOT_FOUND</code> if pid is unknown or not a zombie </dd></dl>

</div>
</div>
<a id="gab8daaf2e96831c06fe870e5bf3d40e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8daaf2e96831c06fe870e5bf3d40e33">&#9670;&nbsp;</a></span>thread_measure_stack_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t thread_measure_stack_free </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the stack usage of a stack. </p>
<p>Only works if the thread was created with the flag THREAD_CREATE_STACKTEST.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>the stack you want to measure. try <code>sched_active_thread-&gt;stack_start</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of unused space of the thread's stack </dd></dl>

</div>
</div>
<a id="ga8d16ab2564e99827b629f8cb1a253beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d16ab2564e99827b629f8cb1a253beb">&#9670;&nbsp;</a></span>thread_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the current thread into sleep mode. </p>
<p>Has to be woken up externally. </p>

</div>
</div>
<a id="ga46cf14bb228358de0e8a7a0e5425a466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46cf14bb228358de0e8a7a0e5425a466">&#9670;&nbsp;</a></span>thread_stack_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* thread_stack_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a>&#160;</td>
          <td class="paramname"><em>task_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets called upon thread creation to set CPU registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_func</td><td>First function to call within the thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Argument to supply to task_func </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_start</td><td>Start address of the stack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>Stack size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack pointer </dd></dl>

</div>
</div>
<a id="gaab65867d92604d57f6efb622586466f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab65867d92604d57f6efb622586466f4">&#9670;&nbsp;</a></span>thread_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel__types_8h.html#a8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakes up a sleeping thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to be woken up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> on success </dd>
<dd>
<code>STATUS_NOT_FOUND</code> if pid is unknown or not sleeping </dd></dl>

</div>
</div>
<a id="gaaa9229e0f462f60bb9550919fa3d7699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9229e0f462f60bb9550919fa3d7699">&#9670;&nbsp;</a></span>thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lets current thread yield. </p>
<p>The current thread will resume operation immediately, if there is no other ready thread with the same or a higher priority.</p>
<p>Differently from <a class="el" href="group__core__thread.html#ga293ec7e262958787bc744f28d29588a8" title="Lets current thread yield in favor of a higher prioritized thread. ">thread_yield_higher()</a> the current thread will be put to the end of the thread's in its priority class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__thread.html#ga293ec7e262958787bc744f28d29588a8" title="Lets current thread yield in favor of a higher prioritized thread. ">thread_yield_higher()</a> </dd></dl>

</div>
</div>
<a id="ga293ec7e262958787bc744f28d29588a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293ec7e262958787bc744f28d29588a8">&#9670;&nbsp;</a></span>thread_yield_higher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_yield_higher </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lets current thread yield in favor of a higher prioritized thread. </p>
<p>The current thread will resume operation immediately, if there is no other ready thread with a higher priority.</p>
<p>Differently from <a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield. ">thread_yield()</a> the current thread will be scheduled next in its own priority class, i.e. it stays the first thread in its priority class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield. ">thread_yield()</a> </dd></dl>

</div>
</div>
<a id="ga76c8b55efc2c693fc6e2c6acd9ca2ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76c8b55efc2c693fc6e2c6acd9ca2ddb">&#9670;&nbsp;</a></span>thread_zombify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_zombify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the current thread into zombie state. </p>
<p>Does nothing when in ISR. A thread in zombie state will never be scheduled again, but its scheduler entry and stack will be kept. A zombie state thread is supposed to be cleaned up by <a class="el" href="group__core__thread.html#ga862dec3a65ad85c3b18bdf2d5450880e">thread_kill_zombie()</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Jul 2 2020 15:49:28 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
