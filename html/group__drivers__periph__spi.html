<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>SPI</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <!--BEGIN SEARCHENGINE hidden-sm hidden-xs"-->
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
    var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replaceAll('href=\"../','href=\"');
    document.getElementById('MSearchResultsWindow').style.display='none';
    document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
    document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
    document.getElementById('doc-content').innerHTML=rhtml;
}finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event);
                              var r=document.getElementById('MSearchResultsWindow');
                              if(parseInt(r.style.left)<0)r.style.left=0;
                              var x=document.getElementById('MSearchResults');
                              if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                              var f=document.getElementById('riot-searchform');
                              if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__drivers__periph__spi.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI<div class="ingroups"><a class="el" href="group__drivers.html">Drivers</a> &raquo; <a class="el" href="group__drivers__periph.html">Peripheral Driver Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low-level SPI peripheral driver.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low-level SPI peripheral driver. </p>
<p>This interface defines an abstraction for using a CPU's hardware SPI units. The interface only supports SPI master mode.</p>
<p>As SPI buses can have multiple devices connected to them they are to be considered as shared resources. To reflect this, the SPI interface is based on a transaction model. This requires that the bus needs to be acquired before usage and released afterwards, using the <code><a class="el" href="group__drivers__periph__spi.html#ga18d8f6e9f0b095440e6355092a2a37d5" title="Start a new SPI transaction. ">spi_acquire()</a></code> and the <code><a class="el" href="group__drivers__periph__spi.html#ga9e36100f2b58917366872fca2f9f3bc6" title="Finish an ongoing SPI transaction by releasing the given SPI bus. ">spi_release()</a></code> functions.</p>
<p>This interface supports both software and hardware chip select lines. This is reflected by the cpi_cs_t type, which overloads the gpio_t type with platform specific values for defining platform dependent hardware chip select lines.</p>
<p>Some devices have however very uncommon requirements on the usage and the timings of their chip select line. For those cases this interface allows to manage the chip select line manually from the user code (e.g. by calling gpio_set/clear explicitly) while deactivating the SPI driver internal chip select handling by passing <a class="el" href="group__drivers__periph__gpio.html#ga3969ce1e494a72d3c2925b10ddeb4604">GPIO_UNDEF</a> as CS parameter.</p>
<p>In the time, when the SPI bus is not used, the SPI unit should be in low-power mode to save energy.</p>
<p>The SPI unit's initialization is split into 3 parts:</p><ol type="1">
<li><code><a class="el" href="group__drivers__periph__spi.html#gada6e52541835bc04dcc6ec62f2c74c3a" title="Basic initialization of the given SPI bus. ">spi_init()</a></code> should be called once for each SPI unit defined by a board during system initialization.</li>
<li><code><a class="el" href="group__drivers__periph__spi.html#ga1ed20d7e5b67938bd35139a819a8c982" title="Initialize the given chip select pin. ">spi_init_cs()</a></code> should be called during device driver initialization, as each chip select pin/line is used uniquely by a specific device, i.e. chip select lines are no shared resource.</li>
<li><code><a class="el" href="group__drivers__periph__spi.html#ga18d8f6e9f0b095440e6355092a2a37d5" title="Start a new SPI transaction. ">spi_acquire()</a></code> needs to be called for each new transaction. This function configures the bus with specific parameters (clock, mode) for the duration of that transaction.</li>
</ol>
<h1>(Low-) Power Implications</h1>
<p>As SPI buses are shared peripherals and the interfaces implements a transaction based paradigm, we leverage this for the SPI peripherals power management. After calling <a class="el" href="group__drivers__periph__spi.html#gada6e52541835bc04dcc6ec62f2c74c3a" title="Basic initialization of the given SPI bus. ">spi_init()</a>, the SPI peripheral <b>should</b> be completely powered off (e.g. through peripheral clock gating). It <b>should</b> subsequently only be powered on and enabled in between <a class="el" href="group__drivers__periph__spi.html#ga18d8f6e9f0b095440e6355092a2a37d5" title="Start a new SPI transaction. ">spi_acquire()</a> and <a class="el" href="group__drivers__periph__spi.html#ga9e36100f2b58917366872fca2f9f3bc6" title="Finish an ongoing SPI transaction by releasing the given SPI bus. ">spi_release()</a> blocks.</p>
<p>In case the SPI driver implementation puts the active thread to sleep during data transfer (e.g. when using DMA), the implementation might need to block certain power states during that time. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:spi_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8h.html">spi.h</a></td></tr>
<tr class="memdesc:spi_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI peripheral driver interface definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__gpio__mode__t.html">spi_gpio_mode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI gpio mode.  <a href="structspi__gpio__mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafb9420809bc7722e41488a090b53eaf9"><td class="memItemLeft" align="right" valign="top"><a id="gafb9420809bc7722e41488a090b53eaf9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9">SPI_DEV</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:gafb9420809bc7722e41488a090b53eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default SPI device access macro. <br /></td></tr>
<tr class="separator:gafb9420809bc7722e41488a090b53eaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d0505b52e78af9251f6a1921d30214e"><td class="memItemLeft" align="right" valign="top"><a id="ga0d0505b52e78af9251f6a1921d30214e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga0d0505b52e78af9251f6a1921d30214e">SPI_UNDEF</a>&#160;&#160;&#160;(UINT_MAX)</td></tr>
<tr class="memdesc:ga0d0505b52e78af9251f6a1921d30214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define global value for undefined SPI device. <br /></td></tr>
<tr class="separator:ga0d0505b52e78af9251f6a1921d30214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0f414ed05adc20a504e8705587f9f8"><td class="memItemLeft" align="right" valign="top"><a id="ga8b0f414ed05adc20a504e8705587f9f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga8b0f414ed05adc20a504e8705587f9f8">SPI_CS_UNDEF</a>&#160;&#160;&#160;(<a class="el" href="group__drivers__periph__gpio.html#ga3969ce1e494a72d3c2925b10ddeb4604">GPIO_UNDEF</a>)</td></tr>
<tr class="memdesc:ga8b0f414ed05adc20a504e8705587f9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define value for unused CS line. <br /></td></tr>
<tr class="separator:ga8b0f414ed05adc20a504e8705587f9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga292c9a0a5b03329a153ad28343ff2e09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga292c9a0a5b03329a153ad28343ff2e09">SPI_HWCS</a>(x)&#160;&#160;&#160;(<a class="el" href="group__drivers__periph__spi.html#ga8b0f414ed05adc20a504e8705587f9f8">SPI_CS_UNDEF</a>)</td></tr>
<tr class="memdesc:ga292c9a0a5b03329a153ad28343ff2e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default SPI hardware chip select access macro.  <a href="#ga292c9a0a5b03329a153ad28343ff2e09">More...</a><br /></td></tr>
<tr class="separator:ga292c9a0a5b03329a153ad28343ff2e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac33db64063315b2b98b535051813ccea"><td class="memItemLeft" align="right" valign="top"><a id="gac33db64063315b2b98b535051813ccea"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a></td></tr>
<tr class="memdesc:gac33db64063315b2b98b535051813ccea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default type for SPI devices. <br /></td></tr>
<tr class="separator:gac33db64063315b2b98b535051813ccea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5fbaf43946646c588c9372e8906c99e"><td class="memItemLeft" align="right" valign="top"><a id="gaf5fbaf43946646c588c9372e8906c99e"></a>
typedef <a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td></tr>
<tr class="memdesc:gaf5fbaf43946646c588c9372e8906c99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chip select pin type overlaps with gpio_t so it can be casted to this. <br /></td></tr>
<tr class="separator:gaf5fbaf43946646c588c9372e8906c99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga223be06596dd9ff740bf0a09c8632294"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__drivers__periph__spi.html#gga223be06596dd9ff740bf0a09c8632294a2b1fe832bba9b2799c09ddec72f7df75">SPI_OK</a> = 0, 
<a class="el" href="group__drivers__periph__spi.html#gga223be06596dd9ff740bf0a09c8632294a9c11521841e0fa199f2a6c49f441ecb2">SPI_NODEV</a> = -1, 
<a class="el" href="group__drivers__periph__spi.html#gga223be06596dd9ff740bf0a09c8632294a4955501124d6881ba11dcf3007aa31cc">SPI_NOCS</a> = -2, 
<a class="el" href="group__drivers__periph__spi.html#gga223be06596dd9ff740bf0a09c8632294a9ff35bd70e3623cf323f8caaafacf8e3">SPI_NOMODE</a> = -3, 
<br />
&#160;&#160;<a class="el" href="group__drivers__periph__spi.html#gga223be06596dd9ff740bf0a09c8632294a7dc86187e76eb54e02d32e53f4fb08b3">SPI_NOCLK</a> = -4
<br />
 }<tr class="memdesc:ga223be06596dd9ff740bf0a09c8632294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status codes used by the SPI driver interface.  <a href="group__drivers__periph__spi.html#ga223be06596dd9ff740bf0a09c8632294">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga223be06596dd9ff740bf0a09c8632294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b206a51636d91c5cffcbcee458c3cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a> { <a class="el" href="group__drivers__periph__spi.html#ggac4b206a51636d91c5cffcbcee458c3cba152359b11fb4b43ed0c5485eb0ab0673">SPI_MODE_0</a> = 0, 
<a class="el" href="group__drivers__periph__spi.html#ggac4b206a51636d91c5cffcbcee458c3cba7c1990cc15e9d69621be8e0e757e634c">SPI_MODE_1</a>, 
<a class="el" href="group__drivers__periph__spi.html#ggac4b206a51636d91c5cffcbcee458c3cba4d350945d895a4acdc45ae96b0b82fc3">SPI_MODE_2</a>, 
<a class="el" href="group__drivers__periph__spi.html#ggac4b206a51636d91c5cffcbcee458c3cbaf06ec36087996d6f328df39866ff5de6">SPI_MODE_3</a>
 }<tr class="memdesc:gac4b206a51636d91c5cffcbcee458c3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available SPI modes, defining the configuration of clock polarity and clock phase.  <a href="group__drivers__periph__spi.html#gac4b206a51636d91c5cffcbcee458c3cb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gac4b206a51636d91c5cffcbcee458c3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae81cec9f03084065c25089e514a57337"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gae81cec9f03084065c25089e514a57337">spi_clk_t</a> { <br />
&#160;&#160;<a class="el" href="group__drivers__periph__spi.html#ggae81cec9f03084065c25089e514a57337ae6cc2c3387e4da1c7cb83aefb10f5d27">SPI_CLK_100KHZ</a> = 0, 
<a class="el" href="group__drivers__periph__spi.html#ggae81cec9f03084065c25089e514a57337a8db155bff416a59ca71ce9b2a2568bf3">SPI_CLK_400KHZ</a>, 
<a class="el" href="group__drivers__periph__spi.html#ggae81cec9f03084065c25089e514a57337abf727d641e5cceb12a58d29dc954c111">SPI_CLK_1MHZ</a>, 
<a class="el" href="group__drivers__periph__spi.html#ggae81cec9f03084065c25089e514a57337a4105210aa902203502e4392d4a3fbe58">SPI_CLK_5MHZ</a>, 
<br />
&#160;&#160;<a class="el" href="group__drivers__periph__spi.html#ggae81cec9f03084065c25089e514a57337a1693f88bef873b11f7b85ce0bba8175d">SPI_CLK_10MHZ</a>
<br />
 }<tr class="memdesc:gae81cec9f03084065c25089e514a57337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available SPI clock speeds.  <a href="group__drivers__periph__spi.html#gae81cec9f03084065c25089e514a57337">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gae81cec9f03084065c25089e514a57337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gada6e52541835bc04dcc6ec62f2c74c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gada6e52541835bc04dcc6ec62f2c74c3a">spi_init</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus)</td></tr>
<tr class="memdesc:gada6e52541835bc04dcc6ec62f2c74c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic initialization of the given SPI bus.  <a href="#gada6e52541835bc04dcc6ec62f2c74c3a">More...</a><br /></td></tr>
<tr class="separator:gada6e52541835bc04dcc6ec62f2c74c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fcf9ffd48cdc62c6019a2f07aab4ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga9fcf9ffd48cdc62c6019a2f07aab4ae9">spi_init_pins</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus)</td></tr>
<tr class="memdesc:ga9fcf9ffd48cdc62c6019a2f07aab4ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the used SPI bus pins, i.e.  <a href="#ga9fcf9ffd48cdc62c6019a2f07aab4ae9">More...</a><br /></td></tr>
<tr class="separator:ga9fcf9ffd48cdc62c6019a2f07aab4ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed20d7e5b67938bd35139a819a8c982"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga1ed20d7e5b67938bd35139a819a8c982">spi_init_cs</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus, <a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs)</td></tr>
<tr class="memdesc:ga1ed20d7e5b67938bd35139a819a8c982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the given chip select pin.  <a href="#ga1ed20d7e5b67938bd35139a819a8c982">More...</a><br /></td></tr>
<tr class="separator:ga1ed20d7e5b67938bd35139a819a8c982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53bb266f74e4aaab19955c9fd199205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gab53bb266f74e4aaab19955c9fd199205">spi_deinit_pins</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> dev)</td></tr>
<tr class="memdesc:gab53bb266f74e4aaab19955c9fd199205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the pins of the given SPI bus back to plain GPIO functionality.  <a href="#gab53bb266f74e4aaab19955c9fd199205">More...</a><br /></td></tr>
<tr class="separator:gab53bb266f74e4aaab19955c9fd199205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206fc7968c27b40069ec5c3d7de03eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga206fc7968c27b40069ec5c3d7de03eb3">spi_pin_miso</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> dev)</td></tr>
<tr class="memdesc:ga206fc7968c27b40069ec5c3d7de03eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MISO pin of the given SPI bus.  <a href="#ga206fc7968c27b40069ec5c3d7de03eb3">More...</a><br /></td></tr>
<tr class="separator:ga206fc7968c27b40069ec5c3d7de03eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1dd3972f11c2383927855a4daf5d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga5a1dd3972f11c2383927855a4daf5d89">spi_pin_mosi</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> dev)</td></tr>
<tr class="memdesc:ga5a1dd3972f11c2383927855a4daf5d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MOSI pin of the given SPI bus.  <a href="#ga5a1dd3972f11c2383927855a4daf5d89">More...</a><br /></td></tr>
<tr class="separator:ga5a1dd3972f11c2383927855a4daf5d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ad55ec9f29b85502d74a1a4230cd45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga64ad55ec9f29b85502d74a1a4230cd45">spi_pin_clk</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> dev)</td></tr>
<tr class="memdesc:ga64ad55ec9f29b85502d74a1a4230cd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CLK pin of the given SPI bus.  <a href="#ga64ad55ec9f29b85502d74a1a4230cd45">More...</a><br /></td></tr>
<tr class="separator:ga64ad55ec9f29b85502d74a1a4230cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f90200fdf31f65d3e4e2efccd15426b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga5f90200fdf31f65d3e4e2efccd15426b">spi_init_with_gpio_mode</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus, <a class="el" href="structspi__gpio__mode__t.html">spi_gpio_mode_t</a> mode)</td></tr>
<tr class="memdesc:ga5f90200fdf31f65d3e4e2efccd15426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize MOSI/MISO/SCLK pins with adapted GPIO modes.  <a href="#ga5f90200fdf31f65d3e4e2efccd15426b">More...</a><br /></td></tr>
<tr class="separator:ga5f90200fdf31f65d3e4e2efccd15426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18d8f6e9f0b095440e6355092a2a37d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga18d8f6e9f0b095440e6355092a2a37d5">spi_acquire</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus, <a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, <a class="el" href="group__drivers__periph__spi.html#gac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a> mode, <a class="el" href="group__drivers__periph__spi.html#gae81cec9f03084065c25089e514a57337">spi_clk_t</a> clk)</td></tr>
<tr class="memdesc:ga18d8f6e9f0b095440e6355092a2a37d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new SPI transaction.  <a href="#ga18d8f6e9f0b095440e6355092a2a37d5">More...</a><br /></td></tr>
<tr class="separator:ga18d8f6e9f0b095440e6355092a2a37d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e36100f2b58917366872fca2f9f3bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga9e36100f2b58917366872fca2f9f3bc6">spi_release</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus)</td></tr>
<tr class="memdesc:ga9e36100f2b58917366872fca2f9f3bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish an ongoing SPI transaction by releasing the given SPI bus.  <a href="#ga9e36100f2b58917366872fca2f9f3bc6">More...</a><br /></td></tr>
<tr class="separator:ga9e36100f2b58917366872fca2f9f3bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga6e2f58f7b719d1e8ac5cb05bdeed7c9b">spi_transfer_byte</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus, <a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, bool cont, uint8_t out)</td></tr>
<tr class="memdesc:ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer one byte on the given SPI bus.  <a href="#ga6e2f58f7b719d1e8ac5cb05bdeed7c9b">More...</a><br /></td></tr>
<tr class="separator:ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ca850b7cb6142b76deecb831357447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#gae6ca850b7cb6142b76deecb831357447">spi_transfer_bytes</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus, <a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, bool cont, const void *out, void *in, <a class="el" href="msp430__types_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> len)</td></tr>
<tr class="memdesc:gae6ca850b7cb6142b76deecb831357447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a number bytes using the given SPI bus.  <a href="#gae6ca850b7cb6142b76deecb831357447">More...</a><br /></td></tr>
<tr class="separator:gae6ca850b7cb6142b76deecb831357447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2593203a71900ff6d8346398bc5241a1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga2593203a71900ff6d8346398bc5241a1">spi_transfer_reg</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus, <a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, uint8_t reg, uint8_t out)</td></tr>
<tr class="memdesc:ga2593203a71900ff6d8346398bc5241a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer one byte to/from a given register address.  <a href="#ga2593203a71900ff6d8346398bc5241a1">More...</a><br /></td></tr>
<tr class="separator:ga2593203a71900ff6d8346398bc5241a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6577f294a7dd426badb3d69356bfc850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__spi.html#ga6577f294a7dd426badb3d69356bfc850">spi_transfer_regs</a> (<a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a> bus, <a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, uint8_t reg, const void *out, void *in, <a class="el" href="msp430__types_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> len)</td></tr>
<tr class="memdesc:ga6577f294a7dd426badb3d69356bfc850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a number of bytes to/from a given register address.  <a href="#ga6577f294a7dd426badb3d69356bfc850">More...</a><br /></td></tr>
<tr class="separator:ga6577f294a7dd426badb3d69356bfc850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga292c9a0a5b03329a153ad28343ff2e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga292c9a0a5b03329a153ad28343ff2e09">&#9670;&nbsp;</a></span>SPI_HWCS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_HWCS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group__drivers__periph__spi.html#ga8b0f414ed05adc20a504e8705587f9f8">SPI_CS_UNDEF</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default SPI hardware chip select access macro. </p>
<p>Per default, we map all hardware chip select lines to be not defined. If an implementation makes use of HW chip select lines, this value needs to be overridden by the corresponding CPU. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00111">111</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga223be06596dd9ff740bf0a09c8632294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga223be06596dd9ff740bf0a09c8632294">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status codes used by the SPI driver interface. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga223be06596dd9ff740bf0a09c8632294a2b1fe832bba9b2799c09ddec72f7df75"></a>SPI_OK&#160;</td><td class="fielddoc"><p>everything went as planned </p>
</td></tr>
<tr><td class="fieldname"><a id="gga223be06596dd9ff740bf0a09c8632294a9c11521841e0fa199f2a6c49f441ecb2"></a>SPI_NODEV&#160;</td><td class="fielddoc"><p>invalid SPI bus specified </p>
</td></tr>
<tr><td class="fieldname"><a id="gga223be06596dd9ff740bf0a09c8632294a4955501124d6881ba11dcf3007aa31cc"></a>SPI_NOCS&#160;</td><td class="fielddoc"><p>invalid chip select line specified </p>
</td></tr>
<tr><td class="fieldname"><a id="gga223be06596dd9ff740bf0a09c8632294a9ff35bd70e3623cf323f8caaafacf8e3"></a>SPI_NOMODE&#160;</td><td class="fielddoc"><p>selected mode is not supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga223be06596dd9ff740bf0a09c8632294a7dc86187e76eb54e02d32e53f4fb08b3"></a>SPI_NOCLK&#160;</td><td class="fielddoc"><p>selected clock value is not supported </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00132">132</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="gae81cec9f03084065c25089e514a57337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae81cec9f03084065c25089e514a57337">&#9670;&nbsp;</a></span>spi_clk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drivers__periph__spi.html#gae81cec9f03084065c25089e514a57337">spi_clk_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available SPI clock speeds. </p>
<p>The actual speed of the bus can vary to some extend, as the combination of CPU clock and available prescaler values on certain platforms may not make the exact values possible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337ae6cc2c3387e4da1c7cb83aefb10f5d27"></a>SPI_CLK_100KHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 100KHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337a8db155bff416a59ca71ce9b2a2568bf3"></a>SPI_CLK_400KHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 400KHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337abf727d641e5cceb12a58d29dc954c111"></a>SPI_CLK_1MHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 1MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337a4105210aa902203502e4392d4a3fbe58"></a>SPI_CLK_5MHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 5MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337a1693f88bef873b11f7b85ce0bba8175d"></a>SPI_CLK_10MHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 10MHz </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00173">173</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="gac4b206a51636d91c5cffcbcee458c3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4b206a51636d91c5cffcbcee458c3cb">&#9670;&nbsp;</a></span>spi_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drivers__periph__spi.html#gac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available SPI modes, defining the configuration of clock polarity and clock phase. </p>
<p>RIOT is using the mode numbers as commonly defined by most vendors (<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_numbers">https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_numbers</a>):</p>
<ul>
<li>MODE_0: CPOL=0, CPHA=0 - The first data bit is sampled by the receiver on the first SCK rising SCK edge (this mode is used most often).</li>
<li>MODE_1: CPOL=0, CPHA=1 - The first data bit is sampled by the receiver on the second rising SCK edge.</li>
<li>MODE_2: CPOL=1, CPHA=0 - The first data bit is sampled by the receiver on the first falling SCK edge.</li>
<li>MODE_3: CPOL=1, CPHA=1 - The first data bit is sampled by the receiver on the second falling SCK edge. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cba152359b11fb4b43ed0c5485eb0ab0673"></a>SPI_MODE_0&#160;</td><td class="fielddoc"><p>CPOL=0, CPHA=0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cba7c1990cc15e9d69621be8e0e757e634c"></a>SPI_MODE_1&#160;</td><td class="fielddoc"><p>CPOL=0, CPHA=1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cba4d350945d895a4acdc45ae96b0b82fc3"></a>SPI_MODE_2&#160;</td><td class="fielddoc"><p>CPOL=1, CPHA=0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cbaf06ec36087996d6f328df39866ff5de6"></a>SPI_MODE_3&#160;</td><td class="fielddoc"><p>CPOL=1, CPHA=1. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00157">157</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga18d8f6e9f0b095440e6355092a2a37d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18d8f6e9f0b095440e6355092a2a37d5">&#9670;&nbsp;</a></span>spi_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spi_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a>&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gae81cec9f03084065c25089e514a57337">spi_clk_t</a>&#160;</td>
          <td class="paramname"><em>clk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a new SPI transaction. </p>
<p>Starting a new SPI transaction will get exclusive access to the SPI bus and configure it according to the given values. If another SPI transaction is active when this function is called, this function will block until the other transaction is complete (spi_relase was called).</p>
<dl class="section note"><dt>Note</dt><dd>This function expects the <code>bus</code> and the <code>cs</code> parameters to be valid (they are checked in spi_init and spi_init_cs before)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode to use for the new transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>bus clock speed to use for the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_OK on success </dd>
<dd>
SPI_NOMODE if given mode is not supported </dd>
<dd>
SPI_NOCLK if given clock speed is not supported </dd></dl>

</div>
</div>
<a id="gab53bb266f74e4aaab19955c9fd199205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab53bb266f74e4aaab19955c9fd199205">&#9670;&nbsp;</a></span>spi_deinit_pins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_deinit_pins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the pins of the given SPI bus back to plain GPIO functionality. </p>
<p>The pin mux of the MISO, MOSI and CLK pins of the bus will be changed back to default (GPIO) mode and the SPI bus is powered off. This allows to use the SPI pins for another function and return to SPI functionality again by calling <a class="el" href="group__drivers__periph__spi.html#ga9fcf9ffd48cdc62c6019a2f07aab4ae9" title="Initialize the used SPI bus pins, i.e. ">spi_init_pins()</a></p>
<p>If you want the pin to be in a defined state, call <a class="el" href="group__drivers__periph__gpio.html#gab7d8ecaeb639070a28027a8fd31a0955" title="Initialize the given pin as general purpose input or output. ">gpio_init()</a> on it.</p>
<p>The bus MUST not be acquired before initializing it, as this is handled internally by the <a class="el" href="group__drivers__periph__spi.html#gab53bb266f74e4aaab19955c9fd199205" title="Change the pins of the given SPI bus back to plain GPIO functionality. ">spi_deinit_pins()</a> function!</p>
<p>Calls to <a class="el" href="group__drivers__periph__spi.html#ga18d8f6e9f0b095440e6355092a2a37d5" title="Start a new SPI transaction. ">spi_acquire()</a> will block until <a class="el" href="group__drivers__periph__spi.html#ga9fcf9ffd48cdc62c6019a2f07aab4ae9" title="Initialize the used SPI bus pins, i.e. ">spi_init_pins()</a> is called again.</p>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>the device to de-initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada6e52541835bc04dcc6ec62f2c74c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6e52541835bc04dcc6ec62f2c74c3a">&#9670;&nbsp;</a></span>spi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic initialization of the given SPI bus. </p>
<p>This function does the basic initialization including pin configuration for MISO, MOSI, and CLK pins. After initialization, the given device should be in power down state.</p>
<p>This function is intended to be called by the board initialization code during system startup to prepare the (shared) SPI device for further usage. It uses the board specific initialization parameters as defined in the board's <code>periph_conf.h</code>.</p>
<p>Errors (e.g. invalid <code>bus</code> parameter) are not signaled through a return value, but should be signaled using the <a class="el" href="assert_8h.html#a3153a272f18d0f805028fce7e4337b53" title="abort the program if assertion is false ">assert()</a> function internally.</p>
<dl class="section note"><dt>Note</dt><dd>This function MUST not be called more than once per bus!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ed20d7e5b67938bd35139a819a8c982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed20d7e5b67938bd35139a819a8c982">&#9670;&nbsp;</a></span>spi_init_cs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spi_init_cs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a>&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the given chip select pin. </p>
<p>The chip select can be any generic GPIO pin (e.g. <a class="el" href="group__drivers__periph__gpio.html#gae29846b3ecd19a0b7c44ff80a37ae7c1" title="Convert (port, pin) tuple to gpio_t value. ">GPIO_PIN(x,y)</a>), or it can be a hardware chip select line. The existence and number of hardware chip select lines depends on the underlying platform and the actual pins used for hardware chip select lines are defined in the board's <code>periph_conf.h</code>.</p>
<p>Define the used chip select line using the <a class="el" href="group__drivers__periph__spi.html#ga292c9a0a5b03329a153ad28343ff2e09">SPI_HWCS(x)</a> macro for hardware chip select line <code>x</code> or the <a class="el" href="group__drivers__periph__gpio.html#gae29846b3ecd19a0b7c44ff80a37ae7c1" title="Convert (port, pin) tuple to gpio_t value. ">GPIO_PIN(x,y)</a> macro for using any GPIO pin for manual chip select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device that is used with the given CS line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin to initialize</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_OK on success </dd>
<dd>
SPI_NODEV on invalid device </dd>
<dd>
SPI_NOCS on invalid CS pin/line </dd></dl>

</div>
</div>
<a id="ga9fcf9ffd48cdc62c6019a2f07aab4ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fcf9ffd48cdc62c6019a2f07aab4ae9">&#9670;&nbsp;</a></span>spi_init_pins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_init_pins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the used SPI bus pins, i.e. </p>
<p>MISO, MOSI, and CLK</p>
<p>After calling spi_init, the pins must be initialized (i.e. spi_init is calling this function internally). In normal cases, this function will not be used. But there are some devices (e.g. CC110x), that use SPI bus lines also for other purposes and need the option to dynamically re-configure one or more of the used pins. So they can take control over certain pins and return control back to the SPI driver using this function.</p>
<p>This function must be called after <a class="el" href="group__drivers__periph__spi.html#gab53bb266f74e4aaab19955c9fd199205">spi_deinit_pins</a> to return the pins to SPI operation.</p>
<p>The pins used are configured in the board's periph_conf.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device the pins are configure for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f90200fdf31f65d3e4e2efccd15426b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f90200fdf31f65d3e4e2efccd15426b">&#9670;&nbsp;</a></span>spi_init_with_gpio_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spi_init_with_gpio_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspi__gpio__mode__t.html">spi_gpio_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MOSI/MISO/SCLK pins with adapted GPIO modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device that is used with the given CS line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>a struct containing the 3 modes to use on each pin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga64ad55ec9f29b85502d74a1a4230cd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ad55ec9f29b85502d74a1a4230cd45">&#9670;&nbsp;</a></span>spi_pin_clk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> spi_pin_clk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CLK pin of the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the SPI CLK line. </dd></dl>

</div>
</div>
<a id="ga206fc7968c27b40069ec5c3d7de03eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206fc7968c27b40069ec5c3d7de03eb3">&#9670;&nbsp;</a></span>spi_pin_miso()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> spi_pin_miso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MISO pin of the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the SPI MISO line. </dd></dl>

</div>
</div>
<a id="ga5a1dd3972f11c2383927855a4daf5d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a1dd3972f11c2383927855a4daf5d89">&#9670;&nbsp;</a></span>spi_pin_mosi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> spi_pin_mosi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MOSI pin of the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the SPI MOSI line. </dd></dl>

</div>
</div>
<a id="ga9e36100f2b58917366872fca2f9f3bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e36100f2b58917366872fca2f9f3bc6">&#9670;&nbsp;</a></span>spi_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish an ongoing SPI transaction by releasing the given SPI bus. </p>
<p>After release, the given SPI bus should be fully powered down until acquired again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e2f58f7b719d1e8ac5cb05bdeed7c9b">&#9670;&nbsp;</a></span>spi_transfer_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spi_transfer_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a>&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer one byte on the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cont</td><td>if true, keep device selected after transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>byte to send out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the received byte </dd></dl>

</div>
</div>
<a id="gae6ca850b7cb6142b76deecb831357447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ca850b7cb6142b76deecb831357447">&#9670;&nbsp;</a></span>spi_transfer_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_transfer_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a>&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="msp430__types_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer a number bytes using the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cont</td><td>if true, keep device selected after transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>buffer to send data from, set NULL if only receiving </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in</td><td>buffer to read into, set NULL if only sending </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2593203a71900ff6d8346398bc5241a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2593203a71900ff6d8346398bc5241a1">&#9670;&nbsp;</a></span>spi_transfer_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spi_transfer_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a>&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer one byte to/from a given register address. </p>
<p>This function is a shortcut function for easier handling of SPI devices that implement a register based access scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to transfer data to/from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>byte to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value that was read from the given register address </dd></dl>

</div>
</div>
<a id="ga6577f294a7dd426badb3d69356bfc850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6577f294a7dd426badb3d69356bfc850">&#9670;&nbsp;</a></span>spi_transfer_regs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_transfer_regs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gac33db64063315b2b98b535051813ccea">spi_t</a>&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drivers__periph__spi.html#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a>&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="msp430__types_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer a number of bytes to/from a given register address. </p>
<p>This function is a shortcut function for easier handling of SPI devices that implement a register based access scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to transfer data to/from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>buffer to send data from, set NULL if only receiving </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in</td><td>buffer to read into, set NULL if only sending </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Jul 2 2020 17:48:23 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
