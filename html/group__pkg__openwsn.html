<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>OpenWSN network stack</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <!--BEGIN SEARCHENGINE hidden-sm hidden-xs"-->
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        displaySR();
                    }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event);
                              var r=document.getElementById('MSearchResultsWindow');
                              if(parseInt(r.style.left)<0)r.style.left=0;
                              var x=document.getElementById('MSearchResults');
                              if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                              var f=document.getElementById('riot-searchform');
                              if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__pkg__openwsn.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">OpenWSN network stack<div class="ingroups"><a class="el" href="group__pkg.html">Packages</a> &#124; <a class="el" href="group__net.html">Networking</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a RIOT adaption of the OpenWSN network stack.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides a RIOT adaption of the OpenWSN network stack. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/openwsn-berkeley/openwsn-fw">https://github.com/openwsn-berkeley/openwsn-fw</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><b class="text-danger">This feature is experimental!</b></dd></dl>
<h1>OpenWSN RIOT Port</h1>
<p>This implementation integrates the <a href="https://github.com/openwsn-berkeley/openwsn-fw">OpenWSN</a> full network stack (UDP, IPv6 (6LoWPAN), RPL, 6TiSCH) into RIOT.</p>
<p>It can be used instead of GNRC on supported 802.15.4 radios, and compared to GNRC, provides a full 6TiSCH implementation. It does not yet support RIOT's sock API, so applications will have to be written against OpenWSN's API.</p>
<p>This port provides a new RIOT "board" to the OpenWSN software. In this way RIOT's hardware abstraction connects to OpenWSN's interfaces.</p>
<p>The simple scheduling mechanism in OpenWSN is run in a RIOT thread with second highest priority after the radio thread (THREAD_PRIORITY_MAIN - 4).</p>
<p>The current port of OpenWSN currently needs a root node that works along an external tool that performs routing and handles join procedure: <a href="https://github.com/openwsn-berkeley/openvisualizer">Openvisualizer</a></p>
<h2>Joining a network</h2>
<p>The first thing a new mote will need to do is to find a network. On boot it will actively be listening for enhanced beacons. Once a beacon is received it will adjust its timers drift and synchronize with the network. Re-synchronization will be happening constantly to compensate for oscillator and timer drifts.</p>
<p>Once synchronized the node will need to join the network. OpenWSN uses CoJP <a href="https://datatracker.ietf.org/doc/draft-ietf-6tisch-minimal-security/">constrained join protocol</a> an the stack itself only handles Join Requests. The JRC (join registrar/coordinator, a central entity) is not running on the root node, but alongside it, in the <code>OpenVisualizer</code> external tool.</p>
<p>Once joined the device has the required keys to start listening to DIS (DODAG Information Solicitation) messages and to send DIO (DODAG Information Object) requests. Once it knows about the topology of the network it is able to send packets.</p>
<p>OpenWSN uses source routing. This means that unless the recipient of a packet is one of the parents in the RPL tree the packet will have to go up the tree to the root node. But in OpenWSN RPL implementation the node does not know how to route, instead it is <code>OpenVisualizer</code> which generates an SRH (Source Routing Header), attaches to the incoming packet and sends it down the tree.</p>
<h2>Hardware abstraction implementation</h2>
<p>Following, details about the implementation of selected hardware modules.</p>
<h3>sctimer</h3>
<p>The <code>sctimer</code> ("single compare timer") in OpenWSN is the lowest timer abstraction which is used by the higher layer timer module <code>opentimers</code>. In the end it is responsible for scheduling on the MAC layer. To enable low power energy modes, this timer usually uses the RTC (real time clock) or RTT (real time timer) module.</p>
<p>This port has two possible implementations or sctimer, one on top of periph_rtt and another on top of ztimer, <code>sctimer_rtt</code> and <code>sctimer_ztimer</code> respectively. If possible <code>ztimer</code> should be preferred, being a virtual timer it will allow RIOT applications/modules to use the low level RTT timer. But ztimer (any virtual timer) has some overhead which can be costly depending on the different platforms used, specially when <code>openserial</code> is required. More on this in openserial and Known Issues.</p>
<h4>sctimer_ztimer</h4>
<p>In order to get the most portable code, this implementation uses ztimer and defines a new <code><a class="el" href="structztimer__clock.html" title="ztimer device structure ">ztimer_clock</a></code> (<code>ZTIMER_32768</code>) that operates at 32768Khz to have a resolution of ~30usec/tick (same as OpenWSN).</p>
<p>When available <code>ZTIMER_32768</code> will be built on top of <code>periph_rtt</code> to get low power capabilities. If not it will be built on top of a regular timer. In either case it will be shifted up if the base frequency is lower than 32768Hz or frac if higher.</p>
<p>When next interrupt to schedule is already late, current time, implementations in OpenWSN directly trigger a hardware interrupt. Until able to trigger sw isr directly a callback is set 0 ticks in the future, which internally will be set to <code>now + RTT_MIN_OFFSET</code>.</p>
<h4>sctimer_rtt</h4>
<p>In order to reduce overhead this implementation uses bare RTT. It expects a RTT running at 32768Hz to have a resolution of ~30usec/tick (same as OpenWSN). If <code>RTT_FREQUENCY</code> is lower than 32768Hz then a simple time-division mechanism will be used to speed up the clock. This only works if <code>RTT_FREQUENCY</code> is 32768Hz/2.</p>
<p>When next interrupt to schedule is already late, current time, Implementations in OpenWSN directly trigger a hardware interrupt. Until able to trigger sw isr directly a callback is set <code>RTT_MIN_OFFSET</code> ticks in the future.</p>
<h3>radio</h3>
<p>The radio adaptation runs in its own thread with the highest priority (<code>THREAD_PRIORITY_MAIN - 4</code>) and maps to RIOT's <a class="el" href="structnetdev.html">netdev</a> API.</p>
<p>Hardware MAC layer features such as CSMA/CA, ACK handling and retransmissions are handled by OpenWSN, so the radio driver must support disabling AUTOACK and CSMA handling by the hardware. Frame filtering must as well be disabled.</p>
<p>The radio adaptation preloads the buffer so <code>NETOPT_PRELOADING</code> must be supported.</p>
<p>OpenWSN needs to be notified when a frame reception/transmission starts and when it ends. Therefore radio drivers need to support the following netdev events: </p><pre class="fragment">- `NETDEV_EVENT_RX_STARTED`
- `NETDEV_EVENT_TX_STARTED`
- `NETDEV_EVENT_RX_COMPLETE`
- `NETDEV_EVENT_TX_COMPLETE`
</pre><p>OpenWSN expects to recover crc information on every received frame even if it will simply drop frames with invalid crc. The stack can function correctly if radio drivers automatically drop frames with an invalid crc (i.e. the stack doesn't get notified about these frames).</p>
<h3>uart</h3>
<p>In RIOT, the first configured uart device is mapped to STDIO in most cases. In OpenWSN however, the <code>openserial</code> tool uses uart to feed external software running on a host computer such as <a href="https://github.com/openwsn-berkeley/openvisualizer">Openvisualizer</a>. To enable use of these tools, an uart adaptation is provided.</p>
<p>This is provided through the <code>openwsn_serial</code> (<code>openserial</code>) module. It will use the next available uart that is not used by STDIO (checking STDIO_UART_DEV). When multiple uart are available STDIO and <code>openserial</code> can be used in parallel. If <code>stdio_null</code> is used then <code>openserial</code> will use <code>STDIO_UART_DEV</code>, otherwise it will use the next available uart. e.g. If <code>STDIO_UART_DEV = <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(1)</a></code> <code>OPENWSN_UART_DEV = <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(0)</a></code> if there are uarts.</p>
<p>OpenWSN uart abstraction makes use of tx hardware interrupts to execute a previously registered callback after every byte is sent out. These interrupts are currently not defined in RIOT in a generic way, so instead a timer is set to fire shortly after a byte is written.</p>
<p>It uses <code>ztimer</code> to set the timer since it's already pulled in as a dependency.</p>
<h3>Openserial</h3>
<p>As was mentioned before any OpenWSN network will require a root node which is connected to an <code>OpenVisualizer</code> instance running on a host computer. Interaction between <code>OpenVisualizer</code> and the root-node is done over serial. As OpenWSN uses source routing, this means that ultimately all network traffic must go from the root node to <code>OpenVisualizer</code> and back.</p>
<p>OpenSerial uses software flow control (XonXoff) to turn off serial activity while time critical TSCH operation are ongoing. But software flow control can cause issues since delays in the serial pipe (either because of a remote connection, buffers, etc..) can lead to bytes being transmitted when one side is not yet ready.</p>
<p>Serial data is transmitted as High-Level Data Link Control (HDLC) frames. Since network traffic is tunneled through the serial pipe, in order to to have a stable connection these packets must not be lost. Packets can be lost in multiple ways but at the end it reduces to bytes being overridden in the uart reception buffer.</p>
<ol type="1">
<li>The last byte in an HDCL frame is received</li>
<li>Serial pipe delays hindering XonXoff operation</li>
<li>Interrupts are masked or higher/equal ISR are running</li>
</ol>
<ol type="1">
<li>When the last byte of a frame is received some parsing and handling of the frame occur. This takes some time and during that time OpenSerial can't handle more incoming bytes. This in practice limits the baudrate depending on the CPU's speed.</li>
<li>This can occur when a debugger/virtual-port might act as a buffer between the mote and the host, or when there is a latency in the connection (for example tcp connection to iotlab).</li>
<li><p class="startli">Since uart reception is interrupted based if the uart ISR is not serviced for too long then bytes start overriding each other in the reception buffer. In an application where only OpenWSN is running then there are 3 functions/operations that run in ISR or with disabled ISR.</p>
<p class="startli">(a) <code>opentimers_timer_callback</code> (OpenWSN timer abstraction callback) (b) <code>sctimer_setCompare</code> and <code>sctimer_readCounter</code> (c) <code>ztimer_handler</code></p>
</li>
</ol>
<p>(a) and (b) are closely related since <code>opentimers_timer_callback</code> will itself call <code>sctimer_setCompare</code> and <code>sctimer_readCounter</code>. And this itself will depend on <code>ztimer_set</code> and <code>ztimer_now</code> or <code>rtt_get_counter</code> or <code>rtt_set_alarm</code> execution time.</p>
<p>(c) is also related to (a) (b) since <code>ztimer_handler</code> will also call <code>opentimers_timer_callback</code> as well as the underlying <code>rtt</code> functions.</p>
<p>Since a 115200 baudrate means ~1byte every 10us, none of the above can take longer than that or bytes could be lost at that baudrate.</p>
<p>Because of the above mentioned reasons, it is preferable to use <code>sctimer_rtt</code> for the root node or "border router" on an OpenWSN network, since this reduces the likeliness of packets being lost. For non root nodes, OpenSerial only provides debugging information so no special care needs to be taken.</p>
<p>It is also recommended that the root node should act as a border router running only the OpenWSN stack to avoid other threads/ISR disrupting serial reception.</p>
<h2>Tested Platforms and Pin configurations</h2>
<p>So far, this has been successfully tested on <code>iotlab-m3</code>,<code>nucleo-f103</code> and <code>samr21-xpro</code>, all based on at86rf23x radios.</p>
<h3>Synchronization</h3>
<p>To join a network a node must first receive EB (enhanced beacons). Once an EB is received the node will be synchronized with the network. Synchronization times are not deterministic, they depend on the following:</p>
<p><code>SLOTFRAME_LENGTH*SLOTDURATION*P_CHANNEL*P_EB</code></p>
<p><code>SLOTFRAME_LENGTH</code> in OpenWSN is 101, and this port uses 20ms as the slotOffset duration. <code>P_EB</code> specifies the a probability for a node to transmit an EB. By default it's 10%, that means that on average it will take 10 tries before an EB is transmitted. <code>P_CHANNEL</code> is the probability for the transmitter's and receiver channel to match. If channel hopping is disabled this means that the average worst case scenario is <code>101*20ms*10 ~= 20s</code>, so 20s for synchronization to take place. <code>EB_PORTION</code> can be changed to increase the likelihood of EB to be sent. This can also be achieved by reducing <code>SLOTFRAME_LENGTH</code>, but the later can have an impact on the MSF (Minimal Scheduling Function). If too few cells are available this could increase the likelihood of collisions.</p>
<p>On the other hand if channel hopping is enabled then the joining node picks a random channel to start listening on. The transmitter also picks a random channel to start transmitting on and then follows a channel hopping template. This would take on average ~8 tries for it to hit the correct channel for the first time, and then it would hit it every 16 hops, on average this could lead synchronization times of around <code>320s</code>.</p>
<p>If nodes are having trouble in staying synchronized increasing <code>P_EB</code> by reducing the value of <code>EB_PORTION</code> can also be done. Note that <code>EB_PORTION</code> and <code>SLOTFRAME_LENGTH</code> are not configurable by default so need to be overridden with <code>CFLAGS</code>.</p>
<h3>Timing</h3>
<p>Timing is essential for OpenWSN to work properly. For optimal results most parameters in <code><a class="el" href="board__info_8h.html">board_info.h</a></code> should be measured for the specific hardware used. OpenWSN has done that for most of their boards. These values can not be taken directly from OpenWSN since they do not necessarily use the same TIMER's or clock speeds.</p>
<p>For more details on those parameters refer to: <a href="https://openwsn.atlassian.net/wiki/spaces/OW/pages/688251/State+Machine">https://openwsn.atlassian.net/wiki/spaces/OW/pages/688251/State+Machine</a></p>
<p>Since all these parameters are HW dependent, it also means that hybrid networks (different type of underlying hardware) might desynchronize often, or not manage to keep in sync at all.</p>
<p>Print messages during TSCH operation should be avoided since these can disrupt TSCH timings.</p>
<h3>ledpins &amp; debugpins</h3>
<p>The OpenWSN software provides different hooks all over the stack to toggle different LEDs as well as debug pins to examine state and scheduling of a node. Default configuration files are provided for both. The LED configuration maps to RIOTs <code>LEDX_PIN</code> definitions, if available. On Nucleo boards LED0 line is shared SPI, so is not used.</p>
<p>The default configuration can be overwritten by setting <code>OPENWSN_LEDS_DEFAULT</code> in the form of <code>leds_config_t</code>. The debugpins work similarly by setting <code>OPENWSN_DEBUGPINS_BOARD</code> in the form of <code>debugpins_config_t</code>.</p>
<p>The default configuration maps to OpenWSN reference hardware <code>openmote-b</code>.</p>
<h2>Testing and debugging</h2>
<p>List of some items which are helpful to explore the functionality of OpenWSN:</p>
<ul>
<li>LED pins and debug pins as mentioned above in combination with a logic analyzer. The expected behavior is described in: <a href="https://openwsn.atlassian.net/wiki/spaces/OW/pages/688257/Schedules">OpenWSN wiki</a>.</li>
<li>The provided test application provides a UDP client and server. If the UDP server is able to receive packets, the mechanism is considered to work correctly. You should also be able to ping the device from your host. See <code>tests/pkg_openwsn/README.md</code> for more details.</li>
<li>To speed up synchronization and make sniffing easier you can disable channel hopping by setting (<code>CFLAGS=-DIEEE802154E_SINGLE_CHANNEL=26</code>).</li>
<li>To sniff the packets either use a 802.15.4 capable board and follow at: <a href="https://github.com/RIOT-OS/applications/blob/master/sniffer/tools/README.md">https://github.com/RIOT-OS/applications/blob/master/sniffer/tools/README.md</a>. Alternatively use a Raspberry Pi with an external radio such as Openlabs and incorporate Linux WPAN tools. In addition to that, there's also other hardware such as the ATUSB IEEE 802.15.4 USB Adapter which can directly be used on your Linux computer with WPAN tools installed. If you conduct your experiments on the IoT-LAB testbed you might want to use a: <a href="https://www.iot-lab.info/tutorials/radio-sniffer">sniffer profile</a>.</li>
<li>To explore the channel hopping mechanism there are rather expensive multi-channel sniffers such as the BeamLogic 802.15.4 Site Analyzer that can sniff all channels simultaneously. Alternatively you can set up multiple separate sniffer devices locally or make use of the <code>sniffer_aggregator</code> on the IoT-LAB testbed.</li>
<li><p class="startli">To test Openserial on a given platform the target <code>make openv-serial</code> can be used on a BOARD flashed with <code>tests/pkg_openwsn</code> (<code>USEMODULE=openwsn_serial</code>) must be included as well. The following output should appear:</p>
<p class="startli">``` </p><h2>Test Setup: </h2>
<p class="startli">Iterations: 100 Packet length: 100 Echo timeout: 2</p>
<p class="startli">Test Progress:</p>
<p class="startli">[####################################] 100%</p>
</li>
</ul>
<h2>Test Statistics: </h2>
<p>Pkts send: 100 Echo success: 100 Echo timeout: 0 Echo corrupted: 0 ```</p>
<p>The test should be considered passing if success rate is &gt; 98%.</p>
<h2>Known Issues</h2>
<p>The following errors might be visible when using <code>openwsn_serial</code>:</p>
<ul>
<li><code>[OPENSERIAL] wrong CRC in input Buffer</code></li>
</ul>
<p>Since a timer is set to simulate a uart transmit interrupt, it can happen that the interrupt is missed if another interrupt occurs during that time, this seems to lead to the input buffer missing a byte and so CRC fails. More details where given in the <code>openserial</code> section.</p>
<ul>
<li><code>[IEEE802154E] wdDataDuration overflows while at state 19 in slotOffset 0</code></li>
</ul>
<p>This error can show up when the radio starts receiving (receives the SFD) and therefore triggers a <code>NETDEV_RX_STARTED</code> but then no <code>NETDEV_TX_STARTED</code> event follows. This happens when packets with invalid CRC are received. netdev currently silently drops these packets without notifying upper layers. But this does not affect the stack operation, so they can be ignored.</p>
<ul>
<li><code>[IEEE802154E] large timeCorr.: -18 ticks (code loc. 0)</code></li>
</ul>
<p>Most crystals used to clock the RTT will drift even those with a very similarly drift (10-30ppm). It's is normal then for motes adjust their timerCorr as long as it stays within the above mentioned margins and if motes are able to stay synchronized over the long run. If there aren't then maybe <a class="el" href="board__info_8h.html">board_info.h</a> parameters require tuning for the specific platform.</p>
<ul>
<li><code>[JRC:ERROR] Type-error in conversion of 5N=ex</code></li>
</ul>
<p>This errors happen when a node tries to rejoin the network. This error is only associated to a log print, so can be ignored.</p>
<ul>
<li><code>[coap:WARNING] coapRcBadRequest(reason=OSCOAP unprotect failed: oscoapError(reason=Replay protection failed))</code></li>
</ul>
<p>The join procedure uses a replay window. If a node had already joined the network and for some reason attempts to rejoin again, then the replay windows will need to expire for it's join request to be accepted.</p>
<p>The following errors are platform specific.</p>
<ul>
<li>samr21-xpro issues:<ul>
<li>The serial debugger hinders Openserial operation, an ftdi device must be used.</li>
</ul>
</li>
<li>sam0 issues:<ul>
<li>sam0 requires 180us busy loops every time an alarm is set or the counter is read. Because of the later only <code>sctimer_rtt</code> can be used and the max. tested baudrate for openserial is of 19200 bauds.</li>
</ul>
</li>
<li>iotlab-m3 issues:<ul>
<li>openserial does not work reliably over 57600 bauds or when using sctimer_ztimer.</li>
</ul>
</li>
</ul>
<p>Other errors:</p>
<ul>
<li>missed characters over stdio</li>
</ul>
<p>TSCH state machine disable occurs in IRQ context and disables IRQ during time critical sections. This can cause bytes sent over stdio to be missed.</p>
<h2>Todos</h2>
<ul>
<li><code>sctimer</code> to trigger an ISR immediately using software interrupts.</li>
<li><code>RTT_FREQUENCY</code> is not configurable for most platforms, implementations should be adapted to make this configurable to be able to set <code>RTT_FREQUENCY</code> to 32768Hz or the closer possible value.</li>
<li>The UART wrapper uses ztimer to fake an interrupt after one byte has been sent. This should also be done with software interrupts.</li>
</ul>
<h2>Future Steps</h2>
<p>The OpenWSN community is working on refactoring their code base. As one of the outputs of this modules like <code>cjoin</code>, <code>udp</code>, <code>coap</code> will become optional. Once this is upstream the support for this pkg should be adapted.</p>
<p>With above mentioned re-works the extraction of the MAC layer might be favored.</p>
<p>As more immediate future steps:</p>
<ul>
<li>Follow up PR to add OpenWSN sock</li>
<li>Complete support of OpenWSN default HW (<code>openmote-b</code>)</li>
<li>Add support for other 802.15.4 network drivers </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:board__info_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="board__info_8h.html">board_info.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn_8h.html">openwsn.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn__board_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__board_8h.html">openwsn_board.h</a></td></tr>
<tr class="memdesc:openwsn__board_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RIOT HAL is provided as a new "board", a "RIOT board" to OpenWSN hardware abstraction interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn__debugpins_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__debugpins_8h.html">openwsn_debugpins.h</a></td></tr>
<tr class="memdesc:openwsn__debugpins_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an adaption of OpenWSN debug pin handling to RIOTs handling of GPIOs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn__debugpins__params_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__debugpins__params_8h.html">openwsn_debugpins_params.h</a></td></tr>
<tr class="memdesc:openwsn__debugpins__params_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default configuration for the OpenWSN debugpins. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn__leds_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__leds_8h.html">openwsn_leds.h</a></td></tr>
<tr class="memdesc:openwsn__leds_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an adaption of OpenWSN led handling to RIOTs handling of LEDs and/or GPIOs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn__leds__params_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__leds__params_8h.html">openwsn_leds_params.h</a></td></tr>
<tr class="memdesc:openwsn__leds__params_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default configuration for the OpenWSN leds. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn__radio_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__radio_8h.html">openwsn_radio.h</a></td></tr>
<tr class="memdesc:openwsn__radio_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RIOT adaption of the "radio" bsp module definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:openwsn__uart_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__uart_8h.html">openwsn_uart.h</a></td></tr>
<tr class="memdesc:openwsn__uart_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">For details on the implementation check pkg/openwsn/doc.txt. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Fri Jul 3 2020 13:27:55 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
