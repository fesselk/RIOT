<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>ESP32</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right"
                    onsubmit="try{
                        displaySR();
                    }finally{
                            return false;
                    }">
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__cpu__esp32.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">ESP32<div class="ingroups"><a class="el" href="group__cpu.html">CPU</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation for Espressif ESP32 MCUs.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation for Espressif ESP32 MCUs. </p>
<dl class="section author"><dt>Author</dt><dd>Gunar Schorcht <a href="#" onclick="location.href='mai'+'lto:'+'gun'+'ar'+'@sc'+'ho'+'rch'+'t.'+'net'; return false;">gunar<span style="display: none;">.nosp@m.</span>@sch<span style="display: none;">.nosp@m.</span>orcht<span style="display: none;">.nosp@m.</span>.net</a></dd></dl>
<h1><a class="anchor" id="esp32_riot"></a>
RIOT-OS on ESP32 boards</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
&lt;a name="esp32_toc"&gt; Table of Contents &lt;/a&gt;</h2>
<ol type="1">
<li><a href="#esp32_overview">Overview</a></li>
<li><a href="#esp32_short_configuration_reference">Short Configuration Reference</a></li>
<li><a href="#esp32_mcu_esp32">MCU ESP32</a><ol type="a">
<li><a href="#esp32_features">Features of ESP32</a></li>
<li><a href="#esp32_supported_features">Features Supported by RIOT-OS</a></li>
<li><a href="#esp32_limitations">Limitations of the RIOT-port</a></li>
</ol>
</li>
<li><a href="#esp32_toolchain">Toolchain</a><ol type="a">
<li><a href="#esp32_riot_docker_toolchain">RIOT Docker Toolchain (riotdocker)</a></li>
<li><a href="#esp32_manual_toolchain_installation">Manual Toolchain Installation</a></li>
</ol>
</li>
<li><a href="#esp32_flashing_the_device">Flashing the Device</a><ol type="a">
<li><a href="#esp32_toolchain_usage">Toolchain Usage</a></li>
<li><a href="#esp32_compile_options">Compile Options</a></li>
<li><a href="#esp32_flash_modes">Flash Modes</a></li>
<li><a href="#esp32_esp_idf_heap_implementation">ESP-IDF Heap Implementation</a></li>
</ol>
</li>
<li><a href="#esp32_peripherals">Common Peripherals</a><ol type="a">
<li><a href="#esp32_gpio_pins">GPIO pins</a></li>
<li><a href="#esp32_adc_channels">ADC Channels</a></li>
<li><a href="#esp32_dac_channels">DAC Channels</a></li>
<li><a href="#esp32_i2c_interfaces">I2C Interfaces</a></li>
<li><a href="#esp32_pwm_channels">PWM Channels</a></li>
<li><a href="#esp32_spi_interfaces">SPI Interfaces</a></li>
<li><a href="#esp32_timers">Timers</a></li>
<li><a href="#esp32_rtt_counter">RTT Implementation</a></li>
<li><a href="#esp32_uart_interfaces">UART Interfaces</a></li>
<li><a href="#esp32_can_interfaces">CAN Interfaces</a></li>
<li><a href="#esp32_power_management">Power Management</a></li>
<li><a href="#esp32_other_peripherals">Other Peripherals</a></li>
</ol>
</li>
<li><a href="#esp32_special_on_board_peripherals">Special On-board Peripherals</a><ol type="a">
<li><a href="#esp32_spi_ram">SPI RAM Modules</a></li>
<li><a href="#esp32_spiffs_device">SPIFFS Device</a></li>
</ol>
</li>
<li><a href="#esp32_network_interfaces">Network Interfaces</a><ol type="a">
<li><a href="#esp32_ethernet_network_interface">Ethernet MAC Network Interface</a></li>
<li><a href="#esp32_wifi_network_interface">WiFi Network Interface</a></li>
<li><a href="#esp32_wifi_ap_network_interface">WiFi SoftAP Network Interface</a></li>
<li><a href="#esp32_esp_now_network_interface">ESP-NOW Network Interface</a></li>
<li><a href="#esp32_other_network_devices">Other Network Devices</a></li>
</ol>
</li>
<li><a href="#esp32_application_specific_configurations">Application-Specific Configurations</a><ol type="a">
<li><a href="#esp32_config_make_variable">Make Variable <code>CONFIGS</code></a></li>
<li><a href="#esp32_application_specific_board_configuration">Application-Specific Board Configuration</a></li>
<li><a href="#esp32_application_specific_driver_configuration">Application-Specific Driver Configuration</a></li>
</ol>
</li>
<li><a href="#esp32_debugging">Debugging</a><ol type="a">
<li><a href="#esp32_jtag_debugging">JTAG Debugging</a></li>
<li><a href="#esp32_qemu_mode_and_gdb">QEMU Mode and GDB</a></li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md26"></a>
&lt;a name="esp32_overview"&gt; Overview &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<p><b>RIOT-Xtensa-ESP</b> is a bare metal implementation of <b>RIOT-OS</b> for <b>ESP32</b> SOCs which supports most features of RIOT-OS. The peripheral SPI and I2C interfaces allow to connect all external hardware modules supported by RIOT-OS, such as sensors and actuators. SPI interface can also be used to connect external IEEE802.15.4 modules to integrate ESP32 boards into a GNRC network.</p>
<p>Although the port does not use the official <b>ESP-IDF</b> (Espresso IoT Development Framework) SDK, it must be installed for compilation. The reason is that the port uses most of the <b>ESP32 SOC definitions</b> provided by the ESP-IDF header files. In addition, it needs the hardware abstraction library (libhal), and the <b>ESP32 WiFi stack binary</b> libraries which are part of the ESP-IDF SDK.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
&lt;a name="esp32_short_configuration_reference"&gt; Short Configuration Reference &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<p>The following table gives a short reference of all board configuration parameters used by the ESP32 port in alphabetical order.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter </th><th class="markdownTableHeadNone">Short Description </th><th class="markdownTableHeadNone">Type*  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_adc_channels">ADC_GPIOS</a> </td><td class="markdownTableBodyNone">GPIOs that can be used as ADC channels </td><td class="markdownTableBodyNone">m  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_can_interfaces">CAN_TX</a> </td><td class="markdownTableBodyNone">GPIO used as CAN transceiver TX signal </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_can_interfaces">CAN_RX</a> </td><td class="markdownTableBodyNone">GPIO used as CAN transceiver RX signal </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_adc_channels">DAC_GPIOS</a> </td><td class="markdownTableBodyNone">GPIOs that can be used as DAC channels </td><td class="markdownTableBodyNone">m  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_i2c_interfaces">I2C0_SPEED</a> </td><td class="markdownTableBodyNone">Bus speed of <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(0)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_i2c_interfaces">I2C0_SCL</a> </td><td class="markdownTableBodyNone">GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(0)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_i2c_interfaces">I2C0_SDA</a> </td><td class="markdownTableBodyNone">GPIO used as SCL for I2C_DEV(0 </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_i2c_interfaces">I2C1_SPEED</a> </td><td class="markdownTableBodyNone">Bus speed of <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_i2c_interfaces">I2C1_SCL</a> </td><td class="markdownTableBodyNone">GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_i2c_interfaces">I2C1_SDA</a> </td><td class="markdownTableBodyNone">GPIO used as SCL for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_pwm_channels">PWM0_GPIOS</a> </td><td class="markdownTableBodyNone">GPIOs that can be used at channels of <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(0)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_pwm_channels">PWM1_GPIOS</a> </td><td class="markdownTableBodyNone">GPIOs that can be used at channels of <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI0_CTRL</a> </td><td class="markdownTableBodyNone">SPI Controller used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a>, can be <code>VSPI</code> <code>HSPI</code> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI0_SCK</a> </td><td class="markdownTableBodyNone">GPIO used as SCK for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI0_MOSI</a> </td><td class="markdownTableBodyNone">GPIO used as MOSI for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI0_MISO</a> </td><td class="markdownTableBodyNone">GPIO used as MISO for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI0_CS0</a> </td><td class="markdownTableBodyNone">GPIO used as default CS for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI1_CTRL</a> </td><td class="markdownTableBodyNone">SPI Controller used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(1)</a>, can be <code>VSPI</code> <code>HSPI</code> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI1_SCK</a> </td><td class="markdownTableBodyNone">GPIO used as SCK for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI1_MOSI</a> </td><td class="markdownTableBodyNone">GPIO used as MOSI for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI1_MISO</a> </td><td class="markdownTableBodyNone">GPIO used as MISO for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_spi_interfaces">SPI1_CS0</a> </td><td class="markdownTableBodyNone">GPIO used as default CS for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_uart_interfaces">UART1_TXD</a> </td><td class="markdownTableBodyNone">GPIO used as TxD for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_uart_interfaces">UART1_RXD</a> </td><td class="markdownTableBodyNone">GPIO used as RxD for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_uart_interfaces">UART2_TXD</a> </td><td class="markdownTableBodyNone">GPIO used as TxD for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(2)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_uart_interfaces">UART2_RXD</a> </td><td class="markdownTableBodyNone">GPIO used as RxD for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(2)</a> </td><td class="markdownTableBodyNone">o  </td></tr>
</table>
</center><center></center><p><b>*Type:</b> m - mandatory, o - optional</p>
<p>The following table gives a short reference in alphabetical order of modules that can be enabled/disabled by board configurations and/or application's makefile using <code>USEMODULE</code> and <code>DISABLE_MODULE</code>.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Module </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Short description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_ethernet_network_interface">esp_eth</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable the Ethernet MAC (EMAC) network device  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_debugging">esp_gdb</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable the compilation with debug information for debugging  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_timers">esp_hw_counter</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">use hardware counters for RIOT timers  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_i2c_interfaces">esp_i2c_hw</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">use the i2C hardware implementation  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_esp_idf_heap_implementation">esp_idf_heap</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable ESP-IDF heap implementation  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_esp_log_module">esp_log_colored</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable colored log output  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_esp_log_module">esp_log_startup</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable additional startup information  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_esp_log_module">esp_log_tagged</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">add additional information to the log output  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_esp_now_network_interface">esp_now</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable the ESP-NOW network device  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_rtt_counter">esp_rtc_timer_32k</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">use RTC timer with external 32.768 kHz crystal as RTT  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_spi_ram">esp_spi_ram</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable SPI RAM  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_spiffs_device">esp_spiffs</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable SPIFFS for on-board flash memory  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_wifi_network_interface">esp_wifi</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable the Wifi network device in WPA2 personal mode  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="#esp32_wifi_ap_network_interface">esp_wifi_ap</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable the WiFi SoftAP network device  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="#esp32_wifi_network_interface">esp_wifi_enterprise</a> </td><td class="markdownTableBodyNone">not used </td><td class="markdownTableBodyNone">enable the Wifi network device in WPA2 enterprise mode  </td></tr>
</table>
</center><center></center><h1><a class="anchor" id="autotoc_md28"></a>
&lt;a name=esp32_mcu_esp32&gt; MCU ESP32 &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<p>ESP32 is a low-cost, ultra-low-power, single or dual-core SoCs from Espressif Systems with integrated WiFi and dual-mode BT module. The processor core is based on the Tensilica Xtensa LX6 32-bit Controller Processor Core.</p>
<p><a class="anchor" id="esp32_mcu"></a></p>
<h2><a class="anchor" id="autotoc_md29"></a>
&lt;a name=esp32_features&gt; Features of ESP32 &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The key features of ESP32 are:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">MCU </th><th class="markdownTableHeadNone">ESP32 </th><th class="markdownTableHeadNone">Supported by RIOT  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Vendor </td><td class="markdownTableBodyNone">Espressif </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Cores </td><td class="markdownTableBodyNone">1 or 2 x Tensilica Xtensa LX6 </td><td class="markdownTableBodyNone">1 core  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FPU </td><td class="markdownTableBodyNone">ULP - Ultra low power co-processor </td><td class="markdownTableBodyNone">no  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RAM </td><td class="markdownTableBodyNone">520 kByte SRAM <br  />
 8 kByte slow RTC SRAM <br  />
 8 kByte fast RTC SRAM </td><td class="markdownTableBodyNone">yes <br  />
 yes <br  />
 yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ROM </td><td class="markdownTableBodyNone">448 kByte </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Flash </td><td class="markdownTableBodyNone">512 kByte ... 16 MByte </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Frequency </td><td class="markdownTableBodyNone">240 MHz, 160 MHz, 80 MHz </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Power Consumption </td><td class="markdownTableBodyNone">68 mA @ 240 MHz <br  />
 44 mA @ 160 MHz (34 mA @ 160 MHz single core) <br  />
 31 mA @ 80 MHz (25 mA @ 80 MHz single core) <br  />
 800 uA in light sleep mode <br  />
 10 uA in deep sleep mode </td><td class="markdownTableBodyNone">yes <br  />
 yes <br  />
 yes <br  />
 yes <br  />
 yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Timers </td><td class="markdownTableBodyNone">4 x 64 bit </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ADCs </td><td class="markdownTableBodyNone">2 x SAR-ADC with up to 18 x 12 bit channels total </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DACs </td><td class="markdownTableBodyNone">2 x DAC with 8 bit </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIOs </td><td class="markdownTableBodyNone">34 (6 are only inputs, 18 are RTC GPIOs) </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">I2Cs </td><td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SPIs </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">yes (2)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">UARTs </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WiFi </td><td class="markdownTableBodyNone">IEEE 802.11 b/g/n built in </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Bluetooth </td><td class="markdownTableBodyNone">v4.2 BR/EDR and BLE </td><td class="markdownTableBodyNone">no  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Ethernet </td><td class="markdownTableBodyNone">MAC interface with dedicated DMA and IEEE 1588 support </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CAN </td><td class="markdownTableBodyNone">version 2.0 </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IR </td><td class="markdownTableBodyNone">up to 8 channels TX/RX </td><td class="markdownTableBodyNone">no  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Motor PWM </td><td class="markdownTableBodyNone">2 devices x 6 channels </td><td class="markdownTableBodyNone">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LED PWM </td><td class="markdownTableBodyNone">16 channels </td><td class="markdownTableBodyNone">no  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Crypto </td><td class="markdownTableBodyNone">Hardware acceleration of AES, SHA-2, RSA, ECC, RNG </td><td class="markdownTableBodyNone">no  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Vcc </td><td class="markdownTableBodyNone">2.5 - 3.6 V </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Documents </td><td class="markdownTableBodyNone"><a href="https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf">Datasheet</a> <br  />
 <a href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf">Technical Reference</a> </td><td class="markdownTableBodyNone"></td></tr>
</table>
</center><center></center><p><br  />
</p>
<dl class="section note"><dt>Note</dt><dd>Even if used ESP32 SoC is a dual-core version, RIOT-OS uses only one core.</dd></dl>
<p>Rather than using the ESP32 SoC directly, ESP32 boards use an <a href="https://www.espressif.com/en/products/hardware/modules">ESP32 module from Espressif</a> which integrates additionally to the SoC some key components, like SPI flash memory, SPI RAM, or crystal oscillator. Some of these components are optional. A good overview about available modules can be found in the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/hw-reference/modules-and-boards.html#wroom-solo-and-wrover-modules">Online documentation of ESP-IDF</a>.</p>
<p>Most common modules used by ESP32 boards are the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/hw-reference/modules-and-boards.html#esp32-wroom-32">ESP32-WROOM-32</a> and <a href="https://docs.espressif.com/projects/esp-idf/en/latest/hw-reference/modules-and-boards.html#esp32-wrover">ESP32-WROVER</a>.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
&lt;a name="esp32_supported_features"&gt; Features Supported by RIOT-OS &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The RIOT-OS for ESP32 SoCs supports the following features at the moment:</p>
<ul>
<li>I2C interfaces</li>
<li>SPI interfaces</li>
<li>UART interfaces</li>
<li>CAN interface</li>
<li>CPU ID access</li>
<li>RTC module</li>
<li>ADC and DAC channels</li>
<li>PWM channels</li>
<li>SPI RAM</li>
<li>SPI Flash Drive (MTD with SPIFFS and VFS)</li>
<li>Layered Power Management</li>
<li>Hardware number generator</li>
<li>Hardware timer devices</li>
<li>ESP-NOW netdev interface</li>
<li>ESP Ethernet MAC (EMAC) netdev interface</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
&lt;a name="esp32_limitations"&gt; Limitations of the RIOT port &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The implementation of RIOT-OS for ESP32 SOCs has the following limitations at the moment:</p>
<ul>
<li>Only <b>one core</b> (the PRO CPU) is used because RIOT does not support running multiple threads simultaneously.</li>
<li><b>Bluetooth</b> cannot be used at the moment.</li>
<li><b>Flash encryption</b> is not yet supported.</li>
</ul>
<h1><a class="anchor" id="autotoc_md32"></a>
&lt;a name="esp32_toolchain"&gt; Toolchain &lt;a&gt;</h1>
<p>Following software components are required for compilation:</p>
<ul>
<li><b>Xtensa GCC</b> compiler suite for ESP32</li>
<li><b>ESP-IDF</b> SDK which includes all ESP32 SOC definitions, basic libraries and the hardware abstraction library <b><code>libhal.a</code></b></li>
</ul>
<p>There are two options to install the Toolchain:</p>
<ul>
<li><b>riotdocker</b> image, see section <a href="#esp32_riot_docker_toolchain">RIOT Docker Toolchain (riotdocker)</a></li>
<li><b>manual installation</b>, see section <a href="#esp32_manual_toolchain_installation">Manual Toolchain Installation</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
&lt;a name="esp32_riot_docker_toolchain"&gt; RIOT Docker Toolchain (riotdocker) &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The easiest way to use install the toolchain is the RIOT Docker image <code>riotdocker</code>. The compilation process using Docker consists of two steps</p>
<ol type="1">
<li>making the RIOT application in Docker with command <code>make BOARD= ...</code></li>
<li>flashing the RIOT application on the host computer with command <code>make flash-only BOARD=...</code></li>
</ol>
<p>where step 2 requires that the ESP flash programmer <code>esptool.py</code> is installed. Both steps can also be performed with a single command on the host system using the <code>BUILD_IN_DOCKER</code> variable: </p><div class="fragment"><div class="line">BUILD_IN_DOCKER=1 make BOARD=... flash</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md34"></a>
&lt;a name="esp32_preparing_the_environment"&gt; Preparing the Environment &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>Using RIOT Docker requires at least the following software:</p>
<ul>
<li><b><code>Docker</code></b> container virtualization software</li>
<li>RIOT Docker (<b><code>riotdocker</code></b>) image</li>
<li>ESP flash programmer tool <b><code>esptool.py</code></b></li>
</ul>
<p>For information about installing Docker on your host, refer to the appropriate manuals for your operating system. For example, the easiest way to install Docker on the Ubuntu/Debian system is: </p><div class="fragment"><div class="line">sudo apt-get install docker.io</div>
</div><!-- fragment --><p>For information on how to install <code>esptool.py</code>, see section <a href="#esp32_installation_of_esptool">Installation of <code>esptool.py</code></a>.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
&lt;a name="esp32_generating_docker_image"&gt; Generating a riotdocker Image &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>A <code>riotdocker</code> fork that only installs the <code>RIOT-Xtensa-ESP32-toolchain</code> is available at <a href="https://github.com/gschorcht/riotdocker-Xtensa-ESP.git">GitHub</a>. After cloning this git repository, you can use branch <code>esp32_only</code> to generate a Docker image with a size of "only" 990 MByte:</p>
<div class="fragment"><div class="line">git clone https:<span class="comment">//github.com/gschorcht/riotdocker-Xtensa-ESP.git</span></div>
<div class="line">cd riotdocker-Xtensa-ESP</div>
<div class="line">git checkout esp32_only</div>
<div class="line">docker build -t riotbuild .</div>
</div><!-- fragment --><p>A <code>riotdocker</code> version that contains the toolchains for all different RIOT platforms can be found at <a href="https://github.com/RIOT-OS/riotdocker">GitHub</a>. However, the Docker image generated from the this Docker file has a size of about 1.5 GByte.</p>
<p>Once a Docker image has been created, it can be started with the following commands while in the RIOT root directory: </p><div class="fragment"><div class="line">cd /path/to/RIOT</div>
<div class="line">docker run -i -t --privileged -v /dev:/dev -u $UID -v $(pwd):/data/riotbuild riotbuild</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>RIOT's root directory <code>/path/to/RIOT</code> becomes visible as the home directory of the <code>riotbuild</code> user in the Docker image. That is, the output of compilations performed in RIOT Docker is also accessible on the host system.</dd></dl>
<p>Please refer the <a href="https://github.com/RIOT-OS/RIOT/wiki/Use-Docker-to-build-RIOT">RIOT wiki</a> on how to use the Docker image to compile RIOT OS.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
&lt;a name="esp32_using_existing_docker_image"&gt; Using an Existing riotdocker Image &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>Alternatively, an existing Docker image from Docker Hub can be used. You can either pull and start the <a href="https://hub.docker.com/r/schorcht/riotbuild_esp32">schorcht/riotbuild_esp32</a> Docker image which only contains the <code>RIOT-Xtensa-ESP32-toolchain</code> using </p><div class="fragment"><div class="line">cd /path/to/RIOT</div>
<div class="line">docker run -i -t --privileged -v /dev:/dev -u $UID -v $(pwd):/data/riotbuild schorcht/riotbuild_esp32</div>
</div><!-- fragment --><p>or the <a href="https://hub.docker.com/r/riot/riotbuild/">riot/riotbuild</a> Docker image (size is about 1.5 GB) which contains the toolchains for all platforms using </p><div class="fragment"><div class="line">cd /path/to/RIOT</div>
<div class="line">docker run -i -t --privileged -v /dev:/dev -u $UID -v $(pwd):/data/riotbuild riot/riotbuild</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md37"></a>
&lt;a name="esp32_flashing_using_docker"&gt; Make Process with Docker Image &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>Using Docker, the make process consists of the following two steps:</p>
<ol type="1">
<li><b>making</b> the RIOT binary <b>within a RIOT Docker image</b></li>
<li><b>flashing</b> the RIOT binary using a flasher program <b>on the host system</b></li>
</ol>
<p>Once the RIOT Docker image has been started from RIOT's root directory, a RIOT application can be compiled inside the Docker using the make command as usual, for example:</p>
<div class="fragment"><div class="line">make BOARD=esp32-esp-12x -C tests/shell ...</div>
</div><!-- fragment --><p>This will generate a RIOT binary in ELF format.</p>
<dl class="section note"><dt>Note</dt><dd>You can't use the <code>flash</code> target inside the Docker image.</dd></dl>
<p>The RIOT binary has to be flash outside docker on the host system. Since the Docker image was stared while in RIOT's root directory, the output of the compilations is also accessible on the host system. On the host system, the <code>flash-only</code> target can then be used to flash the binary. </p><div class="fragment"><div class="line">make flash-only BOARD=esp32-esp-12x -C tests/shell</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md38"></a>
&lt;a name="esp32_manual_toolchain_installation"&gt; Manual Toolchain Installation &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>A more difficult way to install the toolchain is the manual installation of required components as described below.</p>
<dl class="section note"><dt>Note</dt><dd>To use the precompiled toolchain the following packages (Debian/Ubuntu) have to be installed:<br  />
 <code>build-essential</code> <code>cppcheck</code> <code>coccinelle</code> <code>curl</code> <code>doxygen</code> <code>git</code> <code>graphviz</code> <code>make</code> <code>pcregrep</code> <code>python</code> <code>python-serial</code> <code>python3</code> <code>python3-flake8</code> <code>unzip</code> <code>wget</code></dd></dl>
<h3><a class="anchor" id="autotoc_md39"></a>
&lt;a name="esp32_installation_of_xtensa_gcc"&gt; Installation of Xtensa GCC compiler suite &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>Xtensa GCC compiler for ESP32 can be downloaded and installed as precompiled binary archive from GitHub.</p>
<div class="fragment"><div class="line">mkdir -p $HOME/esp</div>
<div class="line">cd $HOME/esp</div>
<div class="line">git clone https:<span class="comment">//github.com/gschorcht/xtensa-esp32-elf.git</span></div>
</div><!-- fragment --><p>Once the compiler is installed you can add the binary directory to your <code>PATH</code> variable. </p><div class="fragment"><div class="line">export PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md40"></a>
&lt;a name="esp32_installation_of_esp_idf"&gt; Installation of ESP-IDF (Espressif IoT Development Framework) &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>ESP-IDF, the official SDK from Espressif, can be downloaded and installed as GIT repository.</p>
<div class="fragment"><div class="line">cd $HOME/esp</div>
<div class="line">git clone https:<span class="comment">//github.com/espressif/esp-idf.git</span></div>
<div class="line">cd esp-idf</div>
<div class="line">git checkout f198339ec09e90666150672884535802304d23ec</div>
<div class="line">git submodule init</div>
<div class="line">git submodule update</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Please take care to checkout correct branches which were used for the port. Newer versions might also work but were not tested.</dd></dl>
<p>Since we only use a few header files, ESP-IDF does not need to be compiled in any way. To use the installed ESP-IDF, just set the variable <code>ESP32_SDK_DIR</code> accordingly. </p><div class="fragment"><div class="line">export ESP32_SDK_DIR=$HOME/esp/esp-idf</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md41"></a>
&lt;a name="esp32_installation_of_esptool"&gt; Installation of &lt;tt&gt;esptool.py&lt;/tt&gt; (ESP flash programmer tool) &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>The RIOT port does not work with the <code>esptool.py</code> ESP flasher program available on <a href="https://github.com/espressif/esptool">GitHub</a> or as a package for your OS. Instead, a modified version is required.</p>
<p>To avoid the installation of the complete ESP-IDF SDK, for example, because RIOT Docker <code>riotdocker</code> is used for compilation, <code>esptool.py</code> has been extracted from the SDK and placed in RIOT's directory <code>dist/tools/esptool</code>. For convenience, the build system uses always the version from this directory.</p>
<p>Therefore, it is <b>not necessary to install</b> <code>esptool.py</code> explicitly. However <code>esptool.py</code> depends on <code>pySerial</code> which can be installed either using <code>pip</code></p>
<div class="fragment"><div class="line">sudo pip install pyserial</div>
</div><!-- fragment --><p>or the package manager of your OS, for example on Debian/Ubuntu systems: </p><div class="fragment"><div class="line">apt install python-pyserial</div>
</div><!-- fragment --><p>For more information on <code>esptool.py</code>, please refer to the <a href="https://github.com/espressif/esptool">git repository</a>.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
&lt;a name="esp32_flashing_the_device"&gt; Flashing the Device &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
&lt;a name="esp32_toolchain_usage"&gt; Toolchain Usage &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>Once you have installed all required components, you should have the following directories.</p>
<div class="fragment"><div class="line">/path/to/esp/esp-idf</div>
<div class="line">/path/to/esp/xtensa-esp32-elf</div>
</div><!-- fragment --><p>To use the toolchain and optionally the SDK, please check that your environment variables are set correctly to</p>
<div class="fragment"><div class="line">export ESP32_SDK_DIR=/path/to/esp/esp-idf</div>
<div class="line">export PATH=$PATH:/path/to/esp/xtensa-esp32-elf/bin</div>
</div><!-- fragment --><p>To compile an application for an ESP32 board, change to RIOT's root directory and execute the make command, e.g., </p><div class="fragment"><div class="line">make flash BOARD=esp32-<span class="keyword">generic</span> -C tests/shell [Compile Options]</div>
</div><!-- fragment --><p>where the <code>BOARD</code> variable specifies the generic ESP32 board definition and option <code>-C</code> the directory of application.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
&lt;a name="esp32_compile_options"&gt; Compile Options &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The compilation process can be controlled by a number of variables for the make command:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option </th><th class="markdownTableHeadNone">Values </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CONFIGS </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">empty </td><td class="markdownTableBodyNone">Override default board and driver configurations, see section <a href="#esp32_application_specific_configurations">Application-Specific Configurations</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FLASH_MODE </td><td class="markdownTableBodyNone">dout, dio, qout, qio </td><td class="markdownTableBodyNone">dout </td><td class="markdownTableBodyNone">Set the flash mode, see section <a href="#esp32_flash_modes">Flash Modes</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PORT </td><td class="markdownTableBodyNone">/dev/* </td><td class="markdownTableBodyNone">/dev/ttyUSB0 </td><td class="markdownTableBodyNone">Set the port for flashing the firmware.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">QEMU </td><td class="markdownTableBodyNone">0, 1 </td><td class="markdownTableBodyNone">0 </td><td class="markdownTableBodyNone">Generate an image for QEMU, see section <a href="#esp32_qemu_mode_and_gdb">QEMU Mode and GDB</a>.  </td></tr>
</table>
</center><center></center><p><br  />
</p>
<p>Optional features of ESP32 can be enabled by <code>USEMODULE</code> definitions in the makefile of the application. These are:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Module </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">esp_eth </td><td class="markdownTableBodyNone">Enable the Ethernet MAC (EMAC) interface as <code>netdev</code> network device, see section <a href="#esp32_ethernet_network_interface">Ethernet Network Interface</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">esp_gdb </td><td class="markdownTableBodyNone">Enable the compilation with debug information for debugging with <a href="#esp32_qemu_mode_and_gdb">QEMU and GDB</a> (<code>QEMU=1</code>) or via <a href="#esp32_jtag_debugging">JTAG interface with OpenOCD</a>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">esp_i2c_hw </td><td class="markdownTableBodyNone">Use the hardware I2C implementation, see section <a href="#esp32_i2c_interfaces">I2C Interfaces</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">esp_idf_heap </td><td class="markdownTableBodyNone">Use the ESP-IDF heap implementation, see section <a href="#esp32_esp_idf_heap_implementation">ESP-IDF Heap Implementation</a>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">esp_log_colored </td><td class="markdownTableBodyNone">Enable colored log output, see section <a href="#esp32_esp_log_module">Log output</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">esp_log_startup </td><td class="markdownTableBodyNone">Enable additional startup information, see section <a href="#esp32_esp_log_module">Log output</a>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">esp_log_tagged </td><td class="markdownTableBodyNone">Add additional information to the log output, see section <a href="#esp32_esp_log_module">Log output</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">esp_now </td><td class="markdownTableBodyNone">Enable the built-in WiFi module with the ESP-NOW protocol as <code>netdev</code> network device, see section <a href="#esp32_esp_now_network_interface">ESP-NOW Network Interface</a>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">esp_rtc_timer_32k </td><td class="markdownTableBodyNone">Enable RTC hardware timer with external 32.768 kHz crystal.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">esp_spiffs </td><td class="markdownTableBodyNone">Enable the optional SPIFFS drive in on-board flash memory, see section <a href="#esp32_spiffs_device">SPIFFS Device</a>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">esp_spi_ram </td><td class="markdownTableBodyNone">Enable the optional SPI RAM, see section <a href="#esp32_spi_ram">SPI RAM Modules</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">esp_wifi </td><td class="markdownTableBodyNone">Enable the built-in WiFi module as <code>netdev</code> network device in WPA2 personal mode, see section <a href="#esp32_wifi_network_interface">WiFi Network Interface</a>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">esp_wifi_ap </td><td class="markdownTableBodyNone">Enable the built-in WiFi SoftAP module as <code>netdev</code> network device, see section <a href="#esp32_wifi_ap_network_interface">WiFi SoftAP Network Interface</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">esp_wifi_enterprise </td><td class="markdownTableBodyNone">Enable the built-in WiFi module as <code>netdev</code> network device in WPA2 enterprise mode, see section <a href="#esp32_wifi_network_interface">WiFi Network Interface</a>.  </td></tr>
</table>
</center><center></center><p>For example, to activate the a SPIFFS drive in on-board flash memory, the makefile of application has simply to add the <code>esp_spiffs</code> module to <code>USEMODULE</code> make variable: </p><div class="fragment"><div class="line">USEMODULE += esp_spiffs</div>
</div><!-- fragment --><p>Modules can be also be activated temporarily at the command line when calling the make command: </p><div class="fragment"><div class="line">USEMODULE=<span class="stringliteral">&quot;esp_spiffs&quot;</span> make BOARD=...</div>
</div><!-- fragment --><p><a class="anchor" id="esp32_flash_modes"></a></p>
<h2><a class="anchor" id="autotoc_md45"></a>
&lt;a name="esp32_flash_modes"&gt; Flash Modes &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The <code>FLASH_MODE</code> make command variable determines the mode that is used for flash access in normal operation.</p>
<p>The flash mode determines whether 2 data lines (<code>dio</code> and <code>dout</code>) or 4 data lines (<code>qio</code> and <code>qout</code>) for addressing and data access. For each data line, one GPIO is required. Therefore, using <code>qio</code> or <code>qout</code> increases the performance of SPI Flash data transfers, but uses two additional GPIOs (GPIO9 and GPIO10). That is, in this flash modes these GPIOs are not available for other purposes. If you can live with lower flash data transfer rates, you should always use <code>dio</code> or <code>dout</code> to keep GPIO9 and GPIO10 free for other purposes.</p>
<p>For more information about these flash modes, refer the documentation of <a href="https://github.com/espressif/esptool/wiki/SPI-Flash-Modes">esptool.py</a>.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
&lt;a name="esp32_esp_log_module"&gt; Log output &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The RIOT port for ESP32 implements a log module with a bunch of macros to generate log output according to the interface as defined in <a href="http://doc.riot-os.org/log_8h.html">system logging header</a>. These macros support colored and tagged log output.</p>
<p>The colored log output is enabled by module <code>esp_log_colored</code>. If colored log output is enabled, log messages are displayed in color according to their type: Error messages are displayed in red, warnings in yellow, information messages in green and all other message types in standard color.</p>
<p>When the <code>esp_log_tagged</code> module is used, all log messages are tagged with additional information: the type of message, the system time in ms, and the module or function in which the log message is generated. For example:</p>
<div class="fragment"><div class="line">I (663) [main_trampoline] main(): This is RIOT! (Version: 2019.10-devel-437-gf506a)</div>
</div><!-- fragment --><p>Either the <code>LOG_*</code> macros as defined in <a href="http://doc.riot-os.org/log_8h.html">system logging header</a> or the tagged version <code>LOG_TAG_*</code> of these macros can be used to produce tagged log output. If the <code>LOG_*</code> macros are used, the function which generates the log message is used in the tag while a <code>tag</code> parameter is used for the <code>LOG_TAG_*</code> macros. For example, </p><div class="fragment"><div class="line">LOG_ERROR(<span class="stringliteral">&quot;error message&quot;</span>);</div>
</div><!-- fragment --><p>generates a log message in which the name of the calling function is used as tag. With </p><div class="fragment"><div class="line">LOG_TAG_ERROR(<span class="stringliteral">&quot;mod&quot;</span>, <span class="stringliteral">&quot;error message&quot;</span>);</div>
</div><!-- fragment --><p>a log message with string <code>mod</code> in the tag is generated.</p>
<p>The <code>esp_log_startup</code> module can be used to enable additional information about the boot process, the board configuration, the system configuration, the CPU used by the system, and the available heap. These information may help to detect problems during the startup. If the application does not start as expected, this module should be used.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
&lt;a name="esp32_esp_idf_heap_implementation"&gt; ESP-IDF Heap Implementation &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP-IDF SDK provides a complex heap implementation that supports multiple heap segments in different memory areas such as DRAM, IRAM, and PSRAM. Whenever you want to use these memory areas as heap, you have to use the heap implementation from the ESP-IDF SDK. ESP-IDF heap is not used by default. To use it, it has to be enabled by the the makefile of the application: </p><div class="fragment"><div class="line">USEMODULE += esp_heap</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>ESP-IDF heap implementation is used by default, when the following modules are used: <code>esp_spi_ram</code></dd></dl>
<p><a class="anchor" id="esp32_comm_periph"></a></p>
<h1><a class="anchor" id="autotoc_md48"></a>
&lt;a name="esp32_peripherals"&gt; Common Peripherals &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<p>ESP32 is an SoC and has a lot of peripherals that are not all supported by the RIOT port. This section describs the supported peripherals and how they have to be configured.</p>
<p><a class="anchor" id="esp32_gpio_pins"></a></p>
<h2><a class="anchor" id="autotoc_md49"></a>
&lt;a name="esp32_gpio_pins"&gt; GPIO pins &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP32 has 34 GPIO pins, where only a subset can be used as output, as ADC channel, as DAC channel and as GPIOs in deep-sleep mode, the so-called RTC GPIOs. Some of them are used by special SoC components, e.g., as touch sensors. The following table gives a short overview.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Pin </th><th class="markdownTableHeadLeft">Type </th><th class="markdownTableHeadCenter">ADC / RTC </th><th class="markdownTableHeadCenter">PU / PD </th><th class="markdownTableHeadNone">Special function </th><th class="markdownTableHeadNone">Remarks  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO0 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Touch sensor </td><td class="markdownTableBodyNone">Bootstrapping, pulled up  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO1 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">UART0 TxD </td><td class="markdownTableBodyNone">Console  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO2 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Touch sensor </td><td class="markdownTableBodyNone">Bootstrapping, pulled down  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO3 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">UART0 RxD </td><td class="markdownTableBodyNone">Console  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO4 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Touch sensor </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO5 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO6 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Flash SD_CLK </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO7 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Flash SD_DATA0 </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO8 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Flash SD_DATA1 </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO9 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Flash SD_DATA2 </td><td class="markdownTableBodyNone">only in <code>qout</code>and <code>qio</code>mode, see section <a href="#esp32_flash_modes">Flash Modes</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO10 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Flash SD_DATA3 </td><td class="markdownTableBodyNone">only in <code>qout</code>and <code>qio</code>mode, see section <a href="#esp32_flash_modes">Flash Modes</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO11 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Flash SD_CMD </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO12 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">MTDI / Touch sensor </td><td class="markdownTableBodyNone">JTAG interface / Bootstrapping, pulled down  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO13 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">MTCK / Touch sensor </td><td class="markdownTableBodyNone">JTAG interface  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO14 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">MTMS / Touch sensor </td><td class="markdownTableBodyNone">JTAG interface  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO15 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">MTDO / Touch sensor </td><td class="markdownTableBodyNone">JTAG interface / Bootstrapping, pulled up  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO16 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">usually not available when SPI RAM is used  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO17 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">usually not available when SPI RAM is used  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO18 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO19 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO21 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO22 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO23 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO25 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">DAC1 </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO26 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">DAC2 </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO27 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">Touch sensor </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO32 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyNone">XTAL32_P </td><td class="markdownTableBodyNone">can be used to connect an external 32 kHz crystal  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO33 </td><td class="markdownTableBodyLeft">In/Out </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyNone">XTAL32_N </td><td class="markdownTableBodyNone">can be used to connect an external 32 kHz crystal  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO34 </td><td class="markdownTableBodyLeft">In </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyNone">VDET </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO35 </td><td class="markdownTableBodyLeft">In </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyNone">VDET </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO36 </td><td class="markdownTableBodyLeft">In </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyNone">SENSOR_VP </td><td class="markdownTableBodyNone">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO37 </td><td class="markdownTableBodyLeft">In </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyNone">SENSOR_CAPP </td><td class="markdownTableBodyNone">usually not broken out  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GPIO38 </td><td class="markdownTableBodyLeft">In </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyNone">SENSOR_CAPN </td><td class="markdownTableBodyNone">usually not broken out  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPIO39 </td><td class="markdownTableBodyLeft">In </td><td class="markdownTableBodyCenter">yes </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyNone">SENSOR_VN </td><td class="markdownTableBodyNone">-  </td></tr>
</table>
</center><center></center><p><b>ADC:</b> these pins can be used as ADC inputs<br  />
 <b>RTC:</b> these pins are RTC GPIOs and can be used in deep-sleep mode<br  />
 <b>PU/PD:</b> these pins have software configurable pull-up/pull-down functionality.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd>GPIOs that can be used as ADC channels are also available as low power digital inputs/outputs in deep sleep mode.</dd></dl>
<p>GPIO0, GPIO2 are bootstrapping pins which are used to boot ESP32 in different modes:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">GPIO0 </th><th class="markdownTableHeadCenter">GPIO2 </th><th class="markdownTableHeadNone">Mode  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">X </td><td class="markdownTableBodyNone">boot in FLASH mode to boot the firmware from flash (default mode)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyNone">boot in UART mode for flashing the firmware  </td></tr>
</table>
</center><center></center><dl class="section note"><dt>Note</dt><dd>GPIO2 becomes the SPI MISO signal for boards that use the HSPI interface as SD-Card interface in 4-bit SD mode. On these boards all signals of the SD-Card interface are pulled up. Because of the bootstrapping functionality of GPIO2, it can become necessary to either press the <b>Boot</b> button, remove the SD card or remove the peripheral hardware to flash RIOT.</dd></dl>
<p><a class="anchor" id="esp32_adc_channels"></a></p>
<h2><a class="anchor" id="autotoc_md50"></a>
&lt;a name="esp32_adc_channels"&gt; ADC Channels &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP32 integrates two 12-bit ADCs (ADC1 and ADC2) capable of measuring up to 18 analog signals in total. Most of these ADC channels are either connected to a number of integrated sensors like a Hall sensors, touch sensors and a temperature sensor or can be connected with certain GPIOs. Integrated sensors are disabled in RIOT's implementation and are not accessible. Thus, up to 18 GPIOs, can be used as ADC inputs:</p>
<ul>
<li>ADC1 supports 8 channels: GPIOs 32-39</li>
<li>ADC2 supports 10 channels: GPIOs 0, 2, 4, 12-15, 25-27</li>
</ul>
<p>These GPIOs are realized by the RTC unit and are therefore also called RTC GPIOs or RTCIO GPIOs.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>GPIO37 and GPIO38 are usually not broken out on ESP32 boards and can not be used therefore.</li>
<li>ADC2 is used by the WiFi module. The GPIOs connected to ADC2 are therefore not available as ADC channels if the modules <code>esp_wifi</code> or <code>esp_now</code> are used.</li>
</ul>
</dd></dl>
<p>The GPIOs that can be used as ADC channels for a given board are defined by the <b><code>ADC_GPIOS</code></b> macro in the board-specific peripheral configuration. This configuration can be changed by <a href="#esp32_application_specific_configurations">application-specific configurations</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define ADC_GPIOS   { GPIO0, GPIO2, GPIO4 }</span></div>
</div><!-- fragment --><p>The order of the listed GPIOs determines the mapping between the RIOT's ADC lines and the GPIOs. The maximum number of GPIOs in the list is <code>ADC_NUMOF_MAX</code> which is defined to be 16.</p>
<p><b><code>ADC_NUMOF</code></b> is determined automatically from <code>ADC_GPIOS</code> list and must not be changed.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li><code>ADC_GPIOS</code> must be defined even if there are no GPIOs that could be used as ADC channels on the board. In this case, an empty list hast to be defined which just contains the curly braces.</li>
<li>As long as the GPIOs listed in ADC_GPIOS are not initialized as ADC channels with the <code>adc_init</code> function, they can be used for other purposes.</li>
</ul>
</dd></dl>
<p>For each ADC line, an attenuation of the input signal can be defined separately with the <code>adc_set_attenuation</code>function.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="adc__arch_8h.html#a6786cc4a1c5602bf2466638ab3e8dff6">adc_set_attenuation</a>(<a class="code" href="group__drivers__periph__adc.html#ga1679abe0c8c15b3df16ac5732512642a">adc_t</a> line, <a class="code" href="adc__arch_8h.html#aa71353583a04674cb8a03f8117e8ecd3">adc_attenuation_t</a> atten);</div>
</div><!-- fragment --><p>This results in different full ranges of the measurable voltage at the input. The attenuation can be set to 0 dB, 3 dB, 6 dB and 11 dB, with 11 dB being the standard attenuation. Since an ADC input is measured against a reference voltage Vref of 1.1 V, approximately the following measurement ranges are given when using a corresponding attenuation:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attenuation </th><th class="markdownTableHeadNone">Voltage Range </th><th class="markdownTableHeadNone">Symbol  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0 dB </td><td class="markdownTableBodyNone">0 ... 1.1V (Vref) </td><td class="markdownTableBodyNone">ADC_ATTENUATION_0_DB  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3 dB </td><td class="markdownTableBodyNone">0 ... 1.5V </td><td class="markdownTableBodyNone">ADC_ATTENUATION_3_DB  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6 dB </td><td class="markdownTableBodyNone">0 ... 2.2V </td><td class="markdownTableBodyNone">ADC_ATTENUATION_6_DB  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11 dB (default) </td><td class="markdownTableBodyNone">0 ... 3.3V </td><td class="markdownTableBodyNone">ADC_ATTENUATION_11_DB  </td></tr>
</table>
</center><center></center><dl class="section note"><dt>Note</dt><dd>The reference voltage Vref can vary from device to device in the range of 1.0V and 1.2V. The Vref of a device can be read with the <code>adc_vref_to_gpio25</code> function at GPIO 25.<br  />
 <div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="adc__arch_8h.html#a8d356a7b25a9dd653be63d70c94942a2">adc_vref_to_gpio25</a> (<span class="keywordtype">void</span>);</div>
</div><!-- fragment --></dd></dl>
<p>For that purpose GPIO25 is initialized automatically as ADC channel and is connected internally to Vref to measure the current voltage. Once the initialization is finished and the function returns with success, the current voltage can be read from GPIO25. The results of the ADC input can then be adjusted accordingly. The <code>adc_vref_to_gpio25</code> function can be used to determine the current voltage at ESP32.</p>
<p><a class="anchor" id="esp32_dac_channels"></a></p>
<h2><a class="anchor" id="autotoc_md51"></a>
&lt;a name="esp32_dac_channels"&gt; DAC Channels &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP32 supports 2 DAC lines at GPIO25 and GPIO26. These DACs have a width of 8 bits and produce voltages in the range from 0 V to 3.3 V (VDD_A). The 16 bits DAC values given as parameter of function <em>dac_set</em> are down-scaled to 8 bit.</p>
<p>The GPIOs that can be used as DAC channels for a given board are defined by the <b><code>DAC_GPIOS</code></b> macro in the board-specific peripheral configuration. This configuration can be changed by <a href="#esp32_application_specific_configurations">application-specific configurations</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define DAC_GPIOS   { GPIO25, GPIO26 }</span></div>
</div><!-- fragment --><p>The order of the listed GPIOs determines the mapping between the RIOT's DAC lines and the GPIOs. The maximum number of GPIOs in the list is <code>DAC_NUMOF_MAX</code> which is defined to be 16.</p>
<p><b><code>DAC_NUMOF</code></b> is determined automatically from <code>DAC_GPIOS</code> list and must not be changed.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li><code>DAC_GPIOS</code> must be defined even if there are no GPIOs that could be used as DAC channels on the board. In this case, an empty list hast to be defined which just contains the curly braces.</li>
<li>As long as the GPIOs listed in <code>DAC_GPIOS</code> are not initialized as DAC channels with the <code>dac_init</code> function, they can be used for other purposes.</li>
</ul>
</dd></dl>
<p><a class="anchor" id="esp32_i2c_interfaces"></a></p>
<h2><a class="anchor" id="autotoc_md52"></a>
&lt;a name="esp32_i2c_interfaces"&gt; I2C Interfaces &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The ESP32 has two built-in I2C hardware interfaces that support I2C bus speed up to 400 kbps (<code>I2C_SPEED_FAST</code>).</p>
<p>The board-specific configuration of the I2C interface <b><code><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a></code></b> requires the definition of</p>
<ul>
<li><b><code>I2Cn_SPEED</code></b>, the bus speed,</li>
<li><b><code>I2Cn_SCL</code></b>, the GPIO used as SCL signal, and</li>
<li><b><code>I2Cn_SDA</code></b>, the GPIO used as SDA signal,</li>
</ul>
<p>where <code>n</code> can be 0 or 1. If they are not defined, the I2C interface <code><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a></code> is not used.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define I2C0_SPEED  I2C_SPEED_FAST</span></div>
<div class="line"><span class="preprocessor">#define I2C0_SCL    GPIO22</span></div>
<div class="line"><span class="preprocessor">#define I2C0_SDA    GPIO21</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define I2C1_SPEED  I2C_SPEED_NORMAL</span></div>
<div class="line"><span class="preprocessor">#define I2C1_SCL    GPIO13</span></div>
<div class="line"><span class="preprocessor">#define I2C1_SDA    GPIO16</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The configuration of the I2C interfaces <code><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a></code> must be in continuous ascending order of n.</dd></dl>
<p><b><code>I2C_NUMOF</code></b> is determined automatically from board-specific peripheral definitions of <code>I2Cn_SPEED</code>, <code>I2Cn_SCK</code>, and <code>I2Cn_SDA</code>.</p>
<p>The following table shows the default configuration of I2C interfaces used for a large number of boards. It can be changed by <a href="#esp32_application_specific_configurations">application-specific configurations</a>.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Device </th><th class="markdownTableHeadLeft">Signal </th><th class="markdownTableHeadLeft">Pin </th><th class="markdownTableHeadLeft">Symbol </th><th class="markdownTableHeadLeft">Remarks  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(0)</a> </td><td class="markdownTableBodyLeft">SCL </td><td class="markdownTableBodyLeft">GPIO22 </td><td class="markdownTableBodyLeft"><code>I2C0_SCL</code> </td><td class="markdownTableBodyLeft">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(0)</a> </td><td class="markdownTableBodyLeft">SDA </td><td class="markdownTableBodyLeft">GPIO21 </td><td class="markdownTableBodyLeft"><code>I2C0_SDA</code> </td><td class="markdownTableBodyLeft">-  </td></tr>
</table>
</center><center></center><dl class="section note"><dt>Note</dt><dd>The GPIOs listed in the configuration are only initialized as I2C signals when the <code>periph_i2c</code> module is used. Otherwise they are not allocated and can be used for other purposes.</dd></dl>
<p>Beside the I2C hardware implementation, a I2C bit-banging protocol software implementation can be used. This implementation allows bus speeds up to 1 Mbps (<code>I2C_SPEED_FAST_PLUS</code>). It can be activated by adding </p><div class="fragment"><div class="line">USEMODULE += esp_i2c_hw</div>
</div><!-- fragment --><p>to application's makefile. The Disadvantage of the software implementation is that it uses busy waiting.</p>
<dl class="section note"><dt>Note</dt><dd>The hardware implementation seems to be very poor and faulty. I2C commands in the I2C command pipeline are sporadically not executed. A number of ACK errors and timeouts caused by protocol errors are the result. The hardware implementation is recommended only if they can be tolerated. Therefore, the software implementation is used by default.</dd></dl>
<p><a class="anchor" id="esp32_pwm_channels"></a></p>
<h2><a class="anchor" id="autotoc_md53"></a>
&lt;a name="esp32_pwm_channels"&gt; PWM Channels &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP supports two types of PWM generators</p>
<ul>
<li>one LED PWM controller (LEDPWM) with 16 channels, and</li>
<li>two high-speed Motor Control PWM controllers (MCPWM) with 6 channels each.</li>
</ul>
<p>The PWM implementation uses the ESP32's high-speed MCPWM modules. Reason is that the LED PWM controller only supports resolutions of powers of two.</p>
<p>ESP32 has 2 MCPWM modules, each with up to 6 channels (<code>PWM_CHANNEL_NUM_DEV_MAX</code>). Thus, the maximum number of PWM devices is 2 and the maximum total number of PWM channels is 12. These 2 MCPWM devices are used as RIOT PWM devices <code><a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(0)</a></code> and <code><a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(1)</a></code>.</p>
<p>The GPIOs that can be used as PWM channels of RIOT's PWM devices are defined by the <b><code>PWM0_GPIOS</code></b> and <b><code>PWM1_GPIOS</code></b> macros in the board-specific peripheral configuration. This configuration can be changed by <a href="#esp32_application_specific_configurations">application specific configurations</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define PWM0_GPIOS { GPIO9, GPIO10 }</span></div>
<div class="line"><span class="preprocessor">#define PWM1_GPIOS { }</span></div>
</div><!-- fragment --><p>The order of the listed GPIOs determines the mapping between RIOT's PWM channels and the GPIOs. Board definitions usually declare a number of GPIOs as PWM channels.</p>
<dl class="section note"><dt>Note</dt><dd>The definition of <code>PWM0_GPIOS</code> and <code>PWM1_GPIOS</code> can be omitted or empty. In the latter case, they must at least contain the curly braces. The corresponding PWM device can not be used in this case.</dd></dl>
<p><b><code>PWM_NUMOF</code></b> is determined automatically from the PWM0_GPIOS and PWM1_GPIOS definitions and must not be changed.</p>
<dl class="section note"><dt>Note</dt><dd>As long as the GPIOs listed in <code>PWM0_GPIOS</code> and <code>PMW1_GPIOS</code> are not initialized as PWM channels with the <code>pwm_init</code> function, they are not allocated and can be used other purposes.</dd></dl>
<p><a class="anchor" id="esp32_spi_interfaces"></a></p>
<h2><a class="anchor" id="autotoc_md54"></a>
&lt;a name="esp32_spi_interfaces"&gt; SPI Interfaces &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP32 integrates four SPI controllers:</p>
<ul>
<li>controller SPI0 is reserved for caching the flash memory</li>
<li>controller SPI1 is reserved for interface <b><code>FSPI</code></b> to external memories like flash and PSRAM</li>
<li>controller SPI2 realizes interface <b><code>HSPI</code></b> that can be used for peripherals</li>
<li>controller SPI3 realizes interface <b><code>VSPI</code></b> that can be used for peripherals</li>
</ul>
<p>Thus, a maximum of two SPI controllers can be used as peripheral interfaces:</p>
<ul>
<li><b><code>VSPI</code></b></li>
<li><b><code>HSPI</code></b></li>
</ul>
<p>All SPI interfaces could be used in quad SPI mode, but RIOT's low level device driver doesn't support it.</p>
<p>The board-specific configuration of the SPI interface <b><code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code></b> requires the definition of</p>
<ul>
<li><b><code>SPIn_CTRL</code></b>, the SPI controller which is used for <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code>, can be <code>VSPI</code> or <code>HSPI</code>,</li>
<li><b><code>SPIn_SCK</code></b>, the GPIO used as clock signal for <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code>,</li>
<li><b><code>SPIn_MISO</code></b>, the GPIO used as MISO signal for <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code>,</li>
<li><b><code>SPIn_MOSI</code></b>, the GPIO used as MOSI signal for <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code>, and</li>
<li><b><code>SPIn_CS0</code></b>, the GPIO used as CS signal for <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code> when the cs parameter in spi_acquire is <code>GPIO_UNDEF</code>,</li>
</ul>
<p>where <code>n</code> can be 0 or 1. If they are not defined, the SPI interface <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code> is not used.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define SPI0_CTRL    VSPI</span></div>
<div class="line"><span class="preprocessor">#define SPI0_SCK    GPIO18      </span><span class="comment">/* SCK  Periphery */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define SPI0_MISO   GPIO19      </span><span class="comment">/* MISO Periphery */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define SPI0_MOSI   GPIO23      </span><span class="comment">/* MOSI Periphery */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define SPI0_CS0    GPIO5       </span><span class="comment">/* CS0  Periphery */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define SPI1_CTRL    HSPI</span></div>
<div class="line"><span class="preprocessor">#define SPI1_SCK    GPIO14      </span><span class="comment">/* SCK  Camera */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define SPI1_MISO   GPIO12      </span><span class="comment">/* MISO Camera */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define SPI1_MOSI   GPIO13      </span><span class="comment">/* MOSI Camera */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define SPI1_CS0    GPIO15      </span><span class="comment">/* CS0  Camera */</span><span class="preprocessor"></span></div>
</div><!-- fragment --><p>The pin configuration of <code>VSPI</code> interface and the <code>HSPI</code> interface can be changed by <a href="#esp32_application_specific_configurations">application specific configurations</a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The configuration of the SPI interfaces <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code> should be in continuous ascending order of <code>n</code>.</li>
<li>The order in which the interfaces <code>VSPI</code> and <code>HSPI</code> are used doesn't matter. For example, while one board may only use the <code>HSPI</code> interface as <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a></code>, another board may use the <code>VSPI</code> interface as <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a></code> and the <code>HSPI</code> interface as <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(1)</a></code>.</li>
<li>The GPIOs listed in the configuration are first initialized as SPI signals when the corresponding SPI interface is used by calling either the <code>spi_init_cs</code> function or the <code>spi_acquire</code> function. That is, they are not allocated as SPI signals before and can be used for other purposes as long as the SPI interface is not used.</li>
<li>GPIO2 becomes the MISO signal in SPI mode on boards that use the HSPI as the SD card interface in 4-bit SD mode. Because of the bootstrapping functionality of the GPIO2, it can be necessary to either press the <b>Boot</b> button, remove the SD card or remove the peripheral hardware to flash RIOT.</li>
</ul>
</dd></dl>
<p><b><code>SPI_NUMOF</code></b> is determined automatically from the board-specific peripheral definitions of <code><a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></code>.</p>
<p>The following table shows the pin configuration used for most boards, even though it <b>can vary</b> from board to board.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Device </th><th class="markdownTableHeadCenter">Signal </th><th class="markdownTableHeadLeft">Pin </th><th class="markdownTableHeadCenter">Symbol </th><th class="markdownTableHeadLeft">Remarks  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">VSPI </td><td class="markdownTableBodyCenter">SCK </td><td class="markdownTableBodyLeft">GPIO18 </td><td class="markdownTableBodyCenter"><code>SPI0_SCK</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">VSPI </td><td class="markdownTableBodyCenter">MISO </td><td class="markdownTableBodyLeft">GPIO19 </td><td class="markdownTableBodyCenter"><code>SPI0_MISO</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">VSPI </td><td class="markdownTableBodyCenter">MOSI </td><td class="markdownTableBodyLeft">GPIO23 </td><td class="markdownTableBodyCenter"><code>SPI0_MOSI</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">VSPI </td><td class="markdownTableBodyCenter">CS0 </td><td class="markdownTableBodyLeft">GPIO18 </td><td class="markdownTableBodyCenter"><code>SPI0_CS0</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">SCK </td><td class="markdownTableBodyLeft">GPIO14 </td><td class="markdownTableBodyCenter"><code>SPI1_SCK</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">MISO </td><td class="markdownTableBodyLeft">GPIO12 </td><td class="markdownTableBodyCenter"><code>SPI1_MISO</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">MOSI </td><td class="markdownTableBodyLeft">GPIO13 </td><td class="markdownTableBodyCenter"><code>SPI1_MOSI</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">CS0 </td><td class="markdownTableBodyLeft">GPIO15 </td><td class="markdownTableBodyCenter"><code>SPI1_CS0</code> </td><td class="markdownTableBodyLeft">can be used for peripherals  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">FSPI </td><td class="markdownTableBodyCenter">SCK </td><td class="markdownTableBodyLeft">GPIO6 </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyLeft">reserved for flash and PSRAM  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">FSPI </td><td class="markdownTableBodyCenter">CMD </td><td class="markdownTableBodyLeft">GPIO11 </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyLeft">reserved for flash and PSRAM  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">FSPI </td><td class="markdownTableBodyCenter">SD0 </td><td class="markdownTableBodyLeft">GPIO7 </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyLeft">reserved for flash and PSRAM  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">FSPI </td><td class="markdownTableBodyCenter">SD1 </td><td class="markdownTableBodyLeft">GPIO8 </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyLeft">reserved for flash and PSRAM  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">FSPI </td><td class="markdownTableBodyCenter">SD2 </td><td class="markdownTableBodyLeft">GPIO9 </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyLeft">reserved for flash and PSRAM (only in <code>qio</code> or <code>qout</code> mode)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">FSPI </td><td class="markdownTableBodyCenter">SD3 </td><td class="markdownTableBodyLeft">GPIO10 </td><td class="markdownTableBodyCenter">- </td><td class="markdownTableBodyLeft">reserved for flash and PSRAM (only in <code>qio</code> or <code>qout</code> mode)  </td></tr>
</table>
</center><center></center><p>Some boards use the HSPI as SD-Card interface (SDIO) in 4-bit SD mode.</p>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Device </th><th class="markdownTableHeadCenter">Pin </th><th class="markdownTableHeadCenter">SD 4-bit mode </th><th class="markdownTableHeadCenter">SPI mode  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">GPIO14 </td><td class="markdownTableBodyCenter">CLK </td><td class="markdownTableBodyCenter">SCK  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">GPIO15 </td><td class="markdownTableBodyCenter">CMD </td><td class="markdownTableBodyCenter">CS0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">GPIO2 </td><td class="markdownTableBodyCenter">DAT0 </td><td class="markdownTableBodyCenter">MISO  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">GPIO4 </td><td class="markdownTableBodyCenter">DAT1 </td><td class="markdownTableBodyCenter">-  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">GPIO12 </td><td class="markdownTableBodyCenter">DAT2 </td><td class="markdownTableBodyCenter">-  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HSPI </td><td class="markdownTableBodyCenter">GPIO13 </td><td class="markdownTableBodyCenter">DAT3 </td><td class="markdownTableBodyCenter">MOSI  </td></tr>
</table>
</center><p>On these boards, all these signals are pulled up. This may cause flashing problems due to the bootstrap function of the GPIO2 pin, see section <a href="#esp32_gpio_pins">GPIO pins</a>.</p>
<p><a class="anchor" id="esp32_timers"></a></p>
<h2><a class="anchor" id="autotoc_md55"></a>
&lt;a name="esp32_timers"&gt; Timers &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>There are two different implementations for hardware timers.</p>
<ul>
<li><b><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho">Timer</a> Module implementation</b> It provides 4 high-speed timers, where 1 timer is used for system time. The remaining <b>3 timer devices</b> with <b>1 channel</b> each can be used as RIOT timer devices with a clock rate of 1 MHz.</li>
<li><b>Counter implementation</b> It uses CCOUNT/CCOMPARE registers to implement <b>2 timer devices</b> with <b>1 channel</b> each and a clock rate of 1 MHz.</li>
</ul>
<p>By default, the hardware timer module is used. To use the hardware counter implementation, add </p><div class="fragment"><div class="line">USEMODULE += esp_hw_counter</div>
</div><!-- fragment --><p>to application's makefile.</p>
<p>Timers are MCU built-in features and not board-specific. There is nothing to be configured.</p>
<p><a class="anchor" id="esp32_rtt_counter"></a></p>
<h2><a class="anchor" id="autotoc_md56"></a>
&lt;a name="esp32_rtt_counter"&gt; RTT implementation &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The RTT peripheral low-level driver provides a RTT (Real Time <a class="el" href="structTimer.html" title="struct to get time references within mqtt paho">Timer</a>) with a frequency of 32.768 kHz. It either uses the RTC hardware timer if an external 32.768 kHz crystal is connected to the ESP32 or the PLL-controlled 64-bit microsecond system timer to emulate the RTC timer.</p>
<p>Whether an external 32.768 kHz crystal is connected to the ESP32 is specified as a feature by the board definition using the pseudomodule <code>esp_rtc_timer_32k</code>. If the feature <code>esp_rtc_timer_32k</code> is defined but the external 32.768 kHz crystal is not recognized during startup, the PLL controlled 64 bit microsecond system timer is used to emulate the RTC timer.</p>
<p>The RTT is retained during light and deep sleep as well as during a restart. The RTC hardware timer is used for this purpose, regardless of whether an external 32.768 kHz crystal is connected to the ESP32 or the internal 150 kHz RC oscillator is used. All current timer values are saved in the RTC memory before entering a sleep mode or restart and are restored after when waking up or restarting.</p>
<dl class="section note"><dt>Note</dt><dd>The RTT implementation is also used to implement a RTC (Real Time Clock) peripheral. For this purpose the module <code>rt_rtc</code> is automatically enabled when the feature <code>periph_rtc</code> is used.</dd></dl>
<p><a class="anchor" id="esp32_uart_interfaces"></a></p>
<h2><a class="anchor" id="autotoc_md57"></a>
&lt;a name="esp32_uart_interfaces"&gt; UART Interfaces &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP32 supports up to three UART devices. <code><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a></code> has a fixed pin configuration and is always available. All ESP32 boards use it as standard configuration for the console.</p>
<p>The pin configuration of <code><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a></code> and <code><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(2)</a></code> are defined in board specific peripheral configuration by</p>
<ul>
<li><b><code>UARTn_TXD</code></b>, the GPIO used as TxD signal, and</li>
<li><b><code>UARTn_RXD</code></b>, the GPIO used as RxD signal,</li>
</ul>
<p>where <code>n</code> can be 2 or 3. If they are not defined, the UART interface <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a> is not used.</p>
<p><b><code>UART_NUMOF</code></b> is determined automatically from the board-specific peripheral definitions of <code>UARTn_TXD</code> and <code>UARTn_RXD</code> and must not be changed.</p>
<p>The following default pin configuration of UART interfaces as used by a most boards can be overridden by the application, see section <a href="#esp32_application_specific_configurations">Application-Specific Configurations</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Device </th><th class="markdownTableHeadLeft">Signal </th><th class="markdownTableHeadLeft">Pin </th><th class="markdownTableHeadLeft">Symbol </th><th class="markdownTableHeadLeft">Remarks  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a> </td><td class="markdownTableBodyLeft">TxD </td><td class="markdownTableBodyLeft">GPIO1 </td><td class="markdownTableBodyLeft"><code>UART0_TXD</code> </td><td class="markdownTableBodyLeft">cannot be changed  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a> </td><td class="markdownTableBodyLeft">RxD </td><td class="markdownTableBodyLeft">GPIO3 </td><td class="markdownTableBodyLeft"><code>UART0_RXD</code> </td><td class="markdownTableBodyLeft">cannot be changed  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a> </td><td class="markdownTableBodyLeft">TxD </td><td class="markdownTableBodyLeft">GPIO10 </td><td class="markdownTableBodyLeft"><code>UART1_TXD</code> </td><td class="markdownTableBodyLeft">optional, can be overridden  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a> </td><td class="markdownTableBodyLeft">RxD </td><td class="markdownTableBodyLeft">GPIO9 </td><td class="markdownTableBodyLeft"><code>UART1_RXD</code> </td><td class="markdownTableBodyLeft">optional, can be overridden  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(2)</a> </td><td class="markdownTableBodyLeft">TxD </td><td class="markdownTableBodyLeft">GPIO17 </td><td class="markdownTableBodyLeft"><code>UART2_TXD</code> </td><td class="markdownTableBodyLeft">optional, can be overridden  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(2)</a> </td><td class="markdownTableBodyLeft">RxD </td><td class="markdownTableBodyLeft">GPIO16 </td><td class="markdownTableBodyLeft"><code>UART2_RXD</code> </td><td class="markdownTableBodyLeft">optional, can be overridden  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define UART1_TXD   GPIO10      </span><span class="comment">/* UART_DEV(1) TxD */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define UART1_RXD   GPIO9       </span><span class="comment">/* UART_DEV(1) RxD */</span><span class="preprocessor"></span></div>
</div><!-- fragment --><p><a class="anchor" id="esp32_can_interfaces"></a></p>
<h2><a class="anchor" id="autotoc_md58"></a>
&lt;a name="esp32_can_interfaces"&gt; CAN Interfaces &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The ESP32 intregates a CAN controller which is compatible with the NXP SJA1000 CAN controller. Thus, it is CAN 2.0B specification compliant and supports two message formats:</p>
<ul>
<li>Base Frame Format (11-bit ID)</li>
<li>Extended Frame Format (29-bit ID)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>ESP32 CAN does not support CAN-FD and is not CAN-FD tolerant.</li>
<li>ESP32 CAN does not support SJA1000's sleep mode and wake-up functionality.</li>
</ul>
</dd></dl>
<p>As with the SJA1000, the ESP32 CAN controller provides only the data link layer and the physical layer signaling sublayer. Therefore, depending on physical layer requirements, an external transceiver module is required which converts the <code>CAN-RX</code> and <code>CAN-TX</code> signals of the ESP32 into <code>CAN_H</code> and <code>CAN_L</code> bus signals, e.g., the MCP2551 or SN65HVD23X transceiver for compatibility with ISO 11898-2.</p>
<p>If module <code>periph_can</code> is used, the low-level CAN driver for the ESP32 CAN controller is enabled. It provides a CAN DLL device that can be used with RIOT's CAN protocol stack. It uses the ESP32 CAN controller in SJA1000 PeliCAN mode. Please refer the <a href="https://www.nxp.com/documents/data_sheet/SJA1000.pdf">SJA1000 Datasheet</a> for detailed information about the CAN controller and its programming.</p>
<p>The pin configuration of the CAN transceiver interface is usually defined in board specific peripheral configuration by</p>
<ul>
<li><b><code>CAN_TX</code></b>, the GPIO used as TX transceiver signal, and</li>
<li><b><code>CAN_RX</code></b>, the GPIO used as RX transceiver signal.</li>
</ul>
<p>If the pin configuration is not defined, the following default configuration is used which can be overridden by the application, see section <a href="#esp32_application_specific_configurations">Application-Specific Configurations</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Device </th><th class="markdownTableHeadLeft">Signal </th><th class="markdownTableHeadLeft">Pin </th><th class="markdownTableHeadLeft">Symbol </th><th class="markdownTableHeadLeft">Remarks  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CAN </td><td class="markdownTableBodyLeft">TX </td><td class="markdownTableBodyLeft">GPIO5 </td><td class="markdownTableBodyLeft"><code>CAN_TX</code> </td><td class="markdownTableBodyLeft">optional, can be overridden  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">CAN </td><td class="markdownTableBodyLeft">RX </td><td class="markdownTableBodyLeft">GPIO35 </td><td class="markdownTableBodyLeft"><code>CAN_RX</code> </td><td class="markdownTableBodyLeft">optional, can be overridden  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define CAN_TX      GPIO10      </span><span class="comment">/* CAN TX transceiver signal */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define CAN_RX      GPIO9       </span><span class="comment">/* CAN RX transceiver signal */</span><span class="preprocessor"></span></div>
</div><!-- fragment --><p>If the board has an external transceiver module connected to the ESP32 on-board, module <code>periph_can</code> should be provided as feature in board's <code>Makefile.features</code> </p><div class="fragment"><div class="line">FEATURES_PROVIDED += periph_can     # CAN peripheral interface</div>
</div><!-- fragment --><p>Otherwise, the application has to add the <code>periph_can</code> module in its makefile when needed.</p>
<p><a class="anchor" id="esp32_power_management"></a></p>
<h2><a class="anchor" id="autotoc_md59"></a>
&lt;a name="esp32_power_management"&gt; Power Management &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<h3><a class="anchor" id="autotoc_md60"></a>
Power Modes</h3>
<p>The RIOT port for the ESP32 implements RIOT's layered power management. It supports the following operating modes:</p>
<ul>
<li>The <b>Modem-sleep</b> mode is the default operating mode when the WiFi interface is disabled.</li>
<li>The <b>Active</b> mode is the default operating mode when the WiFi interface is used by either the <code>esp-wifi</code> or <code>esp-now</code> module.</li>
<li>In <b>Light-sleep</b> mode, the CPUs including peripherals are stalled, but the SRAM is retained. The system can continue when it returns from this mode.</li>
<li>In <b>Deep-sleep</b> the CPU and the SRAM are powered down. The RTC memory can be retained. The system must be restarted when it returns from this mode.</li>
</ul>
<p>Since the peripherals are not working during <em>Light-sleep</em>/_Deep-sleep_, the CPU cannot be woken up by internal interrupt sources such as timers. Therefore, RIOT's layered power management can't select them as idle power mode. They are therefore blocked for normal operation. The application has to select them explicitly using the <code>pm_set</code> function. RIOT's layered power management can only select either <em>Modem-sleep</em> or <em>Active</em> as the lowest unblocked mode.</p>
<p>But also in <em>Modem-sleep</em> or <em>Active</em> mode, the lowest possible power level is used. For this purpose, the Xtensa ISA instruction <code>waiti</code> is used, which saves power by setting the current interrupt level, turning off the processor logic and waiting for an interrupt.</p>
<h3><a class="anchor" id="autotoc_md61"></a>
Using Power Modes</h3>
<p><em>Modem-sleep</em> mode and <em>Active</em> mode are the default operating modes dependent on whether the WiFi interface is used. They are selected automatically by the system.</p>
<p>To enter the <em>Light-sleep</em> or the <em>Deep-sleep</em> mode, function <code>pm_set</code> has to be used with the according mode <code>ESP_PM_LIGHT_SLEEP</code> or <code>ESP_PM_DEEP_SLEEP</code> as parameter. To exit from these modes, several wake-up sources can be used.</p>
<h4><a class="anchor" id="autotoc_md62"></a>
Wake-up Sources in &lt;em&gt;Light-sleep&lt;/em&gt; Mode</h4>
<p>Possible wake-up sources for the <em>Light-sleep</em> mode are:</p>
<ul>
<li>RTC timer (set the RTC timer alarm using <code>rtc_set</code> before calling <code>pm_set</code>)</li>
<li>GPIOs that are configured as input with enabled interrupt</li>
<li>RxD signal of UART0 and/or UART1 (configured with <code>ESP_PM_WUP_UART0</code> and <code>ESP_PM_WUP_UART1</code>)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Since the digital core (MCU) is stalled during <em>Light-sleep</em>, it is not possible timers like <code>periph_timer</code> or <code>xtimer</code> as wake-up source.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since only level interrupts are supported in <em>Light-sleep</em> mode, defined edge interrupts of type <code>GPIO_RISING</code> and <code>GPIO_FALLING</code> are implicitly mapped to <code>GPIO_HIGH</code> and <code>GPIO_LOW</code>, respectively, when entering <em>Light-sleep</em> mode.</dd></dl>
<h4><a class="anchor" id="autotoc_md63"></a>
Wake-up Sources in &lt;em&gt;Light-sleep&lt;/em&gt; Mode</h4>
<p>Possible Wake-up sources for the <em>Deep-sleep</em> mode are:</p>
<ul>
<li>RTC timer (set the RTC timer alarm using <code>rtc_set</code> before calling <code>pm_set</code>)</li>
<li>RTC GPIOs (configured by <code>ESP_PM_WUP_PINS</code> and <code>ESP_PM_WUP_LEVEL</code>)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>RTC GPIOs are the GPIOs that are realized by the RTC unit and can also be used as ADC channels. See section <a href="#esp32_gpio_pins">GPIO pins</a> and <a href="#esp32_adc_channels">ADC Channels</a> for more information.</dd></dl>
<h3><a class="anchor" id="autotoc_md64"></a>
Configuration</h3>
<p>Several definitions can be used during compile time to configure the <em>Light-sleep</em> and the <em>Deep-sleep</em> mode:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter </th><th class="markdownTableHeadLeft">Default </th><th class="markdownTableHeadLeft">Mode </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_PM_GPIO_HOLD </td><td class="markdownTableBodyLeft">not defined </td><td class="markdownTableBodyLeft">Deep </td><td class="markdownTableBodyLeft">Hold GPIO output level if defined  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ESP_PM_WUP_PINS </td><td class="markdownTableBodyLeft">none </td><td class="markdownTableBodyLeft">Deep </td><td class="markdownTableBodyLeft">GPIOs used as wake-up source  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_PM_WUP_LEVEL </td><td class="markdownTableBodyLeft">ESP_PM_WUP_PINS_ANY_HIGH </td><td class="markdownTableBodyLeft">Deep </td><td class="markdownTableBodyLeft">Level for wake-up pins to wake-up  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ESP_PM_WUP_UART0 </td><td class="markdownTableBodyLeft">disabled </td><td class="markdownTableBodyLeft">Light </td><td class="markdownTableBodyLeft">Positive UART0 RxD signal edges to wake-up  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_PM_WUP_UART1 </td><td class="markdownTableBodyLeft">disabled </td><td class="markdownTableBodyLeft">Light </td><td class="markdownTableBodyLeft">Positive UART1 RxD signal edges to wake-up  </td></tr>
</table>
</center><center></center><ul>
<li>If <code>ESP_PM_GPIO_HOLD</code> is defined, GPIOs hold their last output level when entering <em>Deep-sleep</em> mode. Please note that only RTC GPIOs can hold their output value in <em>Deep-sleep</em> mode.</li>
<li><code>ESP_PM_WUP_PINS</code> specifies either a single RTC GPIO or a comma separated list of RTC GPIOs that are used as wake-up source in <em>Deep-sleep</em> mode.</li>
<li><code>ESP_PM_WUP_LEVEL</code> specifies the level for the wake-up pins in <em>Deep-sleep</em> mode:<ul>
<li><code>ESP_PM_WUP_PINS_ANY_HIGH</code> (default) - The system is woken up when any of the GPIOs specified in <code>ESP_PM_WUP_PINS</code> becomes HIGH.</li>
<li><code>ESP_PM_WUP_PINS_ALL_LOW</code> - The system is woken up when all GPIOs specified in <code>ESP_PM_WUP_PINS</code> become LOW.</li>
</ul>
</li>
<li><code>ESP_PM_WUP_UART0</code> and <code>ESP_PM_WUP_UART1</code> define the number of positive edges of the RxD signal of the respective UART that are necessary to wake up the system in the <em>Light-sleep</em> mode. The value must be greater than 2, otherwise UART is not activated as wake-up source. The specified value is reduced by 2 so that <code>ESP_PM_WUP_UART0</code> or <code>ESP_PM_WUP_UART1</code> plus 2 is the number of positive edges required to wake up.</li>
</ul>
<p>In the following example the system shall be woken up from <em>Deep-sleep</em> if the pulled-up pin <code>GPIO25</code> (<code>ESP_PM_WUP_PINS=GPIO25</code>) goes LOW (<code>ESP_PM_WUP_LEVEL=ESP_PM_WUP_PINS_ALL_LOW</code>). The last GPIO output values are held (<code>ESP_PM_GPIO_HOLD</code>) in <em>Deep-sleep</em> mode. From <em>Light-sleep</em> the system can be woken up by any of the GPIOs defined as input with enabled interrupt or if the RxD signal of UART0 goes HIGH at least 4 times (<code>ESP_PM_WUP_UART0=6</code>). </p><div class="fragment"><div class="line">CFLAGS=<span class="stringliteral">&#39;-DESP_PM_WUP_PINS=GPIO25 -DESP_PM_WUP_LEVEL=ESP_PM_WUP_PINS_ALL_LOW \</span></div>
<div class="line"><span class="stringliteral">        -DESP_PM_WUP_UART0=6 -DESP_PM_GPIO_HOLD&#39;</span> \</div>
<div class="line">make BOARD=esp32-wroom-32 -C tests/periph_pm</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
Saving Data in &lt;em&gt;Deep-sleep&lt;/em&gt; Mode</h3>
<p>In <em>Deep-sleep</em> mode the SRAM is powered down. However, the slow RTC memory can be retained. Therefore, data that must be retained during <em>Deep-sleep</em> and the subsequent system restart, must be stored in the slow RTC memory. For that purpose, use</p><ul>
<li><code>__attribute__((section(".rtc.bss")))</code> to place uninitialized data in section <code>.rtc.bss</code>, and</li>
<li><code>__attribute__((section(".rtc.data")))</code> to place initialized data in section <code>.rtc.data</code>.</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> _i_value __attribute__((section(<span class="stringliteral">&quot;.rtc.bss&quot;</span>)));      <span class="comment">/* set to 0 at power on */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> _u_value __attribute__((section(<span class="stringliteral">&quot;.rtc.data&quot;</span>))) = 1; <span class="comment">/* initialized */</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
&lt;a name="esp32_other_peripherals"&gt; Other Peripherals &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The ESP32 port of RIOT also supports:</p>
<ul>
<li>hardware number generator with 32 bit</li>
<li>CPU-ID function</li>
<li>Vref measurement function</li>
</ul>
<h1><a class="anchor" id="autotoc_md67"></a>
&lt;a name="esp32_special_on_board_peripherals"&gt; Special On-board Peripherals &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<p><a class="anchor" id="esp32_spi_ram"></a></p>
<h2><a class="anchor" id="autotoc_md68"></a>
&lt;a name="esp32_spi_ram"&gt; SPI RAM Modules&lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The ESP32 can use external SPI RAM connected through the FSPI interface. For example, all boards that use the <a href="https://www.espressif.com/en/products/hardware/modules">ESP32-WROVER modules</a> have already integrated such SPI RAM.</p>
<p>However, the external SPI RAM requires 4 data lines and thus can only be used in QOUT (quad output) or QIO (quad input/output) flash mode, which makes GPIO9 and GPIO10 unavailable for other purposes. Therefore, if needed, the SPI RAM must be explicitly enabled in the makefile of the application. </p><div class="fragment"><div class="line">USEMODULE += esp_spi_ram</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>When the SPI RAM is enabled using the <code>esp_spi_ram</code>, the ESP32 uses four data lines to access the external SPI RAM in QOUT (quad output) flash mode. Therefore, GPIO9 and GPIO10 are used as SPI data lines and are not available for other purposes.</li>
<li>Enabling SPI RAM for modules that don't have SPI RAM may lead to boot problems for some modules. For others is simply throws an error message.</li>
</ul>
</dd></dl>
<p><a class="anchor" id="esp32_spiffs_device"></a></p>
<h2><a class="anchor" id="autotoc_md69"></a>
&lt;a name="esp32_spiffs_device"&gt; SPIFFS Device &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The RIOT port for ESP32 implements a MTD system drive <code>mtd0</code> using the on-board SPI flash memory. This MTD system drive can be used together with SPIFFS and VFS to realize a persistent file system.</p>
<p>To use the MTD system drive with SPIFFS, the <code>esp_spiffs</code> module has to be enabled in the makefile of the application: </p><div class="fragment"><div class="line">USEMODULE += esp_spiffs</div>
</div><!-- fragment --><p>When SPIFFS is enabled, the MTD system drive is formatted with SPIFFS the first time the system is started. The start address of the MTD system drive in the SPI flash memory is defined by the board configuration: </p><div class="fragment"><div class="line"><span class="preprocessor">#define SPI_FLASH_DRIVE_START  0x200000</span></div>
</div><!-- fragment --><p>If this start address is set to 0, as in the default board configuration, the first possible multiple of 0x100000 (1 MByte) will be used in the free SPI flash memory determined from the partition table.</p>
<p>Please refer file <code>$RIOTBASE/tests/unittests/test-spiffs/tests-spiffs.c</code> for more information on how to use SPIFFS and VFS together with a MTD device <code>mtd0</code> alias <code>MTD_0</code>.</p>
<h1><a class="anchor" id="autotoc_md70"></a>
&lt;a name="esp32_network_interfaces"&gt; Network Interfaces &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<p>ESP32 provides different built-in possibilities to realize network devices:</p>
<ul>
<li><b>EMAC</b>, an Ethernet MAC implementation (requires an external PHY module)</li>
<li><b>ESP WiFi</b>, usual AP-based wireless LAN</li>
<li><b>ESP-NOW</b>, a WiFi based AP-less and connectionless peer to peer communication protocol</li>
<li><b>ESP-MESH</b>, a WiFi based mesh technology (not yet supported)</li>
</ul>
<p><a class="anchor" id="esp32_ethernet_network_interface"></a></p>
<h2><a class="anchor" id="autotoc_md71"></a>
&lt;a name="esp32_ethernet_network_interface"&gt; Ethernet MAC Network Interface &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP32 provides an <b>Ethernet MAC layer module (EMAC)</b> according to the IEEE 802.3 standard which can be used together with an external physical layer chip (PHY) to realize a 100/10 Mbps Ethernet interface. Supported PHY chips are the Microchip LAN8710/LAN8720 and the Texas Instruments TLK110.</p>
<p>The RIOT port for ESP32 realizes with module <code>esp_eth</code> a <code>netdev</code> driver for the EMAC which uses RIOT's standard Ethernet interface.</p>
<p>If the board has one of the supported PHY layer chips connected to the ESP32, the <code>esp_eth</code> module should be enabled by default in board's <code>Makefile.dep</code> when module <code>netdev_default</code> is used. </p><div class="fragment"><div class="line">ifneq (,$(filter netdev_default,$(USEMODULE)))</div>
<div class="line">    USEMODULE += esp_eth</div>
<div class="line">endif</div>
</div><!-- fragment --><p>Otherwise, the application has to add the <code>esp_eth</code> module in its makefile when needed.</p>
<dl class="section note"><dt>Note</dt><dd>The board has to have one of the supported PHY modules to be able to use the Ethernet MAC module.</dd></dl>
<p><a class="anchor" id="esp32_wifi_network_interface"></a></p>
<h2><a class="anchor" id="autotoc_md72"></a>
&lt;a name="esp32_wifi_network_interface"&gt; WiFi Network Interface &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The RIOT port for ESP32 implements a <code>netdev</code> driver for the built-in WiFi interface. This <code>netdev</code> driver supports WPA2 personal mode as well as WPA2 enterprise mode.</p>
<h3><a class="anchor" id="autotoc_md73"></a>
WPA2 personal mode</h3>
<p>To use the WiFi <code>netdev</code> driver in WPA2 personal mode with a preshared key (PSK), module <code>esp_wifi</code> has to be enabled.</p>
<div class="fragment"><div class="line">USEMODULE += esp_wifi</div>
</div><!-- fragment --><p>Furthermore, the following configuration parameters have to be defined:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter </th><th class="markdownTableHeadLeft">Default </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_WIFI_SSID </td><td class="markdownTableBodyLeft">"RIOT_AP" </td><td class="markdownTableBodyLeft">SSID of the AP to be used.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ESP_WIFI_PASS </td><td class="markdownTableBodyLeft">- </td><td class="markdownTableBodyLeft">Passphrase used for the AP as clear text (max. 64 chars).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_WIFI_STACKSIZE </td><td class="markdownTableBodyLeft"><a class="el" href="native_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f" title="CPU specific default stack sizes.">THREAD_STACKSIZE_DEFAULT</a> </td><td class="markdownTableBodyLeft">Stack size used for the WiFi netdev driver thread.  </td></tr>
</table>
</center><center></center><p>These configuration parameter definitions, as well as enabling the <code>esp_wifi</code> module, can be done either in the makefile of the project or at make command line, for example:</p>
<div class="fragment"><div class="line">USEMODULE=esp_wifi \</div>
<div class="line">CFLAGS=<span class="stringliteral">&#39;-DESP_WIFI_SSID=\&quot;MySSID\&quot; -DESP_WIFI_PASS=\&quot;MyPassphrase\&quot;&#39;</span> \</div>
<div class="line">make -C examples/gnrc_networking BOARD=...</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>Module <code>esp_wifi</code> is not enabled automatically when module <code>netdev_default</code> is used.</li>
<li>Leave 'ESP_WIFI_PASS' undefined to connect to an open WiFi access point.</li>
<li>The Wifi network interface (module <code>esp_wifi</code>) and the <a href="#esp32_esp_now_network_interface">ESP-NOW network interface</a> (module <code>esp_now</code>) can be used simultaneously, for example, to realize a border router for a mesh network which uses ESP-NOW.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md74"></a>
WPA2 Enterprise Mode</h3>
<p>To use the WiFi <code>netdev</code> driver in WPA2 enterprise mode with IEEE 802.1X/EAP authentication, module <code>esp_wifi_enterprise</code> has to be enabled.</p>
<div class="fragment"><div class="line">USEMODULE += esp_wifi_enterprise</div>
</div><!-- fragment --><p>It supports the following EAP authentication methods:</p>
<ul>
<li>PEAPv0</li>
<li>PEAPv1</li>
<li>TTLS</li>
</ul>
<p>As inner (phase 2) EAP authentication method, only MSCHAPv2 is supported.</p>
<p>To use module <code>esp_wifi_enterprise</code> with these authentication methods, the following configuration parameters have to be defined:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter </th><th class="markdownTableHeadLeft">Default </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_WIFI_SSID </td><td class="markdownTableBodyLeft">"RIOT_AP" </td><td class="markdownTableBodyLeft">SSID of the AP to be used.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ESP_WIFI_EAP_ID </td><td class="markdownTableBodyLeft">none </td><td class="markdownTableBodyLeft">Optional anonymous identity used in phase 1 (outer) EAP authentication. If it is not defined, the user name defined for phase 2 (inner) EAP authentication is used as identity in phase 1.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_WIFI_EAP_USER </td><td class="markdownTableBodyLeft">none </td><td class="markdownTableBodyLeft">User name used in phase 2 (inner) EAP authentication.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ESP_WIFI_EAP_PASS </td><td class="markdownTableBodyLeft">none </td><td class="markdownTableBodyLeft">Password used in phase 2 (inner) EAP authentication.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_WIFI_STACKSIZE </td><td class="markdownTableBodyLeft"><a class="el" href="native_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f" title="CPU specific default stack sizes.">THREAD_STACKSIZE_DEFAULT</a> </td><td class="markdownTableBodyLeft">Stack size used for the WiFi netdev driver thread.  </td></tr>
</table>
</center><center></center><p>These configuration parameter definitions, as well as enabling the <code>esp_wifi</code> module, can be done either in the makefile of the project or at make command line, for example:</p>
<div class="fragment"><div class="line">USEMODULE=esp_wifi_enterprise \</div>
<div class="line">CFLAGS=<span class="stringliteral">&#39;-DESP_WIFI_SSID=\&quot;MySSID\&quot; -DESP_WIFI_EAP_ID=\&quot;anonymous\&quot; -DESP_WIFI_EAP_USER=\&quot;MyUserName\&quot; -DESP_WIFI_EAP_PASS=\&quot;MyPassphrase\&quot;&#39;</span> \</div>
<div class="line">make -C examples/gnrc_networking BOARD=...</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>Since there is no possibility to add the CA certificate to the RIOT image, the verification of the AP certificate is not yet supported.</li>
<li>Module <code>esp_wifi_enterprise</code> is not enabled automatically when module <code>netdev_default</code> is used.</li>
<li>The Wifi network interface (module <code>esp_wifi_enterprise</code>) and the <a href="#esp32_esp_now_network_interface">ESP-NOW network interface</a> (module <code>esp_now</code>) can be used simultaneously, for example, to realize a border router for a mesh network which uses ESP-NOW. In this case the ESP-NOW interface must use the same channel as the AP of the infrastructure WiFi network. All ESP-NOW nodes must therefore be compiled with the channel of the AP as value for the parameter 'ESP_NOW_CHANNEL'.</li>
</ul>
</dd></dl>
<p><a class="anchor" id="esp32_wifi_ap_network_interface"></a></p>
<h2><a class="anchor" id="autotoc_md75"></a>
&lt;a name="esp32_wifi_ap_network_interface"&gt; WiFi SoftAP Network Interface &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>The RIOT port for the ESP32 supports a <code>netdev</code> interface for the ESP32 WiFi SoftAP mode. Module <code>esp_wifi_ap</code> has to be enabled to use it.</p>
<p>The following parameters can be configured:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter </th><th class="markdownTableHeadLeft">Default </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="esp__wifi__params_8h.html#ad2883d0cae1d96edaefd3b0a46b5ee46" title="SSID of the AP to be used.">ESP_WIFI_SSID</a> </td><td class="markdownTableBodyLeft">"RIOT_AP" </td><td class="markdownTableBodyLeft">Static SSID definition for the SoftAP  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="esp__wifi__params_8h.html#a804f5c8a087e8f2db4a3e8ac7469658f" title="Prefix to be used as part of the SSID (e.g.">ESP_WIFI_AP_PREFIX</a> </td><td class="markdownTableBodyLeft">"RIOT_AP_" </td><td class="markdownTableBodyLeft">Optional prefix for dynamic SSID, if used, the node will create the SSID based on the prefix + mac address (e.g.: "RIOT_AP_aabbccddeeff"). This is disabled by default and <code>ESP_WIFI_SSID</code> is used, define this to enable the usage of the SSID prefix.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="esp__wifi__params_8h.html#ac0354e38c60a7a189ea8653efc4e0cd6" title="Passphrase used for the AP as clear text (max.">ESP_WIFI_PASS</a> </td><td class="markdownTableBodyLeft">none </td><td class="markdownTableBodyLeft">The password for the WiFi SoftAP network interface. If no password is provided, the interface will be "open", otherwise it uses WPA2-PSK authentication mode.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="esp__wifi__params_8h.html#a16c939ff6e82025ec056586ade2a73ee" title="Whether SoftAP SSID should be hidden.">ESP_WIFI_SSID_HIDDEN</a> </td><td class="markdownTableBodyLeft">0 </td><td class="markdownTableBodyLeft">Whether the SoftAP SSID should be hidden.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="esp__wifi__params_8h.html#ab3f9fd0aac889d9573032c4d84800638" title="WiFi SoftAP maximum connections (max.">ESP_WIFI_MAX_CONN</a> </td><td class="markdownTableBodyLeft">4 </td><td class="markdownTableBodyLeft">The maximum number of connections for the SoftAP.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="esp__wifi__params_8h.html#a26aa84c2778f44d6ec4c883e057d6b15" title="WiFi SoftAP beacon interval, in milliseconds.">ESP_WIFI_BEACON_INTERVAL</a> </td><td class="markdownTableBodyLeft">100 </td><td class="markdownTableBodyLeft">The beacon interval time in milliseconds for the SoftAP.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="esp__wifi__params_8h.html#a46b0a15e70e1fb388c7ba70f5df96e29" title="The size of the stack used for the ESP WIFI netdev driver thread.">ESP_WIFI_STACKSIZE</a> </td><td class="markdownTableBodyLeft"><a class="el" href="native_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f" title="CPU specific default stack sizes.">THREAD_STACKSIZE_DEFAULT</a> </td><td class="markdownTableBodyLeft">Stack size used for the WiFi netdev driver thread.  </td></tr>
</table>
</center><center></center><p>These configuration parameter definitions, as well as enabling the <code>esp_wifi_ap</code> module, can be done either in the makefile of the project or at make command line, for example:</p>
<div class="fragment"><div class="line">USEMODULE=esp_wifi_ap \</div>
<div class="line">CFLAGS=<span class="stringliteral">&#39;-DESP_WIFI_SSID=\&quot;MySSID\&quot; -DESP_WIFI_PASS=\&quot;MyPassphrase\&quot; -DESP_WIFI_MAX_CONN=1 \</span></div>
<div class="line"><span class="stringliteral">make -C examples/gnrc_networking BOARD=...</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>The <code>esp_wifi_ap</code> module is not used by default when <code>netdev_default</code> is used.</li>
<li>Supports open and WPA2-PSK authentication modes.</li>
<li>The ESP-NOW network interface and the WiFi SoftAP network interface can not be used simultaneously.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The SoftAP may or may not be at all reliable sometimes, this is a known problem with the Wi-Fi network interface, even on the official ESP-IDF. The problem is that the AP doesn't cache multicast data for connected stations, and if stations connected to the AP are power save enabled, they may experience multicast packet loss. This affects RIOT, because NDP relies on multicast packets to work correctly. Refer to the SDK documentation from Espressif on <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/wifi.html#ap-sleep">AP Sleep</a> for more information.</dd></dl>
<p><a class="anchor" id="esp32_esp_now_network_interface"></a></p>
<h2><a class="anchor" id="autotoc_md76"></a>
&lt;a name="esp32_esp_now_network_interface"&gt; ESP-NOW Network Interface &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>With ESP-NOW, the ESP32 provides a connectionless communication technology, featuring short packet transmission. It applies the IEEE802.11 Action Vendor frame technology, along with the IE function developed by Espressif, and CCMP encryption technology, realizing a secure, connectionless communication solution.</p>
<p>The RIOT port for ESP32 implements in module <code>esp_now</code> a <code>netdev</code> driver which uses ESP-NOW to provide a link layer interface to a meshed network of ESP32 nodes. In this network, each node can send short packets with up to 250 data bytes to all other nodes that are visible in its range.</p>
<dl class="section note"><dt>Note</dt><dd>Module <code>esp_now</code>module is not enabled automatically if the <code>netdev_default</code> module is used. Instead, the application has to add the <code>esp_now</code> module in its makefile when needed.<br  />
 <div class="fragment"><div class="line">USEMODULE += esp_now</div>
</div><!-- fragment --></dd></dl>
<p>For ESP-NOW, ESP32 nodes are used in WiFi SoftAP + Station mode to advertise their SSID and become visible to other ESP32 nodes. The SSID of an ESP32 node is the concatenation of the prefix <code>RIOT_ESP_</code> with the MAC address of its SoftAP WiFi interface. The driver periodically scans all visible ESP32 nodes.</p>
<p>The following parameters are defined for ESP-NOW nodes. These parameters can be overridden by <a href="#esp32_application_specific_board_configuration">application-specific board configurations</a>.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter </th><th class="markdownTableHeadLeft">Default </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_NOW_SCAN_PERIOD </td><td class="markdownTableBodyLeft">10000000UL </td><td class="markdownTableBodyLeft">Defines the period in us at which an node scans for other nodes in its range. The default period is 10 s.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ESP_NOW_SOFT_AP_PASS </td><td class="markdownTableBodyLeft">"ThisistheRIOTporttoESP" </td><td class="markdownTableBodyLeft">Defines the passphrase as clear text (max. 64 chars) that is used for the SoftAP interface of ESP-NOW nodes. It has to be same for all nodes in one network.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ESP_NOW_CHANNEL </td><td class="markdownTableBodyLeft">6 </td><td class="markdownTableBodyLeft">Defines the channel that is used as the broadcast medium by all nodes together.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">ESP_NOW_KEY </td><td class="markdownTableBodyLeft">NULL </td><td class="markdownTableBodyLeft">Defines a key that is used for encrypted communication between nodes. If it is NULL, encryption is disabled. The key has to be of type <code>uint8_t[16]</code> and has to be exactly 16 bytes long.  </td></tr>
</table>
</center><center></center><dl class="section note"><dt>Note</dt><dd>The ESP-NOW network interface (module <code>esp_now</code>) and the <a href="#esp32_wifi_network_interface">Wifi network interface</a> (module <code>esp_wifi</code> or <code>esp_wifi_enterprise</code>) can be used simultaneously, for example, to realize a border router for a mesh network which uses ESP-NOW. In this case the ESP-NOW interface must use the same channel as the AP of the infrastructure WiFi network. All ESP-NOW nodes must therefore be compiled with the channel of the AP asvalue for the parameter 'ESP_NOW_CHANNEL'.</dd></dl>
<h2><a class="anchor" id="autotoc_md77"></a>
&lt;a name="esp32_other_network_devices"&gt; Other Network Devices &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>RIOT provides a number of driver modules for different types of network devices, e.g., IEEE 802.15.4 radio modules and Ethernet modules. The RIOT port for ESP32 has been tested with the following network devices:</p>
<ul>
<li><a href="https://riot-os.org/api/group__drivers__mrf24j40.html">mrf24j40</a> (driver for Microchip MRF24j40 based IEEE 802.15.4</li>
<li><a href="https://riot-os.org/api/group__drivers__enc28j60.html">enc28j60</a> (driver for Microchip ENC28J60 based Ethernet modules)</li>
</ul>
<h3><a class="anchor" id="autotoc_md78"></a>
&lt;a name="esp32_using_mrf24j40"&gt; Using MRF24J40 (module &lt;tt&gt;mrf24j40&lt;/tt&gt;) &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>To use MRF24J40 based IEEE 802.15.4 modules as network device, the <code>mrf24j40</code> driver module has to be added to the makefile of the application:</p>
<div class="fragment"><div class="line">USEMODULE += mrf24j40</div>
</div><!-- fragment --><p>The driver parameters that have to be defined by the board configuration for the MRF24J40 driver module are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MRF24J40_PARAM_CS </td><td class="markdownTableBodyNone">GPIO used as CS signal  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MRF24J40_PARAM_INT </td><td class="markdownTableBodyNone">GPIO used as interrupt signal  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MRF24J40_PARAM_RESET </td><td class="markdownTableBodyNone">GPIO used as reset signal  </td></tr>
</table>
<p>Since each board has different GPIO configurations, refer to the board documentation for the GPIOs recommended for the MRF24J40.</p>
<dl class="section note"><dt>Note</dt><dd>The reset signal of the MRF24J40 based network device can be connected with the ESP32 RESET/EN pin which is broken out on most boards. This keeps the GPIO free defined by <code>MRF24J40_PARAM_RESET</code> free for other purposes.</dd></dl>
<h3><a class="anchor" id="autotoc_md79"></a>
&lt;a name="esp32_using_enc28j60"&gt; Using ENC28J60 (module &lt;tt&gt;enc28j60&lt;/tt&gt;) &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h3>
<p>To use ENC28J60 Ethernet modules as network device, the <code>enc28j60</code> driver module has to be added to the makefile of the application:</p>
<div class="fragment"><div class="line">USEMODULE += enc28j60</div>
</div><!-- fragment --><p>The parameters that have to be defined by board configuration for the ENC28J60 driver module are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENC28J60_PARAM_CS </td><td class="markdownTableBodyNone">GPIO used as CS signal  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ENC28J60_PARAM_INT </td><td class="markdownTableBodyNone">GPIO used as interrupt signal  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENC28J60_PARAM_RESET </td><td class="markdownTableBodyNone">GPIO used as reset signal  </td></tr>
</table>
<p>Since each board has different GPIO configurations, refer to the board documentation for the GPIOs recommended for the ENC28J60.</p>
<dl class="section note"><dt>Note</dt><dd>The reset signal of the ENC28J60 based network device can be connected with the ESP32 RESET/EN pin which is broken out on most boards. This keeps the GPIO free defined by <code>ENC28J60_PARAM_RESET</code> free for other purposes.</dd></dl>
<p><a class="anchor" id="esp32_app_spec_conf"></a></p>
<h1><a class="anchor" id="autotoc_md80"></a>
&lt;a name="esp32_application_specific_configurations"&gt; Application-Specific Configurations &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<p>The board-specific configuration files <code>board.h</code> and <code>periph_conf.h</code> as well well as the driver parameter configuration files <code>&lt;driver&gt;_params.h</code> define the default configurations for peripherals and device driver modules. These are, for example, the GPIOs used, bus interfaces used or available bus speeds. Because there are many possible configurations and many different application requirements, these default configurations are usually only a compromise between different requirements.</p>
<p>Therefore, it is often necessary to change some of these default configurations for individual applications. For example, while many PWM channels are needed in one application, another application does not need PWM channels, but many ADC channels.</p>
<p>There are two ways to give the application the ability to change some of these default configurations:</p>
<ul>
<li>make variable <code>CFLAGS</code></li>
<li>application-specific board or driver configuration file</li>
</ul>
<h2><a class="anchor" id="autotoc_md81"></a>
&lt;a name="esp32_config_make_variable"&gt; Make Variable &lt;tt&gt;CFLAGS&lt;/tt&gt; &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>Using the <code>CFLAGS</code> make variable at the command line, board or driver parameter definitions can be overridden.</p>
<p>Example: &lsquo; CFLAGS=&rsquo;-DESP_LCD_PLUGGED_IN=1 -DLIS3DH_PARAM_INT2=GPIO4' `</p>
<p>When a larger number of board definitions needs be overridden, this approach becomes impractical. In that case, an application-specific board configuration file located in application directory can be used, see sections below.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
&lt;a name="esp32_application_specific_board_configuration"&gt; Application-Specific Board Configuration &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>To override default board configurations, simply create an application-specific board configuration file <code>$APPDIR/board.h</code> in the source directory <code>$APPDIR</code> of the application and add the definitions to be overridden. To force the preprocessor to include board's original <code>board.h</code> after that, add the <code>include_next</code> preprocessor directive as the <b>last</b> line.</p>
<p>For example to override the default definition of the GPIOs that are used as PWM channels, the application-specific board configuration file <code>$APPDIR/board.h</code> could look like the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP32</span></div>
<div class="line"><span class="preprocessor">#define PWM0_CHANNEL_GPIOS { GPIO12, GPIO13, GPIO14, GPIO15 }</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include_next &quot;board.h&quot;</span></div>
</div><!-- fragment --><p>It is important to ensure that the application-specific board configuration <code>$APPDIR/board.h</code> is included first. Insert the following line as the <b>first</b> line to the application makefile <code>$APPDIR/Makefile</code>. </p><div class="fragment"><div class="line">INCLUDES += -I$(APPDIR)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>To make such application-specific board configurations dependent on the ESP32 MCU or a particular ESP32 board, you should always enclose these definitions in the following constructs <div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP32</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef BOARD_ESP32_WROVER_KIT</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="autotoc_md83"></a>
&lt;a name="esp32_application_specific_driver_configuration"&gt; Application-Specific Driver Configuration &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>Using the approach for overriding board configurations, the parameters of drivers that are typically defined in <code>drivers/&lt;device&gt;/include/&lt;device&gt;_params.h</code> can be overridden. For that purpose just create an application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> in the source directory <code>$APPDIR</code> of the application and add the definitions to be overridden. To force the preprocessor to include driver's original <code>&lt;device&gt;_params.h</code> after that, add the <code>include_next</code> preprocessor directive as the <b>last</b> line.</p>
<p>For example, to override a GPIO used for LIS3DH sensor, the application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> could look like the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP32</span></div>
<div class="line"><span class="preprocessor">#define LIS3DH_PARAM_INT2           (GPIO_PIN(0, 4))</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include_next &quot;lis3dh_params.h&quot;</span></div>
</div><!-- fragment --><p>It is important to ensure that the application-specific driver parameter file <code>$APPDIR/&lt;device&gt;_params.h</code> is included first. Insert the following line as the <b>first</b> line to the application makefile <code>$APPDIR/Makefile</code>. </p><div class="fragment"><div class="line">INCLUDES += -I$(APPDIR)</div>
</div><!-- fragment --><p>Please note:** To make such application-specific board configurations dependent on the ESP32 MCU or a particular ESP32 board, you should always enclose these definitions in the following constructs: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CPU_ESP32</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef BOARD_ESP32_WROVER_KIT</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md84"></a>
&lt;a name="esp32_debugging"&gt; Debugging &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h1>
<h2><a class="anchor" id="autotoc_md85"></a>
&lt;a name="esp32_jtag_debugging"&gt; JTAG Debugging &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>ESP32 provides a JTAG interface at GPIOs 12 ... 15 for On-Chip Debugging.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">ESP32 Pin </th><th class="markdownTableHeadLeft">ESP32 signal name JTAG Signal  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CHIP_PU </td><td class="markdownTableBodyLeft">TRST_N  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">GPIO15 (MTDO) </td><td class="markdownTableBodyLeft">TDO  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">GPIO12 (MTDI) </td><td class="markdownTableBodyLeft">TDI  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">GPIO13 (MTCK) </td><td class="markdownTableBodyLeft">TCK  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">GPIO14 (MTMS) </td><td class="markdownTableBodyLeft">TMS  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">GND </td><td class="markdownTableBodyLeft">GND  </td></tr>
</table>
<p>This JTAG interface can be used with OpenOCD and GDB to debug your software on instruction level. When you compile your software with debugging information (module <code>esp_gdb</code>) you can also debug on source code level as well.</p>
<dl class="section note"><dt>Note</dt><dd>When debugging, the GPIOs used for the JTAG interface must not be used for anything else.</dd></dl>
<p>Detailed information on how to configure the JTAG interface of the ESP32 and to setup of OpenOCD and GDB can be found in section JTAG Debugging in the <a href="https://esp-idf.readthedocs.io/en/latest/api-guides/jtag-debugging/index.html">ESP-IDF Programming Guide</a>.</p>
<h2><a class="anchor" id="autotoc_md86"></a>
&lt;a name="esp32_qemu_mode_and_gdb"&gt; QEMU Mode and GDB &lt;/a&gt;  [&lt;a href="#esp32_toc"&gt;TOC&lt;/a&gt;]</h2>
<p>When you execute command <code>make flash</code> with QEMU mode enabled (<code>QEMU=1</code>), instead of loading the image to the target hardware, a binary image called <code>esp32flash.bin</code> is created in the target directory. Furthermore, two ROM binary files <code>rom.bin</code> and <code>rom1.bin</code> are copied to the target directory. This files file can then be used together with QEMU to debug the code in GDB.</p>
<p>The binary image can be compiled with debugging information using module <code>esp_gdb</code> or optimized without debugging information (default). The latter one is the default. The version with debugging information can be debugged in source code while the optimized version can only be debugged in assembler mode.</p>
<p>To use QEMU, you have to install QEMU for Xtensa with ESP32 machine implementation as following.</p>
<div class="fragment"><div class="line">cd $HOME/src</div>
<div class="line">git clone git:<span class="comment">//github.com/Ebiroll/qemu_esp32</span></div>
<div class="line">cp qemu_esp32/bin/xtensa-esp32-elf-gdb $HOME/esp/xtensa-esp32-elf/bin/xtensa-esp32-elf-gdb.qemu</div>
<div class="line">rm -rf qemu_esp32</div>
<div class="line"> </div>
<div class="line">git clone git:<span class="comment">//github.com/Ebiroll/qemu-xtensa-esp32</span></div>
<div class="line">cd qemu-xtensa-esp32</div>
<div class="line">./configure --disable-werror --prefix=$HOME/esp/qemu-esp32 --target-list=xtensa-softmmu,xtensaeb-softmmu</div>
<div class="line">make install</div>
<div class="line">cd ..; rm -rf qemu-xtensa-esp32 # optional</div>
</div><!-- fragment --><p>Once the compilation has been finished, QEMU for Xtensa with ESP32 machine implementation should be available in <code>$HOME/esp/qemu-esp32</code> and you can change to your application target directory to start it in one terminal window , for example</p>
<div class="fragment"><div class="line">cd $HOME/src/RIOT-Xtensa-ESP/tests/shell/bin/esp32-<span class="keyword">generic</span></div>
<div class="line">$HOME/esp/qemu-esp32/bin/qemu-system-xtensa -d guest_errors,unimp -cpu esp32 -M esp32 -m 4M -S -s &gt; io.txt</div>
</div><!-- fragment --><p>where <code>$HOME/src/RIOT-Xtensa-ESP</code> is the root directory of RIOT and <code>tests/shell</code> is the application.</p>
<dl class="section note"><dt>Note</dt><dd>QEMU starts always the files <code>esp32flash.bin</code>, <code>rom.bin</code> and <code>rom1.bin</code> in local directory. Therefore, Please make sure that you are in the correct destination directory before starting QEMU.</dd></dl>
<p>In the second terminal window, you can then start GDB and connect to the emulation for the example. </p><div class="fragment"><div class="line">xtensa-esp32-elf-gdb.qemu $HOME/src/RIOT-Xtensa-ESP/tests/shell/bin/esp32-<span class="keyword">generic</span>/tests_shell.elf</div>
</div><!-- fragment --><p>To start debugging, you have to connect to QEMU with command: </p><div class="fragment"><div class="line">(gdb) target remote :1234</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>QEMU for Xtensa ESP32 does not support interrupts. That is, once your application uses interrupts, e.g., timers, the application cannot be debugged using QEMU together with GDB. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__cpu__esp__common__esp__now"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp__common__esp__now.html">ESP-NOW netdev interface</a></td></tr>
<tr class="memdesc:group__cpu__esp__common__esp__now"><td class="mdescLeft">&#160;</td><td class="mdescRight">WiFi based ESP-NOW network device driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp__common__esp__wifi"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp__common__esp__wifi.html">ESP-WiFi netdev interface</a></td></tr>
<tr class="memdesc:group__cpu__esp__common__esp__wifi"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structNetwork.html" title="Network struct within mqtt paho.">Network</a> device driver for the ESP SoC WiFi interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp32__esp__can"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp32__esp__can.html">ESP32 CAN controller</a></td></tr>
<tr class="memdesc:group__cpu__esp32__esp__can"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN controller driver for ESP32 (esp_can) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp32__esp__eth"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp32__esp__eth.html">ESP32 Ethernet netdev interface</a></td></tr>
<tr class="memdesc:group__cpu__esp32__esp__eth"><td class="mdescLeft">&#160;</td><td class="mdescRight">ESP32 ethernet network device driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cpu__esp32__conf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__esp32__conf.html">ESP32 compile configurations</a></td></tr>
<tr class="memdesc:group__cpu__esp32__conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time configuration macros for ESP32 modules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:adc__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc__arch_8h.html">adc_arch.h</a></td></tr>
<tr class="memdesc:adc__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture specific ADC functions for ESP32. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc__ctrl_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc__ctrl_8h.html">adc_ctrl.h</a></td></tr>
<tr class="memdesc:adc__ctrl_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADC controller functions used by ADC and DAC peripherals. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp32_2include_2gpio__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2gpio__arch_8h.html">gpio_arch.h</a></td></tr>
<tr class="memdesc:esp32_2include_2gpio__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture specific GPIO functions for ESP32. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp32_2include_2irq__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2irq__arch_8h.html">irq_arch.h</a></td></tr>
<tr class="memdesc:esp32_2include_2irq__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the kernels irq interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp32_2include_2periph__cpu_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html">periph_cpu.h</a></td></tr>
<tr class="memdesc:esp32_2include_2periph__cpu_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU specific definitions and functions for peripheral handling. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtt__arch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtt__arch_8h.html">rtt_arch.h</a></td></tr>
<tr class="memdesc:rtt__arch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture specific RTT functions for ESP32. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp32_2include_2sdk__conf_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2sdk__conf_8h.html">sdk_conf.h</a></td></tr>
<tr class="memdesc:esp32_2include_2sdk__conf_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDK configuration compatible to the ESP-IDF. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:esp32_2include_2syscalls_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2syscalls_8h.html">syscalls.h</a></td></tr>
<tr class="memdesc:esp32_2include_2syscalls_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of required system calls. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aadc__arch_8h_html_a8d356a7b25a9dd653be63d70c94942a2"><div class="ttname"><a href="adc__arch_8h.html#a8d356a7b25a9dd653be63d70c94942a2">adc_vref_to_gpio25</a></div><div class="ttdeci">int adc_vref_to_gpio25(void)</div><div class="ttdoc">Output ADC reference voltage to GPIO25.</div></div>
<div class="ttc" id="agroup__drivers__periph__adc_html_ga1679abe0c8c15b3df16ac5732512642a"><div class="ttname"><a href="group__drivers__periph__adc.html#ga1679abe0c8c15b3df16ac5732512642a">adc_t</a></div><div class="ttdeci">unsigned int adc_t</div><div class="ttdoc">Define default ADC type identifier.</div><div class="ttdef"><b>Definition:</b> <a href="adc_8h_source.html#l00072">adc.h:72</a></div></div>
<div class="ttc" id="aadc__arch_8h_html_aa71353583a04674cb8a03f8117e8ecd3"><div class="ttname"><a href="adc__arch_8h.html#aa71353583a04674cb8a03f8117e8ecd3">adc_attenuation_t</a></div><div class="ttdeci">adc_attenuation_t</div><div class="ttdoc">Attenuations that can be set for ADC lines.</div><div class="ttdef"><b>Definition:</b> <a href="adc__arch_8h_source.html#l00033">adc_arch.h:33</a></div></div>
<div class="ttc" id="aadc__arch_8h_html_a6786cc4a1c5602bf2466638ab3e8dff6"><div class="ttname"><a href="adc__arch_8h.html#a6786cc4a1c5602bf2466638ab3e8dff6">adc_set_attenuation</a></div><div class="ttdeci">int adc_set_attenuation(adc_t line, adc_attenuation_t atten)</div><div class="ttdoc">Set the attenuation for the ADC line.</div></div>
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Tue Nov 24 2020 19:46:59 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.17</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
